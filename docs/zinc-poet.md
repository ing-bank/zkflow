# Zinc Poet

This document describes the design and implementation of our Zinc code generation framework `zinc-poet`.  The Zinc code
is generated by the `gradle-plugin`, using functionality that is implemented by the modules in the `zinc-poet`
directory.

The `zinc-poet` directory contains the following gradle modules:

- `zinc-poet`: A Kotlin DSL to describe and generate generic zinc code
- `zinc-bfl`: A Kotlin DSL to describe types to be deserialized from BFL encoded bit-arrays in zinc
- `zinc-code-generation`: Generate complete zinc circuits for `ZKCommandData` instances

## `zinc-poet`

The `zinc-poet` module defines a Kotlin DSL to programmatically generate zinc code. It captures the whole structure of a
zinc file except function/method bodies. It helps users to generate syntactically correct zinc code.

The following main abstractions/interfaces can be found in `com.ing.zinc.poet.Spec.kt`.

- `ZincGenerable`: zinc code can be generated for this class
- `ZincType`: this class represents a zinc type, i.e. primitives, arrays, structs and enums
- `ZincInvocable`: this class represents an invokable unit, i.e. `ZincFunction` and `ZincMethod`
  - This abstraction was introduced to add both associated functions and methods to an `impl` block
- `ZincFileItem`: this class is a top-level item that can be directly included in a `ZincFile`
  - i.e. mod, use, fn, struct, impl, enum, const, type, comment, newline

These interfaces are well documented, and form a good starting point to understand the whole implementation.

### Example

As an idea what `zinc-poet` looks like is given below, for a more complete example see `ZincFileTest`.  This example
shows the definition of a struct together with implementation and of an enum with a single field.

```kotlin
zincFile {
    struct {
        name = "TestStruct"
        field {
            name = "test_field"
            type = ZincPrimitive.Bool
        }
    }
    impl {
        name = "TestStruct"
        method {
            name = "test_method"
            returnType = ZincPrimitive.Bool
            body = "true"
        }
    }
    enum {
        name = "TestEnum"
        variant {
            name = "TEST_VARIANT"
            ordinal = 0
        }
    }
}.generate()
```

The above Kotlin expression will generate the following String:

```rust
struct TestStruct {
    test_field: bool,
}
impl TestStruct {
    fn test_method(
        self,
    ) -> bool {
        true
    }
}
enum TestEnum {
    TEST_VARIANT = 0,
}
```

### Indentation

The `String.indent(Indentation)` extension function is used to keep the generated zinc code well indented, when inserting multi-line strings into string templates.
It takes an indentation argument, which will determine what will be added after every newline that occurs in the inserted string.
The indentation must be the total number of spaces the current line is indented.

Consider the following code, note that indentation argument here is 8 spaces, because the line that contains the indent
expression is indented 8 spaces.

```kotlin
fun test(): String {
    val toInsert = listOf("one", "two", "three").joinToString(",\n", prefix = "[\n", postfix = "\n]") { "    $it" }
    return """
        myList = ${toInsert.indent(8.spaces)}
    """.trimIndent()
}
```
Value of `toInsert`:
```
[
    one,
    two,
    three
]
```
Result with `indent`:
```
myList = [
    one,
    two,
    three
]
```
When the indentation would not be applied, the result would be:
```
        myList = [
    one,
    two,
    three
]
```

## `zinc-bfl`

The `zinc-bfl` module builds on top of `zinc-poet`, to generate zinc modules that contain types that can be deserialized
from a BFL (Binary-Fixed-Length) encoded bit-array. Since these classes will be used to write contract rule
verifications, the generated code will contain methods to help with that purpose. The generated types using `zinc-bfl`
are self-contained and semantically correct.

The basic abstractions/interfaces are:

- `BflType`: Abstraction for a BFL encoded type
- `BflModule`: Abstraction for a BFL encoded type that is written to a file.

These classes are well documented and are a good starting point to understand this module.

The whole witness, as generated by ZKFlow will contain multiple transaction components of different sizes. In order to
support this, the code is generated with `CodeGenerationOptions`, which contains a list of `TransactionComponentOptions`.
When generating code, a different deserialization method is generated for each transaction component, following the
scheme `deserialize_from_<TRANSACTION_COMPONENT_NAME>`.

### Composable type system

Following `zinc-poet` this module offers a Kotlin DSL to describe the types. Since `zinc-bfl` generates deserialization
methods for BFL encoded bit-arrays, the type system tracks the number of bits in the serialized form for every type.

Every type implements the `BflType` interface, meaning that it can be deserialized (`deserializeExpr()`), instantiated
with a default values (`defaultExpr()`), checked for partial equality (`equalsExpr()`) and know the size (`sizeExpr()`).

### Generated methods/functions

Apart from deserialization methods, for some types additional methods are generated that are either used internally, or
can be helpful while writing contract rule verification functions.

#### BflStruct

- `new`: associated constructor function, each field has a parameter
- `empty`: associated constructor function, each field will be set to a default value
- `equals`: equality method, verifies whether all fields are equal

#### BflList

Since `BflList` extends `BflStruct` it contains the `new`, `empty` and `equals` methods.
In addition the following methods are added.
Please note that the notation here is not actual zinc notation, since zinc does not support generics.

- `list_of(values: [T; CAPACITY]) -> List<T>`: associated constructor function, where size is initialized to full capacity
- `get(self, index: u32) -> T`: retrieve element at requested index, panics when index out of bounds
- `add(mut self, element: T) -> Self`: add an element to the list, panics when there is no capacity
- `all_equals(self, element: T) -> bool`: check whether all elements in the list are equals to a given element
- `is_subset_of(self, other: Self) -> bool`: check whether this list is a subset of another list
- `is_distinct(self) -> bool`: check whether all items in the list are distinct

If the element type of the list is a struct, then for each field the following methods are generated.
The fields are even determined recursively.

- `extract_FIELD(self) -> List<R>`: extract a list with FIELD values, 
  - pseudo code: `self.map { it.FIELD }` 
- `index_of_single_by_FIELD(self, by: R) -> u32`: get the index of a single element that matches FIELD, or panic
  - pseudo code: `self.indexOfSingle { it.FIELD == by }` 
- `single_by_FIELD(self, by: R) -> T`: get a single element that matches FIELD, or panic
  - pseudo code: `self.single { it.FIELD == by }` 

As an example how the recursion works, consider a list of type `Bar` with the following definition:

```rust
struct Foo {
  a: u32
}
struct Bar {
  x: Foo,
  y: u32
}
```

The above methods will be generated for each `FIELD` in (`y`, `x`, `x_a`).

### Adding more functions

Additional functions and methods to `BflModules` can be registered with the `BflModule.registerMethod`
extension method. For example:

```kotlin
BflModule.registerMethod(
    moduleId = "StructWithArrayFields",
    zincMethod {
        name = "foo"
        returnType = ZincPrimitive.Bool
        body = "self.bar[0] || self.bar[1]"
    }
)
```

### Generating structure tree

For debugging purposes, the structure of a type can be generated using the `BflType.toStructureTree` method.

```kotlin
val a = struct {
    name = "Foo"
    field { 
        name = "bar"
        type = BflPrimitive.U32
    }
    field {
        name = "baz"
        type = list {
            capacity = 8
            elementType = BflPrimitive.U8
        }
    }
}
println(a.toStructureTree().toString())
```
This will write:

```
Foo: 128 bits (16 bytes)
├── bar: 32 bits (4 bytes)
│   └── u32: 32 bits (4 bytes)
└── baz: 96 bits (12 bytes)
    └── U8List8: 96 bits (12 bytes)
        ├── size: 32 bits (4 bytes)
        │   └── u32: 32 bits (4 bytes)
        └── values: 64 bits (8 bytes)
            └── [u8; 8]: 64 bits (8 bytes)
                └── u8: 8 bits (1 bytes)
```

## `zinc-code-generation`

The `zinc-code-generation` module is responsible for generating whole zinc circuits for a `ZKCommandData` instance. The
generated circuit will perform the following operations

- Deserialize the `Witness` to a `CommandContext`
- Verify the contract rules on `CommandContext`
- Generate hashes and return them in a `PublicInput`

The fields that are present in the `Witness`, `CommandContext` and `PublicInput` are completely determined by the
`ResolvedZKCommandMetadata` of the command. This logic is implemented in `TransactionComponentContainer`.

This module provides a `main` method in `GenerateZincCircuits`. This method is invoked by `GenerateZincCircuitsTask` in
the `gradle-plugin` module.

### Generated circuit directory

For each command a circuit folder is generated with the following structure:

- Zargo.toml: The zinc manifest
- **src**: Folder containing the zinc sources
- **structure**: Folder containing the structure of the transaction components, generated with `toStructureTree`
