# Zinc Poet

This document describes the design and implementation of our Zinc code generation framework `zinc-poet`.  The Zinc code
is generated by the `gradle-plugin`, using functionality that is implemented by the modules in the `zinc-poet`
directory.

The `zinc-poet` directory contains the following modules:

- `zinc-poet`: A Kotlin DSL to generate zinc code
- `zinc-bfl`: A Kotlin DSL to generate zinc types that can be deserialized from BFL encoded bit-array
- `zinc-code-generation`: Generate complete zinc circuits based on `ResolvedZKCommandMetadata`

## `zinc-poet`

The `zinc-poet` module defines a Kotlin DSL to programmatically generate zinc code. It captures the whole structure of a
zinc file except function/method bodies. It helps users to generate syntactically correct zinc code. There are no
garantees about semantics.

The following main abstractions/interfaces can be found in `com.ing.zinc.poet.Spec.kt`.

- `ZincGeneratable`: zinc code can be generated for this class
- `ZincType`: this class represents a zinc type
- `ZincInvokeable`: this class represents an invokable unit, either `ZincFunction` or `ZincMethod`
  - This abstraction was introduced to add both functions and methods to an `impl` block
- `ZincFileItem`: this class is a top-level item that can be directly included in a `ZincFile`

These classes are well documented, and form a good starting point to understand the whole implementation. The most
top-level item is `ZincFile`, which is a container for `ZincFileItem`s.

- `mod`: import module
- `use`: import items from a module
- `fn`: define a function
- `struct`: define a structure with fields
- `impl`: define functions and methods related to a `struct`
- `enum`: define an enumeration of values
- `const`: define a constant value
- `type`: define a type
- comment
- newline

### Composable type system

Zinc types are composable using arrays and structs. `zinc-poet` offers the following interfaces to define and create
types:

- `ZincType`
  - `ZincPrimitive`
  - `ZincEnum`: enum *NAME* { *VARIANT_NAME*, ... }
  - `ZincArray`: [`ZincType`; *SIZE*]
  - `ZincStruct`: struct *NAME* { *FIELD_NAME*: `ZincType`, ... }
  - `ZincTypeDef`: type *NAME* = `ZincType`;

### Example

As an idea what `zinc-poet` looks like is given below, for a more complete example see `ZincFileTest`.  This example
shows the definition of a struct together with implementation and of an enum with a single field.

```kotlin
zincFile {
    struct {
        name = "TestStruct"
        field {
            name = "test_field"
            type = ZincPrimitive.Bool
        }
    }
    impl {
        name = "TestStruct"
        method {
            name = "test_method"
            returnType = ZincPrimitive.Bool
            body = "true"
        }
    }
    enum {
        name = "TestEnum"
        variant {
            name = "TEST_VARIANT"
            ordinal = 0
        }
    }
}.generate()
```

The above Kotlin expression will generate the following String:

```rust
struct TestStruct {
    test_field: bool,
}
impl TestStruct {
    fn test_method(
        self,
    ) -> bool {
        true
    }
}
enum TestEnum {
    TEST_VARIANT = 0,
}
```

### Indentation

The generated zinc code is well indented, to make it as readable as possible. In all the `zinc-poet` modules, heavy use
is made of multi-line strings using `trimIndent()`. When inserting multi line strings to such a string, one must ensure
proper indentation, so that `trimIndent()` will not be confused. This problem is solved using the
`String.indent(Indentation)` extension function.

The `indent` function takes an indentation argument, which will determine what will be added after every newline that
occurs in the inserted string.

Consider the following code, note that indentation here is 8 spaces, because the line that contains the indent
expression is indented 8 spaces.

```kotlin
fun test(): String {
    val toInsert = listOf("one", "two", "three").joinToString(",\n", prefix = "[\n", postfix = "\n]") { "    $it" }
    return """
        myList = ${toInsert.indent(8.spaces)}
    """.trimIndent()
}
```
Value of `toInsert`:
```
[
    one,
    two,
    three
]
```
Result with `indent`:
```
myList = [
    one,
    two,
    three
]
```
When the indentation would not be applied, the result would be:
```
        myList = [
    one,
    two,
    three
]
```

## `zinc-bfl`

The `zinc-bfl` module builds on top of `zinc-poet`, to generate zinc modules that contain types that can be deserialized
from a BFL (Binary-Fixed-Length) encoded bit-array. Since these classes will be used to write contract rule
verifications, the generated code will contain methods to help with that purpose. The generated types using `zinc-bfl`
are self-contained and semantically correct.

The basic abstractions/interfaces are:

- `BflType`: Abstraction for a BFL encoded type
- `BflModule`: Abstraction for a BFL encoded type that is written to a file.

These classes are well documented and are a good starting point to understand this module.

The whole witness, as generated by ZKFlow will contain multiple groups of different sizes. In order to support this
`CodeGenerationOptions` contains a list of `TransactionComponentOptions`. When generating code, a different
deserialization method is generated for each transaction component.

### Composable type system

Following `zinc-poet` this module offers a Kotlin DSL to describe the types. Since `zinc-bfl` generates deserialization
methods for BFL encoded bit-arrays, the type system tracks the number of bits in the serialized form for every type.

Every type implements the `BflType` interface, meaning that it can be deserialized (`deserializeExpr()`), instantiated
with a default values (`defaultExpr()`), checked for partial equality (`equalsExpr()`) and know the size (`sizeExpr()`).

### Generated methods/functions

Apart from deserialization methods, for some types additional methods are generated that are either used internally, or
can be helpful while writing contract rule verification functions.

#### BflStruct

- `new`: associated constructor function, each field has a parameter
- `empty`: associated constructor function, each field will be set to a default value
- `equals`: equality method, verifies whether all fields are equal

#### BflList

Since `BflList` extends `BflStruct` it contains the `new`, `empty` and `equals` methods. In addition:

- `list_of`: associated constructor function, where size is initialized to full capacity
- `get`: retrieve element at requested index
- `add`: add an element to the list, panics when there is no capacity
- `all_equals`: check whether all elements in the list are equals to a given element
- `is_subset_of`: check whether this list is a subset of another list
- `is_distinct`: check whether all items in the list are distinct
- `extract_FIELD`: extract a list with FIELD values
- `index_of_single_by_FIELD`: get the index of a single element that matches FIELD, or panic
- `single_by_FIELD`: get a single element that matches FIELD, or panic

### Adding more functions

Additional functions and methods to `BflModules` can be registered with the `BflModule.registerMethod`
extension method. For example:

```kotlin
BflModule.registerMethod(
    "StructWithArrayFields",
    zincMethod {
        name = "foo"
        returnType = ZincPrimitive.Bool
        body = "self.bar[0] || self.bar[1]"
    }
)
```

### Generating structure tree

For debugging purposes, the structure of a type can be generated using the `BflType.toStructureTree` method. The
generated `Tree` can be converted to a string that looks like:

```
PublicKeyEdDsaEd25519Sha512: 384 bits (48 bytes)
└── bytes: 384 bits (48 bytes)
    └── ByteArray44: 384 bits (48 bytes)
        ├── size: 32 bits (4 bytes)
        │   └── u32: 32 bits (4 bytes)
        └── values: 352 bits (44 bytes)
            └── [i8; 44]: 352 bits (44 bytes)
                └── i8: 8 bits (1 bytes)
```

## `zinc-code-generation`

The `zinc-code-generation` module is responsible for generating whole zinc circuits for a `ZKCommandData` instance. The
generated circuit will perform the following operations

- Deserialize the `Witness` to a `CommandContext`
- Verify the contract rules on `CommandContext`
- Generate hashes and return them in a `PublicInput`

The fields that are present in the `Witness`, `CommandContext` and `PublicInput` are completely determined by the
`ResolvedZKCommandMetadata` of the command. This logic is implemented in `TransactionComponentContainer`.

This module provides a `main` method in `GenerateZincCircuits`. This method is invoked by `GenerateZincCircuitsTask` in
the `gradle-plugin` module. The reason that this is implemented as a separate java process is that this way the correct
classpath can be used, and the `ServiceLoader` can be used to load all `CommandDataSerializerRegistryProvider`, which
provide the commands circuits must be generated for.

### Generated circuit directory

For each command a circuit folder is generated with the following structure:

- Zargo.toml: The zinc manifest
- **src**: Folder containing the zinc sources
- **structure**: Folder containing the structure of the transaction components
