@startuml
title Simplified sequence of events for ZKP transaction finality
skinparam backgroundColor white



Init as "Initiator" -> Init: stx = ZKTransactionBuilder.toSignedTransaction()
group ZKCollectSignaturesFlow
    Init -> ctp as "Counterparty": stx
    ctp -> ctp: <font color=red><b>ZKResolveTransactionsFlow(stx)</b></font>
    note left
        The ZKResolveTransactionsFlow
        does not collect and verify
        a chain of SignedTransactions.

        It collects and verifies a chain
        of FilteredTransactions with proofs.
    end note
    ctp -> ctp: stx.verify
    ctp -> ctp: sig = stx.sign()
    ctp -> Init: sig
    Init -> Init: fullySignedTx = SignedTransaction + TransactionSignature
end

group ZKFinalityFlow
    Init -> Init: <font color=red><b>proof = ZKService.prove(fullySignedTx)</b></font>
    Init -> Init: ftx = buildFilteredTx(fullySignedTx)
    note right
        Filtered Merkle tree.
        Same transaction id.
        Id is input to proof verification
    end note
    group ZKNotaryFlow.Client
        Init -> notary as "Notary":  send(Payload(ftx, proof))
        group ZKNotaryServiceFlow
            notary -> notary: ZKResolveTransactionsFlow(ftx)
            note left
                The ZKResolveTransactionsFlow
                does not collect and verify
                a chain of SignedTransactions.

                It collects and verifies a chain
                of FilteredTransactions with proofs.
            end note
            notary -> notary: ftx.verify
            notary -> notary: <font color=red><b>verify(proof)</b></font>
            notary -> notary: notarySig = commitInputStates
            notary -> Init: NotarySig
        end
    end
    Init -> Init: notarisedStx = fullySignedTx + notarySig
    Init -> Init: serviceHub.recordTransactions(notarisedStx)
    Init -> ctp: send(notarisedStx)
end
@enduml