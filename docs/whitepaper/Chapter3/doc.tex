\chapter*{Computation of ZKStateRef}

%In standard Corda, the input states to a transaction are identified by a StateRef. This is a combination of the \tx~id of the \tx~ that created that state and its index in that \tx's output list. This enables a \tx~ verifier to resolve the chain of previous transactions so that it can fetch them and verify all of them. This then allows the verifier to confirm that the existence and contents of each input state of the current (head) transaction is valid: in a WireTransaction, the \tx~ id is calculated based on (among other components) the serialized form of the outputs (\texttt{<TransactionState<ContractState>>})  in a transaction. This means that from any historical \tx, a verifier can deserialize all outputs. These are the UTXOs of that \tx and their contents can be used as the inputs of the next transaction verification.

%In the case of a ZKTransaction, the verifier will not have this history, so they will have to confirm the validity of inputs states another way. Additionally, again because verifiers do not receive transaction history to get the full output states from, they can't determine if the contents of an input State they receive as part of a \tx actually match a StateRef in that transaction. This is because as described above, a StateRef is only a pointer to the location of this UTXO in the \tx chain. It doesn't say anything about the contents of the State. To solve this problem, we introduce the ZKStateRef: this is a StateRef that does not give information about which transaction created this state. What a ZKStateRef will do is represent the contents of the state, so that a verifier can confirm that the state contents match the ZKStateRef: $\text{ZKStateRef} = H(\text{State})$.

