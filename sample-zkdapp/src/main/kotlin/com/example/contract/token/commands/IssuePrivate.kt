package com.example.contract.token.commands

import com.example.contract.token.ExampleToken
import com.ing.zkflow.annotations.ZKP
import com.ing.zkflow.common.contracts.ZKCommandData
import com.ing.zkflow.common.zkp.metadata.commandMetadata
import org.intellij.lang.annotations.Language

@ZKP
class IssuePrivate : ZKCommandData {
    override val metadata = commandMetadata {
        numberOfSigners = 1
        outputs {
            private(ExampleToken::class) at 0
        }
    }

    // This is the circuit code for the ZKP circuits smart contract rules
    // Fields will be identical to the Kotlin fields, except in snake case instead of camel case.
    // To help you determine which fields from Kotlin are mapped to which fields in the ZKP circuit, you can check the following files that
    // are generated by ZKFlow:
    // - The generated ZKP circuit sources for any command that uses this state. These are created during kotlin compilation.
    //    In this case, have a look at the `IssuePrivate` command in `build/zinc/issue_private/` or any of the other commands that use
    //    this state. In those directories, you can find the following:
    //    - `structure/module_outputs_example_token_transaction_component.txt`. Describes the structure of this transaction component.
    //      Types and fields should match 1:1 with the generated kotlin structure mentioned below.
    //    - `src/module_example_token.zn`: the generated Zinc source for this state class. Naming is always: `module_<<state_class_to_snake_case>>.zn`
    //      Within this file you can find what other generated Zinc types are called and they can be found in the same way in the same directory.
    // - `src/main/zkp/structure.json`. This file is generated by calling `./gradlew generateZkpStructure`. This describes the Kotlin
    //   structure of all components that can be found in a transaction.
    @Language("Rust")
    override fun verifyPrivate(): String {
        return """
            mod module_command_context;
            use module_command_context::CommandContext;

            fn verify(ctx: CommandContext) {
                // Checks on structure are enforced by the transaction metadata. So no need to check here.
                let output = ctx.outputs.example_token_0;
                
                assert!(output.data.amount.quantity > 0 as i64, "[IssuePrivate] Quantity must be positive");

                assert!(ctx.signers.contains(output.data.amount.issuer.public_key), "[IssuePrivate] Issuer must sign");
            }
        """.trimIndent()
    }
}