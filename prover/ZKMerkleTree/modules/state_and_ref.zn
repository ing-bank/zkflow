type RefBits = [bool; REF_BITS];
type StateBits = [bool; STATE_BITS];

struct Party {
    owning_key: PubKey,
}

// This struct is userland code, and will be generated from Kotlin in the future
struct TestState {
    owner: Party,
    value: i32,
}

//This struct follows the structure in the original Corda TransactionState structure. The fields
// contractCN, encumbrance and constraint are commented out and declared bool intentionally to
// reserve their place in the structure. In the current implementation we don't use these fields,
// if they are going to be included, they should be declared with the corresponding data type.
struct TransactionState {
    data: TestState,
    //contractCN: bool,
    notary: Party,
    //encumbrance: bool,
    //constraint: bool,
}

struct TransactionStatePaddingWrapper {
    content: TransactionState,
    is_filler: bool,
}

struct StateRef {
    txhash: HashDigest,
    index: i32,
}

struct StateAndRef {
    state: TransactionState,
    reference: StateRef,
}

struct StateAndRefPaddingWrapper {
    content: StateAndRef,
    is_filler: bool,
}

impl StateRef {
    fn fingerprint(this: StateRef) -> RefBits {
        let mut state_ref_bits = [false; REF_BITS];

        let txhash_fingerprint = HashDigest::fingerprint(this.txhash);
        for i in 0..HASH_BITS {
            state_ref_bits[i] = txhash_fingerprint[i];
        }

        let stateref_index_bits = to_bits(this.index);
        for i in 0..U32_BITS {
            state_ref_bits[HASH_BITS + i] = stateref_index_bits[i];
        }
        state_ref_bits
    }

    fn compute_leaf_hash(
        this: StateRef,
        privacy_salt: PrivacySalt,
        group_index: u32,
        internal_index: u32,
    ) -> HashDigestBits {
        //fingerprint
        let fingerprint_ref = fingerprint(this);

        //compute nonce
        let mut nonce = compute_nonce(privacy_salt, group_index, internal_index);
        //dbg!("   nonce = {}", digest_to_bytes(nonce));

        // message = nonce || ref
        let mut message: [bool; HASH_BITS + REF_BITS] = [false; HASH_BITS + REF_BITS];
        for i in 0..HASH_BITS {
            message[i] = nonce[i];
        }
        for i in 0..REF_BITS {
            message[HASH_BITS + i] = fingerprint_ref[i];
        }
        //dbg!("   digest input = {}", hashref_to_bytes(message));
        blake2s(message)
    }
}


impl TransactionState {
    fn fingerprint(this: TransactionState) -> [bool; STATE_BITS] {
        let mut result = [false; STATE_BITS];

        // TODO: Separate the fingerprint for the actual ZKContractState our of here.
        // That means that TransactionState.data is asked for its own fingerprint.

        //state_bits = dataOwner_owning_key || value || notary_owning_key
        //dataOwner_owning_key
        result[0..PUBKEY_BITS] = PubKey::fingerprint(this.data.owner.owning_key);
        //value
        result[PUBKEY_BITS..(PUBKEY_BITS + U32_BITS)] = to_bits(this.data.value);
        //notary_owning_key
        result[(PUBKEY_BITS + U32_BITS)..STATE_BITS] =
            PubKey::fingerprint(this.notary.owning_key);

        result
    }

    fn compute_leaf_hash(
        this: TransactionState,
        nonce: HashDigestBits,
    ) -> HashDigestBits {
        // dbg!(">> compute_leaf_hash_transactionstate");

        // message = nonce || state
        let mut message = [false; HASH_BITS + STATE_BITS];
        for i in 0..HASH_BITS {
            message[i] = nonce[i];
        }

        let fingerprint_state = fingerprint(this);
        for i in 0..STATE_BITS {
            message[HASH_BITS + i] = fingerprint_state[i];
        }
        // dbg!("   digest input = {}", hashstate_to_bytes(message));
        blake2s(message)
    }
}
