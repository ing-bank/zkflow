const STATE_BYTES: u16 = PUBKEY_BYTES + U32_BYTES + PUBKEY_BYTES;
const STATE_FINGERPRINT_BYTES: u16 = PUBKEY_BYTES + U32_BYTES + PUBKEY_BYTES;
const STATE_FINGERPRINT_BITS: u16 = STATE_FINGERPRINT_BYTES * BYTE_BITS;

type StateBytes = [u8; STATE_BYTES];
type StateFingerprintBits = [bool; STATE_FINGERPRINT_BITS];

const REF_FINGERPRINT_BYTES: u16 = NODE_DIGEST_BYTES + U32_BYTES;
const REF_FINGERPRINT_BITS: u16 = REF_FINGERPRINT_BYTES * BYTE_BITS;

type RefFingerprintBits = [bool; REF_FINGERPRINT_BITS];

struct Party {
    owning_key: PubKey,
}

// This struct is userland code, and will be generated from Kotlin in the future
struct TestState {
    owner: Party,
    value: i32,
}

//This struct follows the structure in the original Corda TransactionState structure. The fields
// contractCN, encumbrance and constraint are commented out and declared bool intentionally to
// reserve their place in the structure. In the current implementation we don't use these fields,
// if they are going to be included, they should be declared with the corresponding data type.
struct TransactionState {
    data: TestState,
    //contractCN: bool,
    notary: Party,
    //encumbrance: bool,
    //constraint: bool,
}

struct TransactionStatePaddingWrapper {
    content: TransactionState,
    is_filler: bool,
}

struct StateRef {
    txhash: NodeDigestDto,
    index: i32,
}

struct StateAndRef {
    state: TransactionState,
    reference: StateRef,
}

struct StateAndRefPaddingWrapper {
    content: StateAndRef,
    is_filler: bool,
}

impl StateRef {
    fn fingerprint(this: StateRef) -> RefFingerprintBits {
        let mut state_ref_bits = [false; REF_FINGERPRINT_BITS];

        let txhash_fingerprint = NodeDigestDto::from_bytes_to_bits(this.txhash);
        for i in 0..NODE_DIGEST_BITS {
            state_ref_bits[i] = txhash_fingerprint[i];
        }

        let stateref_index_bits = to_bits(this.index);
        for i in 0..U32_BITS {
            state_ref_bits[NODE_DIGEST_BITS + i] = stateref_index_bits[i];
        }
        state_ref_bits
    }

    fn compute_leaf_hash(
        this: StateRef,
        privacy_salt: PrivacySaltBits,
        group_index: u32,
        internal_index: u32,
    ) -> ComponentGroupLeafDigestBits {
        // fingerprint
        let fingerprint_ref = fingerprint(this);

        // compute nonce
        let mut nonce = compute_nonce(privacy_salt, group_index, internal_index);

        // message = nonce || ref
        let mut message = [false; NONCE_DIGEST_BITS + REF_FINGERPRINT_BITS];
        for i in 0..NONCE_DIGEST_BITS {
            message[i] = nonce[i];
        }
        for i in 0..REF_FINGERPRINT_BITS {
            message[NONCE_DIGEST_BITS + i] = fingerprint_ref[i];
        }
        blake2s(message)
    }
}


impl TransactionState {
    fn fingerprint(this: TransactionState) -> [bool; STATE_FINGERPRINT_BITS] {
        let mut result = [false; STATE_FINGERPRINT_BITS];

        // TODO: Separate the fingerprint for the actual ZKContractState our of here.
        // That means that TransactionState.data is asked for its own fingerprint.

        //state_bits = dataOwner_owning_key || value || notary_owning_key
        //dataOwner_owning_key
        result[0..PUBKEY_FINGERPRINT_BITS] = PubKey::fingerprint(this.data.owner.owning_key);
        //value
        result[PUBKEY_FINGERPRINT_BITS..(PUBKEY_FINGERPRINT_BITS + U32_BITS)] = to_bits(this.data.value);
        //notary_owning_key
        result[(PUBKEY_FINGERPRINT_BITS + U32_BITS)..STATE_FINGERPRINT_BITS] =
            PubKey::fingerprint(this.notary.owning_key);

        result
    }

    fn compute_leaf_hash(
        this: TransactionState,
        nonce: NonceDigestBits,
    ) -> ComponentGroupLeafDigestBits {
        // message = nonce || state
        let mut message = [false; NONCE_DIGEST_BITS + STATE_FINGERPRINT_BITS];
        for i in 0..NONCE_DIGEST_BITS {
            message[i] = nonce[i];
        }

        let fingerprint_state = fingerprint(this);
        for i in 0..STATE_FINGERPRINT_BITS {
            message[NONCE_DIGEST_BITS + i] = fingerprint_state[i];
        }
        blake2s(message)
    }
}
