const NONCE_PREIMAGE_BYTES: u16 = PRIVACY_SALT_BYTES + U32_BYTES + U32_BYTES;
const NONCE_PREIMAGE_BITS: u16 = NONCE_PREIMAGE_BYTES * BYTE_BITS;

const NONCE_DIGEST_BYTES: u16 = COMPONENT_GROUP_LEAF_DIGEST_BYTES;
const NONCE_DIGEST_BITS: u16  = COMPONENT_GROUP_LEAF_DIGEST_BITS;

type NoncePreimageBits = [bool; NONCE_PREIMAGE_BITS];
type NonceDigestBits = [bool; NONCE_DIGEST_BITS];


//For debug purposes
fn nonce_preimage_to_bytes(nonce: NoncePreimageBits) -> [u8; NONCE_PREIMAGE_BYTES] {
    let mut nonce_bytes = [0 as u8; NONCE_PREIMAGE_BYTES];

    for i in 0..NONCE_PREIMAGE_BYTES {
        let mut byte_bits: [bool; BYTE_BITS] = [false; BYTE_BITS];
        for j in 0..BYTE_BITS {
            byte_bits[j] = nonce[BYTE_BITS * i + j];
        }
        nonce_bytes[(i as u16)] = from_bits_unsigned(byte_bits);
    }
    nonce_bytes
}

// Method to compute a nonce based on privacySalt, component group index and component internal index.
fn compute_nonce(
    privacy_salt: PrivacySaltBits,
    group_index: u32,
    internal_index: u32,
) -> NonceDigestBits {
    dbg!(">> computeNonce (");
    dbg!("   group index = {}", group_index);
    dbg!("   internal index = {}", internal_index);
    dbg!(")");

    let mut nonce = [false; NONCE_PREIMAGE_BITS];
    for i in 0..PRIVACY_SALT_BITS {
        nonce[i] = privacy_salt[i];
    }

    let group_index_bits = to_bits(group_index);
    let internal_index_bits = to_bits(internal_index);

    for i in 0..U32_BITS {
        nonce[PRIVACY_SALT_BITS + (i as u16)] = group_index_bits[i];
        nonce[PRIVACY_SALT_BITS + U32_BITS + (i as u16)] = internal_index_bits[i];
    }
    dbg!("   nonce input = {}", nonce_to_bytes(nonce));

    blake2s(nonce)
}

