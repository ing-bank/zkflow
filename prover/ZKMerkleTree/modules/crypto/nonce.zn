const NONCE_FINGERPRINT_BYTES: u16 = PRIVACY_SALT_BYTES + U32_BYTES + U32_BYTES;

const NONCE_FINGERPRINT_BITS: u16 = NONCE_FINGERPRINT_BYTES * BYTE_BITS;
const NONCE_DIGEST_BITS: u16  = COMPONENT_GROUP_LEAF_DIGEST_BITS;

type NonceFingerPrintBits = [bool; NONCE_FINGERPRINT_BITS];
type NonceDigestBits = [bool; NONCE_DIGEST_BITS];


//For debug purposes
fn nonce_to_bytes(nonce: NonceFingerPrintBits) -> [u8; NONCE_FINGERPRINT_BYTES] {
    let mut nonce_bytes = [0 as u8; NONCE_FINGERPRINT_BYTES];

    for i in 0..NONCE_FINGERPRINT_BYTES {
        let mut byte_bits: [bool; BYTE_BITS] = [false; BYTE_BITS];
        for j in 0..BYTE_BITS {
            byte_bits[j] = nonce[BYTE_BITS * i + j];
        }
        nonce_bytes[(i as u16)] = from_bits_unsigned(byte_bits);
    }
    nonce_bytes
}

// Method to compute a nonce based on privacySalt, component group index and component internal index.
fn compute_nonce(
    privacy_salt: PrivacySaltFingerprintBits,
    group_index: u32,
    internal_index: u32,
) -> NonceDigestBits {
    dbg!(">> computeNonce (");
    dbg!("   group index = {}", group_index);
    dbg!("   internal index = {}", internal_index);
    dbg!(")");

    let mut nonce = [false; NONCE_FINGERPRINT_BITS];
    for i in 0..PRIVACY_SALT_FINGERPRINT_BITS {
        nonce[i] = privacy_salt[i];
    }

    let group_index_bits = to_bits(group_index);
    let internal_index_bits = to_bits(internal_index);

    for i in 0..U32_BITS {
        nonce[PRIVACY_SALT_FINGERPRINT_BITS + (i as u16)] = group_index_bits[i];
        nonce[PRIVACY_SALT_FINGERPRINT_BITS + U32_BITS + (i as u16)] = internal_index_bits[i];
    }
    dbg!("   nonce input = {}", nonce_to_bytes(nonce));

    blake2s(nonce)
}

