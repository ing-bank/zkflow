const COMMAND_GROUP_SIZE: u16 = 1;
const COMMAND_BITS: u16 = U32_BITS;

enum CommandData {
    CREATE = 0,
    MOVE = 1,
}

struct CommandPaddingWrapper {
    content: CommandData,
    is_filler: bool,
}

struct Commands {
    value: [CommandPaddingWrapper; COMMAND_GROUP_SIZE],
    group_hash: ComponentGroupHashBytes,
}

impl Commands {
    fn fingerprint_content(content: CommandData) -> [bool; U32_BITS] {
        to_bits(content as u32)
    }

    fn compute_leaf_hashes(
        commands: Commands,
        privacy_salt: PrivacySalt,
    ) -> [HashDigestBits; COMMAND_GROUP_SIZE] {
        let mut component_leaf_hashes = [[false; HASH_BITS]; COMMAND_GROUP_SIZE];

        for i in (0 as u32)..(COMMAND_GROUP_SIZE as u32) {
            component_leaf_hashes[i] = compute_leaf_hash_int(
                fingerprint_content(commands.value[i].content),
                privacy_salt,
                ComponentGroupEnum::COMMANDS_GROUP as u32,
                i as u32,
            );
        }
        component_leaf_hashes
    }

    fn compute_component_group_hash(
        commands: Commands,
        privacy_salt: PrivacySalt,
    ) -> ComponentGroupHashBits {
        let component_leaf_hashes = compute_leaf_hashes(commands, privacy_salt);

        //When the number of leaves is one, we pad the leaf with zeros from the right first
        //and use padded input in the merkle_root computation.
        let mut padded_leaves = [[false; HASH_BITS]; 2];
        padded_leaves[0] = component_leaf_hashes[0];

        merkle_2_leaves(padded_leaves)
    }
}
