const STATE_BYTES: u16 = PUBKEY_BYTES + U32_BYTES + PUBKEY_BYTES;
const STATE_FINGERPRINT_BYTES: u16 = PUBKEY_BYTES + U32_BYTES + PUBKEY_BYTES;
const STATE_FINGERPRINT_BITS: u16 = STATE_FINGERPRINT_BYTES * BYTE_BITS;

type StateBytes  = [u8; STATE_BYTES];
type StateFingerprintBits = [bool; STATE_FINGERPRINT_BITS];

const REF_BYTES: u16 = 32;
const REF_FINGERPRINT_BYTES: u16 = 32;
const REF_FINGERPRINT_BITS: u16 = REF_FINGERPRINT_BYTES * BYTE_BITS;

type RefBytes  = [u8; REF_BYTES];
type RefFingerprintBits = [bool; REF_FINGERPRINT_BITS];

struct Party {
    owning_key: PubKey,
}

struct Data {
    owner: Party,
    value: i32,
}

//This struct follows the structure in the original Corda TransactionState structure. The fields
// contractCN, encumbrance and constraint are commented out and declared bool intentionally to
// reserve their place in the structure. In the current implementation we don't use these fields,
// if they are going to be included, they should be declared with the corresponding data type.
struct TransactionState {
    data: Data,
    //contractCN: bool,
    notary: Party,
    //encumbrance: bool,
    //constraint: bool,
}

struct StateRef {
    txhash: HashDigest,
    index: i32,
}

struct StateAndRef {
    state: TransactionState,
    reference: StateRef,
}

struct StateAndRefPaddingWrapper {
    content: StateAndRef,
    is_filler: bool,
}

impl StateRef {
    fn fingerprint(this: StateRef) -> RefFingerprintBits {
        let mut state_ref_bits = [false; REF_BITS];
        state_ref_bits[0] =HashDigest::fingerprint(this.txhash);
        state_ref_bits[this.txhash.len()] =  to_bits(this.index);
        state_ref_bits
    }

    fn compute_leaf_hash(
        this: StateRef,
        privacy_salt: PrivacySaltBits,
        group_index: u32,
        internal_index: u32,
    ) -> ComponentGroupLeafDigestBits {
        //fingerprint
        let fingerprint_ref = StateRef::fingerprint(this.id);

        //compute nonce
        let mut nonce = compute_nonce(privacy_salt, group_index, internal_index);
        //dbg!("   nonce = {}", digest_to_bytes(nonce));

        // message = nonce || ref
        let mut message = [false; NONCE_DIGEST_BITS + REF_FINGERPRINT_BITS];
        for i in 0..NONCE_DIGEST_BITS {
            message[i] = nonce[i];
        }
        for i in 0..REF_FINGERPRINT_BITS {
            message[NONCE_DIGEST_BITS + i] = fingerprint_ref[i];
        }
        //dbg!("   digest input = {}", hashref_to_bytes(message));

        blake2s(message)
    }
}


///This part is currently commented out since it is not used.
/// However, we will need it in future for the backchain concept.
// impl TransactionState {
//     fn fingerprint(this: TransactionState) -> StateFingerprintBits {
//         let mut fingerprint_bits = [false; STATE_FINGERPRINT_BITS];
//
//         //state_bits = dataOwner_owning_key || value || notary_owning_key
//         //dataOwner_owning_key
//         fingerprint_bits[0..PUBKEY_FINGERPRINT_BITS] = PubKey::fingerprint(this.data.owner.owning_key);
//         //value
//         fingerprint_bits[PUBKEY_FINGERPRINT_BITS..(PUBKEY_FINGERPRINT_BITS + U32_BITS)] = to_bits(this.data.value);
//         //notary_owning_key
//         fingerprint_bits[(PUBKEY_FINGERPRINT_BITS + U32_BITS)..STATE_FINGERPRINT_BITS] =
//             PubKey::fingerprint(this.notary.owning_key);
//
//         fingerprint_bits
//     }
//
//     fn compute_leaf_hash_state(
//         this: TransactionState,
//         privacy_salt: PrivacySaltBits,
//         group_index: u32,
//         internal_index: u32,
//     ) -> ComponentGroupLeafDigestBits {
//         //fingerprint
//         let fingerprint_state = fingerprint(this);
//
//         //dbg!(">> compute_leaf_hash_ref");
//
//         //compute nonce
//         let mut nonce = compute_nonce(privacy_salt, group_index, internal_index);
//         //dbg!("   nonce = {}", digest_to_bytes(nonce));
//
//         // message = nonce || state
//         let mut message = [false; NONCE_DIGEST_BITS + STATE_FINGERPRINT_BITS];
//
//         //message = nonce || state
//         for i in 0..NONCE_DIGEST_BITS {
//             message[i] = nonce[i];
//         }
//
//         for i in 0..STATE_FINGERPRINT_BITS {
//             message[NONCE_DIGEST_BITS + i] = fingerprint_state[i];
//         }
//         //dbg!("   digest input = {}", hashstate_to_bytes(message));
//
//         blake2s(message)
//     }
// }
