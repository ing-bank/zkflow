struct Party {
    owning_key: PubKey,
}

struct Data {
    owner: Party,
    value: i32,
}

/*
This struct follows the structure in the original Corda TransactionState structure. The fields contractCN,
encumbrance and constraint are commented out and declared bool intentionally to reserve their place in the
structure. In the current implementation we don't use these fields, if they are going to be included, they
should be declared with the corresponding data type.
*/
struct TransactionState {
    data: Data,
    //contractCN: bool,
    notary: Party,
    //encumbrance: bool,
    //constraint: bool,
}

struct ZKStateRef {
    id: HashDigestBytes,
}

struct ContentZKStateAndRef {
    state: TransactionState,
    reference: ZKStateRef,
}

struct ZKStateAndRef {
    content: ContentZKStateAndRef,
    is_filler: bool,
}

impl ZKStateAndRef {
    fn fingerprint_state(value: ZKStateAndRef) -> [bool; STATE_BITS] {
        let mut result = [false; STATE_BITS];

        //state_bits = dataOwner_owningKey || value || notary_owningKey
        result[0..PUBKEY_BITS] = convert_pubKey_to_bits(value.content.state.data.owner.owning_key); //dataOwner_owningKey
        result[PUBKEY_BITS..(PUBKEY_BITS + INT32_BITS)] = to_bits(value.content.state.data.value); //value
        result[(PUBKEY_BITS + INT32_BITS)..STATE_BITS] =
            convert_pubKey_to_bits(value.content.state.notary.owning_key); //notary_owningKey

        result
    }

    fn fingerprint_ref(value: ZKStateAndRef) -> [bool; REF_BITS] {
        convert_hash_to_bits(value.content.reference.id)
    }

    fn compute_leaf_hash_ref(
        value: [bool; REF_BITS],
        privacy_salt: PrivacySalt,
        group_index: u32,
        internal_index: u32,
    ) -> HashDigestBits {
        //dbg!(">> compute_leaf_hash_ref");

        //compute nonce
        let mut nonce = compute_nonce(privacy_salt, group_index, internal_index);
        //dbg!("   nonce = {}", digest_to_bytes(nonce));

        // message = nonce || ref
        let mut message: [bool; HASH_BITS + REF_BITS] = [false; HASH_BITS + REF_BITS];
        for i in 0..HASH_BITS {
            message[i] = nonce[i];
        }
        for i in 0..REF_BITS {
            message[HASH_BITS + i] = value[i];
        }
        //dbg!("   digest input = {}", hashref_to_bytes(message));
        blake2s(message)
    }

    fn compute_leaf_hash_state(
        value: [bool; STATE_BITS],
        privacy_salt: PrivacySalt,
        group_index: u32,
        internal_index: u32,
    ) -> HashDigestBits {
        //dbg!(">> compute_leaf_hash_ref");

        //compute nonce
        let mut nonce = compute_nonce(privacy_salt, group_index, internal_index);
        //dbg!("   nonce = {}", digest_to_bytes(nonce));

        // message = nonce || state
        let mut message = [false; HASH_BITS + STATE_BITS];

        //message = nonce || state nonce || state
        for i in 0..HASH_BITS {
            message[i] = nonce[i];
        }

        for i in 0..STATE_BITS {
            message[HASH_BITS + i] = value[i];
        }

        //dbg!("   digest input = {}", hashstate_to_bytes(message));

        blake2s(message)
    }
}
