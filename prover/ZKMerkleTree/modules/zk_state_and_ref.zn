type RefBits  = [bool; REF_BITS];
type StateBits  = [bool; STATE_BITS];

struct Party {
    owning_key: PubKey,
}

struct Data {
    owner: Party,
    value: i32,
}

//This struct follows the structure in the original Corda TransactionState structure. The fields
// contractCN, encumbrance and constraint are commented out and declared bool intentionally to
// reserve their place in the structure. In the current implementation we don't use these fields,
// if they are going to be included, they should be declared with the corresponding data type.
struct TransactionState {
    data: Data,
    //contractCN: bool,
    notary: Party,
    //encumbrance: bool,
    //constraint: bool,
}

struct ZKStateRef {
    id: HashDigest,
}

struct ZKStateAndRef {
    state: TransactionState,
    reference: ZKStateRef,
}

struct ZKStateAndRefPaddingWrapper {
    content: ZKStateAndRef,
    is_filler: bool,
}

impl ZKStateRef {
    fn fingerprint(value: ZKStateRef) -> RefBits{
        HashDigest::fingerprint(value.id)
    }

    fn compute_leaf_hash(
        this: ZKStateRef,
        privacy_salt: PrivacySalt,
        group_index: u32,
        internal_index: u32,
    ) -> HashDigestBits {
        //fingerprint
        let fingerprint_ref = fingerprint(this);

        //compute nonce
        let mut nonce = compute_nonce(privacy_salt, group_index, internal_index);
        //dbg!("   nonce = {}", digest_to_bytes(nonce));

        // message = nonce || ref
        let mut message: [bool; HASH_BITS + REF_BITS] = [false; HASH_BITS + REF_BITS];
        for i in 0..HASH_BITS {
            message[i] = nonce[i];
        }
        for i in 0..REF_BITS {
            message[HASH_BITS + i] = fingerprint_ref[i];
        }
        //dbg!("   digest input = {}", hashref_to_bytes(message));
        blake2s(message)
    }
}


///This part is currently commented out since it is not used.
/// However, we will need it in future for the backchain concept.
// impl TransactionState {
//     fn fingerprint_state(state: TransactionState) -> [bool; STATE_BITS] {
//         let mut result = [false; STATE_BITS];
//
//         //state_bits = dataOwner_owning_key || value || notary_owning_key
//         //dataOwner_owning_key
//         result[0..PUBKEY_BITS] = convert_pub_key_to_bits(state.data.owner.owning_key);
//         //value
//         result[PUBKEY_BITS..(PUBKEY_BITS + U32_BITS)] = to_bits(state.data.value);
//         //notary_owning_key
//         result[(PUBKEY_BITS + U32_BITS)..STATE_BITS] =
//             convert_pub_key_to_bits(state.notary.owning_key);
//
//         result
//     }
//
//     fn compute_leaf_hash_state(
//         value: StateBits,
//         privacy_salt: PrivacySalt,
//         group_index: u32,
//         internal_index: u32,
//     ) -> HashDigestBits {
//         //dbg!(">> compute_leaf_hash_ref");
//
//         //compute nonce
//         let mut nonce = compute_nonce(privacy_salt, group_index, internal_index);
//         //dbg!("   nonce = {}", digest_to_bytes(nonce));
//
//         // message = nonce || state
//         let mut message = [false; HASH_BITS + STATE_BITS];
//
//         //message = nonce || state nonce || state
//         for i in 0..HASH_BITS {
//             message[i] = nonce[i];
//         }
//
//         for i in 0..STATE_BITS {
//             message[HASH_BITS + i] = value[i];
//         }
//         //dbg!("   digest input = {}", hashstate_to_bytes(message));
//         blake2s(message)
//     }
// }
