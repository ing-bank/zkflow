const NONCE_BYTES: u16 = HASH_BYTES + U32_BYTES + U32_BYTES;
const NONCE_BITS: u16 = NONCE_BYTES * BYTE_BITS;

// Utility functions -->
fn nonce_to_bytes(bits: [bool; NONCE_BITS]) -> [u8; NONCE_BYTES] {
    let mut nonce_bytes = [0 as u8; NONCE_BYTES];

    for i in 0..NONCE_BYTES {
        let mut byte_bits = [false; BYTE_BITS];
        for j in 0..BYTE_BITS {
            byte_bits[j] = bits[BYTE_BITS * i + j];
        }
        nonce_bytes[i] = from_bits_unsigned(byte_bits);
    }

    nonce_bytes
}
// <-- Utility functions

/**
* Method to compute a nonce based on privacySalt, component group index and component internal index.
* @param privacySalt a PrivacySalt
* @param groupIndex the fixed index (ordinal) of this component group.
* @param internalIndex the internal index of this object in its corresponding components list.
* @return H(privacy_salt || group_index || internal_index))
*/
fn compute_nonce(
    privacy_salt: PrivacySalt,
    group_index: u32,
    internal_index: u32,
) -> [bool; HASH_BITS] {
    // dbg!(">> computeNonce (");
    // dbg!("   group index = {}", group_index);
    // dbg!("   internal index = {}", internal_index);
    // dbg!(")");

    let mut nonce = [false; NONCE_BITS];
    for i in 0..HASH_BITS {
        nonce[i] = privacy_salt[i];
    }

    let group_index_bits = to_bits(group_index);
    let internal_index_bits = to_bits(internal_index);

    for i in 0..U32_BITS {
        nonce[HASH_BITS + (i as u16)] = group_index_bits[i];
        nonce[HASH_BITS + U32_BITS + (i as u16)] = internal_index_bits[i];
    }

    // dbg!("   nonce input = {}", nonce_to_bytes(nonce));

    blake2s(nonce)
}
