// Method to compute a nonce based on privacySalt, component group index and component internal index.
// * privacy_salt a PrivacySalt
// * group_index the fixed index (ordinal) of this component group.
// * internal_index the internal index of this object in its corresponding components list.
// return H(privacy_salt || group_index || internal_index))
fn compute_nonce(
    privacy_salt: PrivacySalt,
    group_index: u32,
    internal_index: u32,
) -> [bool; HASH_BITS] {
    dbg!(">> computeNonce (");
    dbg!("   group index = {}", group_index);
    dbg!("   internal index = {}", internal_index);
    dbg!(")");

    let mut nonce = [false; NONCE_BITS];
    for i in 0..HASH_BITS {
        nonce[i] = privacy_salt[i];
    }

    let group_index_bits = to_bits(group_index);
    let internal_index_bits = to_bits(internal_index);

    for i in 0..U32_BITS {
        nonce[HASH_BITS + (i as u16)] = group_index_bits[i];
        nonce[HASH_BITS + U32_BITS + (i as u16)] = internal_index_bits[i];
    }

    dbg!("   nonce input = {}", nonce_to_bytes(nonce));

    blake2s(nonce)
}
