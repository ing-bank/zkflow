const PEDERSEN_DIGEST_BITS: u16 = 254;

// Method to concatenate two hash digests.
fn concatenate_hashes(
    hash1: [bool; HASH_BITS],
    hash2: [bool; HASH_BITS],
) -> [bool; HASH_BITS + HASH_BITS] {
    let mut data = [false; HASH_BITS + HASH_BITS];

    for i in (0 as u16)..HASH_BITS {
        data[i] = hash1[i];
        data[HASH_BITS + i] = hash2[i];
    }
    data
}

// Method to pad pedersen digest with zeros to assure 256 bits digest size globally.
fn pedersen_to_padded_bits(digest: field) -> [bool; HASH_BITS] {
    let mut digest_bits = [false; HASH_BITS];
    let pedersen_bits = to_bits(digest);

    for i in 0..PEDERSEN_DIGEST_BITS {
        digest_bits[(2 as u16) + i] = pedersen_bits[i];
    }

    digest_bits
}

// Method to compute leaf hash on integer  values.
fn compute_leaf_hash_int(
    value: [bool; U32_BITS],
    privacy_salt: PrivacySalt,
    group_index: u32,
    internal_index: u32,
) -> HashDigestBits {
    //compute nonce
    let mut nonce = compute_nonce(privacy_salt, group_index, internal_index);
    let mut message: [bool; HASH_BITS + U32_BITS] = [false; HASH_BITS + U32_BITS];

    //message = nonce || command
    for i in 0..HASH_BITS {
        message[i] = nonce[i];
    }
    for i in 0..U32_BITS {
        message[HASH_BITS + i] = value[i];
    }

    blake2s(message)
}

// Method to compute leaf hash on hash values.
fn compute_leaf_hash_hash(
    value: [bool; HASH_BITS],
    privacy_salt: PrivacySalt,
    group_index: u32,
    internal_index: u32,
) -> HashDigestBits {
    // dbg!(">> compute_leaf_hash_hash");

    //compute nonce
    let mut nonce = compute_nonce(privacy_salt, group_index, internal_index);
    // dbg!("   nonce = {}", digest_to_bytes(nonce));

    let mut message: [bool; HASH_BITS + HASH_BITS] = [false; HASH_BITS + HASH_BITS];

    //message = nonce || hash
    for i in 0..HASH_BITS {
        message[i] = nonce[i];
    }
    for i in 0..HASH_BITS {
        message[HASH_BITS + i] = value[i];
    }

    // dbg!("   digest input = {}", hashhash_to_bytes(message));

    blake2s(message)
}

// Method to compute leaf hash on public key values.
fn compute_leaf_hash_pub_key(
    value: [bool; PUBKEY_BITS],
    privacy_salt: PrivacySalt,
    group_index: u32,
    internal_index: u32,
) -> HashDigestBits {
    //compute nonce
    let mut nonce = compute_nonce(privacy_salt, group_index, internal_index);
    let mut message: [bool; HASH_BITS + PUBKEY_BITS] = [false; HASH_BITS + PUBKEY_BITS];

    //message = nonce || signature
    for i in 0..HASH_BITS {
        message[i] = nonce[i];
    }

    for i in 0..PUBKEY_BITS {
        message[HASH_BITS + i] = value[i];
    }

    blake2s(message)
}
