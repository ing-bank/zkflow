use std::array::truncate;

use std::crypto::blake2s;
use std::crypto::pedersen;

use std::convert::from_bits_field;
use std::convert::from_bits_unsigned;

use std::convert::to_bits;
const PUBKEY_BYTES: u16 = 44;
const PUBKEY_BITS: u16 = (8 as u16) * PUBKEY_BYTES;

const HASH_BYTES: u16 = 32;
const HASH_BITS: u16 = (8 as u16) * HASH_BYTES;

const BYTE_BITS: u16 = 8;

const U32_BYTES: u16 = 4;
const U32_BITS: u16 = U32_BYTES * BYTE_BITS;

const U128_BYTES: u16 = 16;
const U128_BITS: u16 = U128_BYTES * BYTE_BITS;

const STATE_BYTES: u16 = PUBKEY_BYTES + U32_BYTES + PUBKEY_BYTES;
const STATE_BITS: u16 = STATE_BYTES * BYTE_BITS;

const REF_BITS: u16 = HASH_BITS;

const NONCE_BYTES: u16 = HASH_BYTES + U32_BYTES + U32_BYTES;
const NONCE_BITS: u16 = NONCE_BYTES * BYTE_BITS;

type PubKey = [u8; PUBKEY_BYTES];

type HashDigestBytes = [u8; HASH_BYTES];
type HashDigestBits = [bool; HASH_BITS];

type ComponentGroupHashBytes = [u8; HASH_BYTES];
type ComponentGroupHashBits = [bool; HASH_BITS];

type PrivacySalt = [bool; HASH_BITS];
//Debug functions to convert bit arrays to byte arrays

fn u32_to_bytes(bits: [bool; U32_BITS]) -> [u8; U32_BYTES] {
    let mut u32_bytes = [0 as u8; U32_BYTES];

    for i in 0..U32_BYTES {
        let mut byte_bits = [false; BYTE_BITS];
        for j in 0..BYTE_BITS {
            byte_bits[j] = bits[BYTE_BITS * i + j];
        }
        u32_bytes[i] = std::convert::from_bits_unsigned(byte_bits);
    }

    u32_bytes
}

fn digest_to_bytes(digest: [bool; HASH_BITS]) -> [u8; HASH_BYTES] {
    let mut hash_bytes = [0 as u8; HASH_BYTES];

    for i in 0..HASH_BYTES {
        let mut byte_bits = [false; BYTE_BITS];
        for j in 0..BYTE_BITS {
            byte_bits[j] = digest[BYTE_BITS * i + j];
        }
        hash_bytes[i] = std::convert::from_bits_unsigned(byte_bits);
    }

    hash_bytes
}

fn hashhash_to_bytes(digest: [bool; HASH_BITS + HASH_BITS]) -> [u8; HASH_BYTES + HASH_BYTES] {
    let mut hash_bytes = [0 as u8; HASH_BYTES + HASH_BYTES];

    for i in 0..(HASH_BYTES + HASH_BYTES) {
        let mut byte_bits = [false; BYTE_BITS];
        for j in 0..BYTE_BITS {
            byte_bits[j] = digest[BYTE_BITS * i + j];
        }
        hash_bytes[i] = std::convert::from_bits_unsigned(byte_bits);
    }

    hash_bytes
}

fn hashref_to_bytes(digest: [bool; HASH_BITS + REF_BITS]) -> [u8; HASH_BYTES + HASH_BYTES] {
    let mut hash_bytes = [0 as u8; HASH_BYTES + HASH_BYTES];

    for i in 0..(HASH_BYTES + HASH_BYTES) {
        let mut byte_bits = [false; BYTE_BITS];
        for j in 0..BYTE_BITS {
            byte_bits[j] = digest[BYTE_BITS * i + j];
        }
        hash_bytes[i] = std::convert::from_bits_unsigned(byte_bits);
    }

    hash_bytes
}

fn hashstate_to_bytes(digest: [bool; HASH_BITS + STATE_BITS]) -> [u8; HASH_BYTES + STATE_BYTES] {
    let mut hash_bytes = [0 as u8; HASH_BYTES + STATE_BYTES];

    for i in 0..(HASH_BYTES + STATE_BYTES) {
        let mut byte_bits = [false; BYTE_BITS];
        for j in 0..BYTE_BITS {
            byte_bits[j] = digest[BYTE_BITS * i + j];
        }
        hash_bytes[i] = std::convert::from_bits_unsigned(byte_bits);
    }

    hash_bytes
}

fn nonce_to_bytes(bits: [bool; NONCE_BITS]) -> [u8; NONCE_BYTES] {
    let mut nonce_bytes = [0 as u8; NONCE_BYTES];

    for i in 0..NONCE_BYTES {
        let mut byte_bits: [bool; 8] = [false; 8];
        for j in 0..(8 as u16) {
            byte_bits[j] = bits[(8 as u16) * i + j];
        }
        nonce_bytes[(i as u16)] = std::convert::from_bits_unsigned(byte_bits);
    }

    nonce_bytes
}
enum ComponentGroupEnum {
    INPUTS_GROUP = 0,
    OUTPUTS_GROUP = 1,
    COMMANDS_GROUP = 2,
    ATTACHMENTS_GROUP = 3,
    NOTARY_GROUP = 4,
    TIMEWINDOW_GROUP = 5,
    SIGNERS_GROUP = 6,
    REFERENCES_GROUP = 7,
    PARAMETERS_GROUP = 8,
}
// Method to compute a nonce based on privacySalt, component group index and component internal index.
// * privacy_salt a PrivacySalt
// * group_index the fixed index (ordinal) of this component group.
// * internal_index the internal index of this object in its corresponding components list.
// return H(privacy_salt || group_index || internal_index))
fn compute_nonce(
    privacy_salt: PrivacySalt,
    group_index: u32,
    internal_index: u32,
) -> [bool; HASH_BITS] {

    let mut nonce = [false; NONCE_BITS];
    for i in 0..HASH_BITS {
        nonce[i] = privacy_salt[i];
    }

    let group_index_bits = to_bits(group_index);
    let internal_index_bits = to_bits(internal_index);

    for i in 0..U32_BITS {
        nonce[HASH_BITS + (i as u16)] = group_index_bits[i];
        nonce[HASH_BITS + U32_BITS + (i as u16)] = internal_index_bits[i];
    }


    blake2s(nonce)
}
const PEDERSEN_DIGEST_BITS: u16 = 254;

// Method to concatenate two hash digests.
fn concatenate_hashes(
    hash1: [bool; HASH_BITS],
    hash2: [bool; HASH_BITS],
) -> [bool; HASH_BITS + HASH_BITS] {
    let mut data = [false; HASH_BITS + HASH_BITS];

    for i in (0 as u16)..HASH_BITS {
        data[i] = hash1[i];
        data[HASH_BITS + i] = hash2[i];
    }
    data
}

// Method to pad pedersen digest with zeros to assure 256 bits digest size globally.
fn pedersen_to_padded_bits(digest: field) -> [bool; HASH_BITS] {
    let mut digest_bits = [false; HASH_BITS];
    let pedersen_bits = to_bits(digest);

    for i in 0..PEDERSEN_DIGEST_BITS {
        digest_bits[(2 as u16) + i] = pedersen_bits[i];
    }

    digest_bits
}

// Method to compute leaf hash on integer  values.
fn compute_leaf_hash_int(
    value: [bool; U32_BITS],
    privacy_salt: PrivacySalt,
    group_index: u32,
    internal_index: u32,
) -> HashDigestBits {
    //compute nonce
    let mut nonce = compute_nonce(privacy_salt, group_index, internal_index);
    let mut message: [bool; HASH_BITS + U32_BITS] = [false; HASH_BITS + U32_BITS];

    //message = nonce || command
    for i in 0..HASH_BITS {
        message[i] = nonce[i];
    }
    for i in 0..U32_BITS {
        message[HASH_BITS + i] = value[i];
    }

    blake2s(message)
}

// Method to compute leaf hash on hash values.
fn compute_leaf_hash_hash(
    value: [bool; HASH_BITS],
    privacy_salt: PrivacySalt,
    group_index: u32,
    internal_index: u32,
) -> HashDigestBits {

    //compute nonce
    let mut nonce = compute_nonce(privacy_salt, group_index, internal_index);

    let mut message: [bool; HASH_BITS + HASH_BITS] = [false; HASH_BITS + HASH_BITS];

    //message = nonce || hash
    for i in 0..HASH_BITS {
        message[i] = nonce[i];
    }
    for i in 0..HASH_BITS {
        message[HASH_BITS + i] = value[i];
    }


    blake2s(message)
}

// Method to compute leaf hash on public key values.
fn compute_leaf_hash_pubKey(
    value: [bool; PUBKEY_BITS],
    privacy_salt: PrivacySalt,
    group_index: u32,
    internal_index: u32,
) -> HashDigestBits {
    //compute nonce
    let mut nonce = compute_nonce(privacy_salt, group_index, internal_index);
    let mut message: [bool; HASH_BITS + PUBKEY_BITS] = [false; HASH_BITS + PUBKEY_BITS];

    //message = nonce || signature
    for i in 0..HASH_BITS {
        message[i] = nonce[i];
    }

    for i in 0..PUBKEY_BITS {
        message[HASH_BITS + i] = value[i];
    }

    blake2s(message)
}
// Merkle tree construction.

fn merkle_2_leaves(leaves: [[bool; HASH_BITS]; 2]) -> [bool; HASH_BITS] {
    pedersen_to_padded_bits(pedersen(concatenate_hashes(leaves[0], leaves[1])).0)
}

fn merkle_4_leaves(leaves: [[bool; HASH_BITS]; 4]) -> [bool; HASH_BITS] {
    let mut new_leaves = [[false; HASH_BITS]; 2];
    for i in 0..2 {
        new_leaves[i] = pedersen_to_padded_bits(
            pedersen(concatenate_hashes(leaves[2 * i], leaves[2 * i + 1])).0,
        );
    }
    merkle_2_leaves(new_leaves)
}
fn merkle_8_leaves(leaves: [[bool; HASH_BITS]; 8]) -> [bool; HASH_BITS] {
    let mut new_leaves = [[false; HASH_BITS]; 4];
    for i in 0..4 {
        new_leaves[i] = pedersen_to_padded_bits(
            pedersen(concatenate_hashes(leaves[2 * i], leaves[2 * i + 1])).0,
        );
    }
    merkle_4_leaves(new_leaves)
}
fn merkle_16_leaves(leaves: [[bool; HASH_BITS]; 16]) -> [bool; HASH_BITS] {
    let mut new_leaves = [[false; HASH_BITS]; 8];
    for i in 0..8 {
        new_leaves[i] = pedersen_to_padded_bits(
            pedersen(concatenate_hashes(leaves[2 * i], leaves[2 * i + 1])).0,
        );
    }
    merkle_8_leaves(new_leaves)
}
//Fingerprint methods that are commonly used in component groups.

fn convert_hash_to_bits(value: [u8; HASH_BYTES]) -> [bool; HASH_BITS] {
    let mut hash_digest_bits = [false; HASH_BITS];

    for i in (0 as u16)..HASH_BYTES {
        let hd_bits = to_bits(value[i]);
        for j in (0 as u16)..(8 as u16) {
            hash_digest_bits[(8 as u16) * i + j] = hd_bits[j];
        }
    }
    hash_digest_bits
}

fn convert_pubKey_to_bits(value: [u8; PUBKEY_BYTES]) -> [bool; PUBKEY_BITS] {
    let mut pubKey_bits = [false; PUBKEY_BITS];

    for i in (0 as u16)..PUBKEY_BYTES {
        let pk_bits = to_bits(value[i]);
        for j in (0 as u16)..(8 as u16) {
            pubKey_bits[(8 as u16) * i + j] = pk_bits[j];
        }
    }
    pubKey_bits
}
struct Party {
    owning_key: PubKey,
}

struct Data {
    owner: Party,
    value: i32,
}

//This struct follows the structure in the original Corda TransactionState structure. The fields
// contractCN, encumbrance and constraint are commented out and declared bool intentionally to
// reserve their place in the structure. In the current implementation we don't use these fields,
// if they are going to be included, they should be declared with the corresponding data type.
struct TransactionState {
    data: Data,
    //contractCN: bool,
    notary: Party,
    //encumbrance: bool,
    //constraint: bool,
}

struct ZKStateRef {
    id: HashDigestBytes,
}

struct ContentZKStateAndRef {
    state: TransactionState,
    reference: ZKStateRef,
}

struct ZKStateAndRef {
    content: ContentZKStateAndRef,
    is_filler: bool,
}

impl ZKStateAndRef {
    fn fingerprint_state(value: ZKStateAndRef) -> [bool; STATE_BITS] {
        let mut result = [false; STATE_BITS];

        //state_bits = dataOwner_owning_key || value || notary_owning_key
        //dataOwner_owning_key
        result[0..PUBKEY_BITS] = convert_pubKey_to_bits(value.content.state.data.owner.owning_key);
        //value
        result[PUBKEY_BITS..(PUBKEY_BITS + U32_BITS)] = to_bits(value.content.state.data.value);
        //notary_owning_key
        result[(PUBKEY_BITS + U32_BITS)..STATE_BITS] =
            convert_pubKey_to_bits(value.content.state.notary.owning_key);

        result
    }

    fn fingerprint_ref(value: ZKStateAndRef) -> [bool; REF_BITS] {
        convert_hash_to_bits(value.content.reference.id)
    }

    fn compute_leaf_hash_ref(
        value: [bool; REF_BITS],
        privacy_salt: PrivacySalt,
        group_index: u32,
        internal_index: u32,
    ) -> HashDigestBits {

        //compute nonce
        let mut nonce = compute_nonce(privacy_salt, group_index, internal_index);

        // message = nonce || ref
        let mut message: [bool; HASH_BITS + REF_BITS] = [false; HASH_BITS + REF_BITS];
        for i in 0..HASH_BITS {
            message[i] = nonce[i];
        }
        for i in 0..REF_BITS {
            message[HASH_BITS + i] = value[i];
        }
        blake2s(message)
    }

    fn compute_leaf_hash_state(
        value: [bool; STATE_BITS],
        privacy_salt: PrivacySalt,
        group_index: u32,
        internal_index: u32,
    ) -> HashDigestBits {

        //compute nonce
        let mut nonce = compute_nonce(privacy_salt, group_index, internal_index);

        // message = nonce || state
        let mut message = [false; HASH_BITS + STATE_BITS];

        //message = nonce || state nonce || state
        for i in 0..HASH_BITS {
            message[i] = nonce[i];
        }

        for i in 0..STATE_BITS {
            message[HASH_BITS + i] = value[i];
        }
        blake2s(message)
    }
}
const INPUT_SIZE: u16 = 2;

struct Inputs {
    value: [ZKStateAndRef; INPUT_SIZE],
    group_hash: ComponentGroupHashBytes,
}

impl Inputs {
    fn fingerprint_value(inputs: Inputs) -> [[bool; REF_BITS]; INPUT_SIZE] {
        let mut result = [[false; REF_BITS]; INPUT_SIZE];

        for i in 0..INPUT_SIZE {
            //zkStateRef bits
            result[i] = ZKStateAndRef::fingerprint_ref(inputs.value[i]);
        }
        result
    }

    fn fingerprint_group_hash(inputs: Inputs) -> ComponentGroupHashBits {
        convert_hash_to_bits(inputs.group_hash)
    }

    fn compute_leaf_hashes(
        inputs: Inputs,
        privacy_salt: PrivacySalt,
    ) -> [HashDigestBits; INPUT_SIZE] {
        //get fingerprint
        let fingerprint = fingerprint_value(inputs);

        let mut component_leaf_hashes = [[false; HASH_BITS]; INPUT_SIZE];
        for i in (0 as u32)..(INPUT_SIZE as u32) {
            component_leaf_hashes[i] = ZKStateAndRef::compute_leaf_hash_ref(
                fingerprint[i],
                privacy_salt,
                ComponentGroupEnum::INPUTS_GROUP as u32,
                i as u32,
            );
        }

        component_leaf_hashes
    }

    fn compute_component_group_hash(
        inputs: Inputs,
        privacy_salt: PrivacySalt,
    ) -> ComponentGroupHashBits {
        let component_leaf_hashes = compute_leaf_hashes(inputs, privacy_salt);

        //Since INPUT_SIZE = 2, we use this Merkle function.
        //If INPUT_SIZE is different choose the appropriate merkle_util function.
        //If INPUT_SIZE is odd, apply zero padding until the number of leaf hashes equal to the next power of 2.
        merkle_2_leaves(component_leaf_hashes)
    }
}
const OUTPUT_SIZE: u16 = 2;

struct Outputs {
    value: [ZKStateAndRef; OUTPUT_SIZE],
    group_hash: ComponentGroupHashBytes,
}

impl Outputs {
    fn fingerprint_value(outputs: Outputs) -> [[bool; STATE_BITS]; OUTPUT_SIZE] {
        let mut result = [[false; STATE_BITS]; OUTPUT_SIZE];

        for i in 0..OUTPUT_SIZE {
            //zkStateRef bits
            result[i] = ZKStateAndRef::fingerprint_state(outputs.value[i]);
        }
        result
    }

    fn fingerprint_group_hash(outputs: Outputs) -> ComponentGroupHashBits {
        convert_hash_to_bits(outputs.group_hash)
    }

    fn compute_leaf_hashes(
        outputs: Outputs,
        privacy_salt: PrivacySalt,
    ) -> [HashDigestBits; OUTPUT_SIZE] {
        //get fingerpint
        let fingerprint = fingerprint_value(outputs);

        let mut component_leaf_hashes = [[false; HASH_BITS]; OUTPUT_SIZE];
        for i in (0 as u32)..(OUTPUT_SIZE as u32) {
            component_leaf_hashes[i] = ZKStateAndRef::compute_leaf_hash_state(
                fingerprint[i],
                privacy_salt,
                ComponentGroupEnum::OUTPUTS_GROUP as u32,
                i as u32,
            );
        }

        component_leaf_hashes
    }

    fn compute_component_group_hash(
        outputs: Outputs,
        privacy_salt: PrivacySalt,
    ) -> ComponentGroupHashBits {
        let component_leaf_hashes = compute_leaf_hashes(outputs, privacy_salt);

        merkle_2_leaves(component_leaf_hashes)
    }
}
const REFERENCE_SIZE: u16 = 2;

struct References {
    value: [ZKStateAndRef; REFERENCE_SIZE],
    group_hash: ComponentGroupHashBytes,
}

impl References {
    fn fingerprint_value(references: References) -> [[bool; REF_BITS]; REFERENCE_SIZE] {
        let mut result = [[false; REF_BITS]; REFERENCE_SIZE];

        for i in 0..REFERENCE_SIZE {
            //zkStateRef bits
            result[i] = ZKStateAndRef::fingerprint_ref(references.value[i]);
        }
        result
    }

    fn fingerprint_group_hash(references: References) -> ComponentGroupHashBits {
        convert_hash_to_bits(references.group_hash)
    }

    fn compute_leaf_hashes(
        references: References,
        privacy_salt: PrivacySalt,
    ) -> [HashDigestBits; REFERENCE_SIZE] {
        //get fingerpint
        let fingerprint = fingerprint_value(references);

        let mut component_leaf_hashes = [[false; HASH_BITS]; REFERENCE_SIZE];
        for i in (0 as u32)..(REFERENCE_SIZE as u32) {
            component_leaf_hashes[i] = ZKStateAndRef::compute_leaf_hash_ref(
                fingerprint[i],
                privacy_salt,
                ComponentGroupEnum::REFERENCES_GROUP as u32,
                i as u32,
            );
        }

        component_leaf_hashes
    }

    fn compute_component_group_hash(
        references: References,
        privacy_salt: PrivacySalt,
    ) -> ComponentGroupHashBits {
        let component_leaf_hashes = compute_leaf_hashes(references, privacy_salt);

        merkle_2_leaves(component_leaf_hashes)
    }
}
const COMMAND_SIZE: u16 = 1;
const COMMAND_BITS: u16 = U32_BITS;

enum CommandData {
    CREATE = 0,
    MOVE = 1,
}

struct ContentCommand {
    content: CommandData,
    is_filler: bool,
}

struct Commands {
    value: [ContentCommand; COMMAND_SIZE],
    group_hash: ComponentGroupHashBytes,
}

impl Commands {
    fn fingerprint_value(commands: Commands) -> [[bool; U32_BITS]; COMMAND_SIZE] {
        let mut result = [[false; U32_BITS]; COMMAND_SIZE];

        for i in 0..COMMAND_SIZE {
            result[i] = to_bits(commands.value[i].content as u32);
        }
        result
    }

    fn fingerprint_group_hash(commands: Commands) -> ComponentGroupHashBits {
        convert_hash_to_bits(commands.group_hash)
    }

    fn compute_leaf_hashes(
        commands: Commands,
        privacy_salt: PrivacySalt,
    ) -> [HashDigestBits; COMMAND_SIZE] {
        //get fingerpint
        let fingerprint = fingerprint_value(commands);

        let mut component_leaf_hashes = [[false; HASH_BITS]; COMMAND_SIZE];
        for i in (0 as u32)..(COMMAND_SIZE as u32) {
            component_leaf_hashes[i] = compute_leaf_hash_int(
                fingerprint[i],
                privacy_salt,
                ComponentGroupEnum::COMMANDS_GROUP as u32,
                i as u32,
            );
        }

        component_leaf_hashes
    }

    fn compute_component_group_hash(
        commands: Commands,
        privacy_salt: PrivacySalt,
    ) -> ComponentGroupHashBits {
        let component_leaf_hashes = compute_leaf_hashes(commands, privacy_salt);

        //Since COMMAND_SIZE = 1, we use zero padding first.
        let mut component_leaves = [[false; HASH_BITS]; 2];
        component_leaves[0] = component_leaf_hashes[0];

        merkle_2_leaves(component_leaves)
    }
}
const ATTACHMENT_SIZE: u16 = 2;

struct ContentAttachment {
    content: HashDigestBytes,
    is_filler: bool,
}

struct Attachments {
    value: [ContentAttachment; ATTACHMENT_SIZE],
    group_hash: ComponentGroupHashBytes,
}

impl Attachments {
    fn fingerprint_value(attachments: Attachments) -> [[bool; HASH_BITS]; ATTACHMENT_SIZE] {
        let mut result = [[false; HASH_BITS]; ATTACHMENT_SIZE];

        for i in 0..ATTACHMENT_SIZE {
            result[i] = convert_hash_to_bits(attachments.value[i].content);
        }
        result
    }

    fn fingerprint_group_hash(attachments: Attachments) -> ComponentGroupHashBits {
        convert_hash_to_bits(attachments.group_hash)
    }

    fn compute_leaf_hashes(
        attachments: Attachments,
        privacy_salt: PrivacySalt,
    ) -> [HashDigestBits; ATTACHMENT_SIZE] {
        //get fingerpint
        let fingerprint = fingerprint_value(attachments);

        let mut component_leaf_hashes = [[false; HASH_BITS]; ATTACHMENT_SIZE];
        for i in (0 as u32)..(ATTACHMENT_SIZE as u32) {
            component_leaf_hashes[i] = compute_leaf_hash_hash(
                fingerprint[i],
                privacy_salt,
                ComponentGroupEnum::ATTACHMENTS_GROUP as u32,
                i as u32,
            );
        }

        component_leaf_hashes
    }

    fn compute_component_group_hash(
        attachments: Attachments,
        privacy_salt: PrivacySalt,
    ) -> ComponentGroupHashBits {
        let component_leaf_hashes = compute_leaf_hashes(attachments, privacy_salt);

        merkle_2_leaves(component_leaf_hashes)
    }
}
struct ContentNotary {
    content: Party,
    is_filler: bool,
}

struct Notary {
    value: ContentNotary,
    group_hash: ComponentGroupHashBytes,
}

impl Notary {
    fn fingerprint_value(notary: Notary) -> [bool; PUBKEY_BITS] {
        convert_pubKey_to_bits(notary.value.content.owning_key)
    }

    fn fingerprint_group_hash(notary: Notary) -> ComponentGroupHashBits {
        convert_hash_to_bits(notary.group_hash)
    }

    fn compute_leaf_hashes(notary: Notary, privacy_salt: PrivacySalt) -> HashDigestBits {
        //get fingerpint
        let fingerprint = fingerprint_value(notary);

        let mut component_leaf_hashes = [false; HASH_BITS];
        component_leaf_hashes = compute_leaf_hash_pubKey(
            fingerprint,
            privacy_salt,
            ComponentGroupEnum::NOTARY_GROUP as u32,
            0 as u32,
        );

        component_leaf_hashes
    }

    fn compute_component_group_hash(
        notary: Notary,
        privacy_salt: PrivacySalt,
    ) -> ComponentGroupHashBits {
        let component_leaf_hashes = compute_leaf_hashes(notary, privacy_salt);

        //Since NOTARY_SIZE = 1, we use zero padding first.
        let mut component_leaves = [[false; HASH_BITS]; 2];
        component_leaves[0] = component_leaf_hashes;

        merkle_2_leaves(component_leaves)
    }
}
const TIME_WINDOW_BYTES: u16 = 24;
const TIME_WINDOW_BITS: u16 = (BYTE_BITS as u16) * TIME_WINDOW_BYTES;

struct ContentTimeWindow {
    content: [u8; TIME_WINDOW_BYTES],
    is_filler: bool,
}

struct TimeWindow {
    value: ContentTimeWindow,
    group_hash: ComponentGroupHashBytes,
}

fn compute_leaf_hash_timeW(
    value: [bool; TIME_WINDOW_BITS],
    privacy_salt: PrivacySalt,
    group_index: u32,
    internal_index: u32,
) -> HashDigestBits {
    //compute nonce
    let mut nonce = compute_nonce(privacy_salt, group_index, internal_index);
    let mut message: [bool; HASH_BITS + TIME_WINDOW_BITS] = [false; HASH_BITS + TIME_WINDOW_BITS];

    //message = nonce || signature
    for i in 0..HASH_BITS {
        message[i] = nonce[i];
    }
    for i in 0..TIME_WINDOW_BITS {
        message[HASH_BITS + i] = value[i];
    }

    blake2s(message)
}

impl TimeWindow {
    fn fingerprint_value(time_window: TimeWindow) -> [bool; TIME_WINDOW_BITS] {
        let mut result = [false; TIME_WINDOW_BITS];

        for i in (0 as u16)..TIME_WINDOW_BYTES {
            let time_window_bits = to_bits(time_window.value.content[i]);
            for j in (0 as u16)..(8 as u16) {
                result[i * (8 as u16) + j] = time_window_bits[j];
            }
        }

        result
    }

    fn fingerprint_group_hash(time_window: TimeWindow) -> ComponentGroupHashBits {
        convert_hash_to_bits(time_window.group_hash)
    }

    fn compute_leaf_hashes(time_window: TimeWindow, privacy_salt: PrivacySalt) -> HashDigestBits {
        //get fingerpint
        let fingerprint = fingerprint_value(time_window);

        let mut component_leaf_hashes = [false; HASH_BITS];
        component_leaf_hashes = compute_leaf_hash_timeW(
            fingerprint,
            privacy_salt,
            ComponentGroupEnum::TIMEWINDOW_GROUP as u32,
            0 as u32,
        );

        component_leaf_hashes
    }

    fn compute_component_group_hash(
        time_window: TimeWindow,
        privacy_salt: PrivacySalt,
    ) -> ComponentGroupHashBits {
        let component_leaf_hashes = compute_leaf_hashes(time_window, privacy_salt);

        //Since TIME_WINDOW_SIZE = 1, we use zero padding first.
        let mut component_leaves = [[false; HASH_BITS]; 2];
        component_leaves[0] = component_leaf_hashes;

        merkle_2_leaves(component_leaves)
    }
}
struct ContentParameter {
    content: HashDigestBytes,
    is_filler: bool,
}

struct Parameters {
    value: ContentParameter,
    group_hash: ComponentGroupHashBytes,
}

impl Parameters {
    fn fingerprint_value(parameters: Parameters) -> [bool; HASH_BITS] {
        convert_hash_to_bits(parameters.value.content)
    }

    fn fingerprint_group_hash(parameters: Parameters) -> ComponentGroupHashBits {
        convert_hash_to_bits(parameters.group_hash)
    }

    fn compute_leaf_hashes(parameters: Parameters, privacy_salt: PrivacySalt) -> HashDigestBits {
        //get fingerpint
        let fingerprint = fingerprint_value(parameters);

        let mut component_leaf_hashes = [false; HASH_BITS];
        component_leaf_hashes = compute_leaf_hash_hash(
            fingerprint,
            privacy_salt,
            ComponentGroupEnum::PARAMETERS_GROUP as u32,
            0 as u32,
        );

        component_leaf_hashes
    }

    fn compute_component_group_hash(
        parameters: Parameters,
        privacy_salt: PrivacySalt,
    ) -> ComponentGroupHashBits {
        let component_leaf_hashes = compute_leaf_hashes(parameters, privacy_salt);

        //Since PARAMETER_SIZE = 1, we use zero padding first.
        let mut component_leaves = [[false; HASH_BITS]; 2];
        component_leaves[0] = component_leaf_hashes;

        merkle_2_leaves(component_leaves)
    }
}
const SIGNER_SIZE: u16 = 2;
const SIGNER_BITS: u16 = PUBKEY_BITS;

struct ContentSigner {
    content: PubKey,
    is_filler: bool,
}

struct Signers {
    value: [ContentSigner; SIGNER_SIZE],
    group_hash: ComponentGroupHashBytes,
}

impl Signers {
    fn fingerprint_value(signers: Signers) -> [[bool; PUBKEY_BITS]; SIGNER_SIZE] {
        let mut result = [[false; PUBKEY_BITS]; SIGNER_SIZE];

        for i in 0..SIGNER_SIZE {
            result[i] = convert_pubKey_to_bits(signers.value[i].content);
        }
        result
    }

    fn fingerprint_group_hash(signers: Signers) -> ComponentGroupHashBits {
        convert_hash_to_bits(signers.group_hash)
    }

    fn compute_leaf_hashes(
        signers: Signers,
        privacy_salt: PrivacySalt,
    ) -> [HashDigestBits; SIGNER_SIZE] {
        //get fingerpint
        let fingerprint = fingerprint_value(signers);

        let mut component_leaf_hashes = [[false; HASH_BITS]; SIGNER_SIZE];
        for i in (0 as u32)..(SIGNER_SIZE as u32) {
            component_leaf_hashes[i] = compute_leaf_hash_pubKey(
                fingerprint[i],
                privacy_salt,
                ComponentGroupEnum::SIGNERS_GROUP as u32,
                i as u32,
            );
        }

        component_leaf_hashes
    }

    fn compute_component_group_hash(
        signers: Signers,
        privacy_salt: PrivacySalt,
    ) -> ComponentGroupHashBits {
        let component_leaf_hashes = compute_leaf_hashes(signers, privacy_salt);

        merkle_2_leaves(component_leaf_hashes)
    }
}
struct ZKProverTransaction {
    inputs: Inputs,
    outputs: Outputs,
    references: References,
    commands: Commands,
    attachments: Attachments,
    notary: Notary,
    time_window: TimeWindow,
    parameters: Parameters,
    signers: Signers,
    privacy_salt: [u8; HASH_BYTES],
}

struct Witness {
    transaction: ZKProverTransaction,
}
const COMPONENT_GROUP_SIZE: u8 = 9;

// Auxiliary method to validate a GroupHash
// * computed digest that is computed from witness.
// * received digest that is received within the witness.
// return bool If the computed value is equal to the one received then the function returns true. Otherwise, returns false.
fn validate_group_hash(computed: ComponentGroupHashBits, received: ComponentGroupHashBits) -> bool {
    let computed_bytes = digest_to_bytes(computed);
    let expected_bytes = digest_to_bytes(received);


    let mut is_equal = true;

    for i in 0..HASH_BITS {
        if computed[i] != received[i] {
            is_equal = false;
        }
    }
    is_equal
}

// Method to validate group hashes.
// * component_group_hashes that are computed from the witness ZKProverTransaction.
// * zk_prover_transaction  that contains component group hashes computed by the prover.
// If one component_group_hash value cannot be validated then the execution terminates.
fn validate_group_hashes(
    component_group_hashes: [ComponentGroupHashBits; COMPONENT_GROUP_SIZE],
    zk_prover_transaction: ZKProverTransaction,
) {
    //Validate component hashes
    let validate_input = validate_group_hash(
        component_group_hashes[ComponentGroupEnum::INPUTS_GROUP],
        Inputs::fingerprint_group_hash(zk_prover_transaction.inputs),
    );

    assert!(
        validate_input,
        "Failed computation: The computed input group hash does not match the received group hash."
    );

    let validate_output = validate_group_hash(
        component_group_hashes[ComponentGroupEnum::OUTPUTS_GROUP],
        Outputs::fingerprint_group_hash(zk_prover_transaction.outputs),
    );

    assert!(validate_output, "Failed computation: The computed output group hash does not match the received group hash.");

    let validate_command = validate_group_hash(
        component_group_hashes[ComponentGroupEnum::COMMANDS_GROUP],
        Commands::fingerprint_group_hash(zk_prover_transaction.commands),
    );

    assert!(validate_command, "Failed computation: The computed command group hash does not match the received group hash.");

    let validate_attachment = validate_group_hash(
        component_group_hashes[ComponentGroupEnum::ATTACHMENTS_GROUP],
        Attachments::fingerprint_group_hash(zk_prover_transaction.attachments),
    );

    assert!(validate_attachment, "Failed computation: The computed attachment group hash does not match the received group hash.");

    let validate_notary = validate_group_hash(
        component_group_hashes[ComponentGroupEnum::NOTARY_GROUP],
        Notary::fingerprint_group_hash(zk_prover_transaction.notary),
    );

    assert!(validate_notary, "Failed computation: The computed notary group hash does not match the received group hash.");

    let validate_time_window = validate_group_hash(
        component_group_hashes[ComponentGroupEnum::TIMEWINDOW_GROUP],
        TimeWindow::fingerprint_group_hash(zk_prover_transaction.time_window),
    );

    assert!(validate_time_window, "Failed computation: The computed time window group hash does not match the received group hash.");

    let validate_signers = validate_group_hash(
        component_group_hashes[ComponentGroupEnum::SIGNERS_GROUP],
        Signers::fingerprint_group_hash(zk_prover_transaction.signers),
    );

    assert!(validate_signers, "Failed computation: The computed signers group hash does not match the received group hash.");

    let validate_reference = validate_group_hash(
        component_group_hashes[ComponentGroupEnum::REFERENCES_GROUP],
        References::fingerprint_group_hash(zk_prover_transaction.references),
    );

    assert!(validate_reference, "Failed computation: The computed reference group hash does not match the received group hash.");

    let validate_parameters = validate_group_hash(
        component_group_hashes[ComponentGroupEnum::PARAMETERS_GROUP],
        Parameters::fingerprint_group_hash(zk_prover_transaction.parameters),
    );

    assert!(validate_parameters, "Failed computation: The computed parameters group hash does not match the received group hash.");
}
fn build_merkle_tree(
    zk_prover_transaction: ZKProverTransaction,
    privacy_salt: PrivacySalt,
) -> HashDigestBits {
    let mut component_group_hashes = [[false; HASH_BITS]; COMPONENT_GROUP_SIZE];

    component_group_hashes[ComponentGroupEnum::INPUTS_GROUP] =
        Inputs::compute_component_group_hash(zk_prover_transaction.inputs, privacy_salt);
    component_group_hashes[ComponentGroupEnum::OUTPUTS_GROUP] =
        Outputs::compute_component_group_hash(zk_prover_transaction.outputs, privacy_salt);
    component_group_hashes[ComponentGroupEnum::COMMANDS_GROUP] =
        Commands::compute_component_group_hash(zk_prover_transaction.commands, privacy_salt);
    component_group_hashes[ComponentGroupEnum::ATTACHMENTS_GROUP] =
        Attachments::compute_component_group_hash(zk_prover_transaction.attachments, privacy_salt);
    component_group_hashes[ComponentGroupEnum::NOTARY_GROUP] =
        Notary::compute_component_group_hash(zk_prover_transaction.notary, privacy_salt);
    component_group_hashes[ComponentGroupEnum::TIMEWINDOW_GROUP] =
        TimeWindow::compute_component_group_hash(zk_prover_transaction.time_window, privacy_salt);
    component_group_hashes[ComponentGroupEnum::SIGNERS_GROUP] =
        Signers::compute_component_group_hash(zk_prover_transaction.signers, privacy_salt);
    component_group_hashes[ComponentGroupEnum::REFERENCES_GROUP] =
        References::compute_component_group_hash(zk_prover_transaction.references, privacy_salt);
    component_group_hashes[ComponentGroupEnum::PARAMETERS_GROUP] =
        Parameters::compute_component_group_hash(zk_prover_transaction.parameters, privacy_salt);

    //Validate component group hashes
    //This function is currently disabled since witness file is all zeros.
    //validate_group_hashes(component_group_hashes, zk_prover_transaction);

    // There are 9 component groups.
    // Pad it from the right with as many zero hashes to get a power of two number of leaves.
    // This is how Corda Merkle tree construction works.
    let mut component_leaves = [[false; HASH_BITS]; 16];
    for i in 0..COMPONENT_GROUP_SIZE {
        component_leaves[i] = component_group_hashes[i];
    }

    merkle_16_leaves(component_leaves)
}
//Temporary function to test isFiller attribute
fn check_contract_rules(value: ZKProverTransaction) {
    //Check if inputs total is equal to outputs total
    let mut input_value_sum: i32 = 0;
    let mut output_value_sum: i32 = 0;

    for i in 0..INPUT_SIZE
    while !value.inputs.value[i].is_filler {
        input_value_sum = input_value_sum + value.inputs.value[i].content.state.data.value;
    }

    for i in 0..OUTPUT_SIZE
    while !value.outputs.value[i].is_filler {
        output_value_sum = output_value_sum + value.outputs.value[i].content.state.data.value;
    }

    assert!(
        input_value_sum == output_value_sum,
        "Failed requirement: the total value of the inputs and outputs should be equal"
    );
}
struct PublicInput {
    transactionId: [u8; 32],
}

fn main(witness: Witness) -> PublicInput {
    //Check contract rules
    check_contract_rules(witness.transaction);

    //Fingerprint for privacy salt
    let privacy_salt = convert_hash_to_bits(witness.transaction.privacy_salt);

    //Compute the transaction id
    let root_hash = build_merkle_tree(witness.transaction, privacy_salt);

    PublicInput {
        transactionId: digest_to_bytes(root_hash),
    }
}
