//!
//! The 'ZKMerkleTree' main module.
//!
mod ZKMerkleTree;
mod ComponentGroups;

use ComponentGroups::ZKProverTransaction;
use ComponentGroups::PrivacySalt; 

use ZKMerkleTree::ComponentGroup; 
use ZKMerkleTree::InputGroup;
use ZKMerkleTree::OutputGroup; 
use ZKMerkleTree::CommandDataGroup; 
use ZKMerkleTree::ReferenceGroup; 
use ZKMerkleTree::CommandSignerGroup; 


//Temporary function to manually transfer components to zkmerkle tree !!!
fn convertFromComponentToZKMerkle(zkptx: (ComponentGroups::ComponentGroup, PrivacySalt)) -> (ComponentGroup, PrivacySalt)
{
    (ComponentGroup {
        inputs: InputGroup{
                    groupElements: zkptx.0.inputs.groupElements,
                    groupHash: zkptx.0.inputs.groupHash, 
                },
        outputs: OutputGroup{
                    groupElements: zkptx.0.outputs.groupElements,
                    groupHash: zkptx.0.outputs.groupHash, 
                },        
        commandData: CommandDataGroup{
                    groupElements: zkptx.0.commandData.groupElements,
                    groupHash: zkptx.0.commandData.groupHash, 
                },

        references: ReferenceGroup{
                    groupElements: zkptx.0.references.groupElements,
                    groupHash: zkptx.0.references.groupHash, 
                },

        commandSigners: CommandSignerGroup{
                    groupElements: zkptx.0.commandSigners.groupElements,
                    groupHash: zkptx.0.commandSigners.groupHash, 
                }, 
    },
    zkptx.1)
}


fn main(witness: ZKProverTransaction) -> [u8;32] //ZKMerkleTree::PedersenDigest
{
    //Check contract rules
    //Check value
    //assert!(witness.inputs.value[0].state.data.value == witness.outputs.value[0].state.data.value, "Failed requirement: the value of the input and out put should be equal");

    let zkptx:(ComponentGroups::ComponentGroup, PrivacySalt) = ComponentGroups::buildComponentGroups(witness);
    let root_hash = ZKMerkleTree::buildMerkleTree(convertFromComponentToZKMerkle(zkptx));

    let mut root_bytes = [0 as u8;32]; 
    for i in 0..32{
        let mut byte_bits = [false;8];
        for j in 0..8{
            byte_bits[j] = root_hash[8 * i + j];
        }
        root_bytes[i] = std::convert::from_bits_unsigned(byte_bits); 
    }

    root_bytes
}
