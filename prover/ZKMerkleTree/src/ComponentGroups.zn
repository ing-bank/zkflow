use std::convert::to_bits; 

//number of elements in each component group
const N_INPUTS:u16 = 2; 
const N_OUTPUTS:u16 = 2;
const N_REFERENCES:u16 = 2; 
const N_SIGNERS:u16 = 2;
const N_COMMANDS:u16 = 1;

const PUBKEY_BYTES:u16 = 44;
const PUBKEY_BITS:u16 = (8 as u16) * PUBKEY_BYTES;

const HASH_BYTES:u16 = 32;
const HASH_BITS:u16 = (8 as u16) * HASH_BYTES;

const INT32_BITS:u16 = 32; 
const INT128_BITS:u16 = 128;

//Number of bits for each component group
//Input, Output, and Reference components have the same structure which is ZKStateAndRef. 
//The size of state bits depends on the content of the state. The example state we have contains two public keys and an integer value. 
const STATE_BITS:u16 = PUBKEY_BITS + INT32_BITS + PUBKEY_BITS;
const REF_BITS:u16 = HASH_BITS;

const SIGNER_BITS:u16 = PUBKEY_BITS; 
const COMMAND_BITS:u16 = INT32_BITS; 

type PubKey = [u8; PUBKEY_BYTES];
type PrivacySalt = [bool; HASH_BITS]; 
type ComponentGroupHash = [u8; HASH_BYTES]; //For now we use SHA256 to compute component group hashes - should be replaced with Pedersen!

enum CommandData {
    CREATE = 0,
    MOVE = 1,
}

struct Owner{
    owningKey: PubKey,
}

struct Data {
    owner: Owner,
    value: i32,
}

struct Notary {
    owningKey: [u8; PUBKEY_BYTES],
}

/*
This struct follows the structure in the original Corda TransactionState structure. The fields contractCN, 
encumbrance and constraint declared bool intentionally to reserve their place in the structure. In the current 
implementation we don't use these fields, if they are going to be included, they should be declared with the 
corresponding data type. 
*/
struct TransactionState {
    data: Data,
    contractCN: bool,
    notary: Notary,
    encumbrance: bool,
    constraint: bool,
    nonce: [u8; HASH_BYTES],
}

struct ZKStateRef {
    id: [u8;HASH_BYTES],
}

struct ZKStateAndRef {
    state: TransactionState,
    reference: ZKStateRef,
}

struct Command {
    data: CommandData,
    signers: [PubKey; N_SIGNERS],
}

struct Inputs {
    value: [ZKStateAndRef; N_INPUTS],
    groupHash: ComponentGroupHash, 
}

struct Outputs {
    value: [ZKStateAndRef; N_OUTPUTS],
    groupHash: ComponentGroupHash,
}

struct References {
    value: [ZKStateAndRef; N_REFERENCES],
    groupHash: ComponentGroupHash,
}

struct Commands {
    value: Command, 
    dataGroupHash: ComponentGroupHash,
    signerGroupHash: ComponentGroupHash,
}

struct ZKProverTransaction {
    inputs: Inputs,
    outputs: Outputs,
    references: References,
    commands: Commands,  
    privacySalt: [u8; HASH_BYTES],
}


struct ZKStateAndRefGroup{
    state : [bool; STATE_BITS], 
    zkStateRef: [bool; REF_BITS],
    nonce: [bool; HASH_BITS], 
}


struct InputGroup {
    groupElements: [ZKStateAndRefGroup; N_INPUTS],
    groupHash: [bool;HASH_BITS],  
}

struct OutputGroup {
    groupElements: [ZKStateAndRefGroup; N_OUTPUTS],
    groupHash: [bool;HASH_BITS],  
}

struct ReferenceGroup{
    groupElements: [ZKStateAndRefGroup; N_REFERENCES],
    groupHash: [bool;HASH_BITS],      
}

struct CommandDataGroup {
    groupElements: [bool; INT32_BITS],
    groupHash: [bool;HASH_BITS],  
}

struct CommandSignerGroup {
    groupElements: [[bool; PUBKEY_BITS]; N_SIGNERS],
    groupHash: [bool;HASH_BITS],  
}

struct ComponentGroup{
    inputs: InputGroup,
    outputs: OutputGroup,
    commandData: CommandDataGroup,  
    references: ReferenceGroup,
    commandSigners: CommandSignerGroup,
}

fn convertHashToBits(value:[u8;HASH_BYTES]) -> [bool; HASH_BITS]
{
    let mut hashDigest_bits = [false; HASH_BITS];

    for i in (0 as u16) .. HASH_BYTES{
        let hd_bits = to_bits(value[i]);
        for j in (0 as u16) .. (8 as u16) {
            hashDigest_bits[(8 as u16)* i + j] = hd_bits[j];
        }
    }
    hashDigest_bits 
}

fn convertStateToBits(value:TransactionState) -> [bool; STATE_BITS]
{
    let mut result = [false; STATE_BITS]; 

    //state_bits = dataOwner_owningKey || value || notary_owningKey
    for j in (0 as u16)..PUBKEY_BYTES {
        let owner_bits = to_bits(value.data.owner.owningKey[j]);
        for k in (0 as u16)..(8 as u16) {
            result[(8 as u16) * j + k]  = owner_bits[k];
        }
    }

    let value_bits = to_bits(value.data.value);
    for j in (0 as u16)..INT32_BITS {
        result[PUBKEY_BITS + j ]  = value_bits[j];
    }

    for j in (0 as u16)..PUBKEY_BYTES {
        let notary_bits = to_bits(value.notary.owningKey[j]);
        for k in (0 as u16)..(8 as u16) {
            result[PUBKEY_BITS + INT32_BITS + (8 as u16) * j + k]  = notary_bits[k];
        }
    }

    result
}

fn convertInputsToBits(value:[ZKStateAndRef; N_INPUTS]) -> [ZKStateAndRefGroup; N_INPUTS]
{
    let mut result = [ZKStateAndRefGroup{
                                            state: [false; STATE_BITS],
                                            zkStateRef: [false; REF_BITS],
                                            nonce: [false; HASH_BITS],  
                                        }; N_INPUTS];
    for i in 0.. N_INPUTS { 
        //state bits 
        result[i].state = convertStateToBits(value[i].state); 
        //zkStateRef bits 
        result[i].zkStateRef = convertHashToBits(value[i].reference.id); 
        //zkStateRef nonce bits 
        result[i].nonce = convertHashToBits(value[i].state.nonce);
    } 
    result  
}

fn convertOutputsToBits(value:[ZKStateAndRef; N_OUTPUTS]) -> [ZKStateAndRefGroup; N_OUTPUTS]
{
    let mut result = [ZKStateAndRefGroup{
                                            state: [false; STATE_BITS],
                                            zkStateRef: [false; REF_BITS],
                                            nonce: [false; HASH_BITS],  
                                        }; N_OUTPUTS];
    for i in 0.. N_OUTPUTS { 
        //state bits 
        result[i].state = convertStateToBits(value[i].state); 
        //zkStateRef bits 
        result[i].zkStateRef = convertHashToBits(value[i].reference.id); 
        //zkStateRef nonce bits 
        result[i].nonce = convertHashToBits(value[i].state.nonce);
    } 
    result  
}

fn convertReferencesToBits(value:[ZKStateAndRef; N_REFERENCES]) -> [ZKStateAndRefGroup; N_REFERENCES]
{
    let mut result = [ZKStateAndRefGroup{
                                            state: [false; STATE_BITS],
                                            zkStateRef: [false; REF_BITS],
                                            nonce: [false; HASH_BITS],  
                                        }; N_REFERENCES];
    for i in 0.. N_REFERENCES { 
        //state bits 
        result[i].state = convertStateToBits(value[i].state); 
        //zkStateRef bits 
        result[i].zkStateRef = convertHashToBits(value[i].reference.id); 
        //zkStateRef nonce bits 
        result[i].nonce = convertHashToBits(value[i].state.nonce);
    }

    result  
}

fn convertCommandDataToBits(value:CommandData) -> [bool; COMMAND_BITS]
{
    to_bits(value as u32) 
}

fn convertCommandSignersToBits(value:[PubKey; N_SIGNERS]) -> [[bool; SIGNER_BITS]; N_SIGNERS]
{
    let mut result = [[false; SIGNER_BITS];N_SIGNERS];

    for i in 0 .. N_SIGNERS {
        for j in 0 .. (SIGNER_BITS/ (8 as u16)){
            let commandSigner_bits = to_bits(value[i][j]);
            for k in (0 as u16)..(8 as u16) {
                result[i][(8 as u16) * j + k]  = commandSigner_bits[k];
            }
        }
    }   

    result  
}

fn buildComponentGroups(zkptx:ZKProverTransaction) -> (ComponentGroup, PrivacySalt)
{
    (
        ComponentGroup {
        inputs: InputGroup{
                groupElements: convertInputsToBits(zkptx.inputs.value),
                groupHash: convertHashToBits(zkptx.inputs.groupHash),
            },

        outputs: OutputGroup{
                groupElements: convertOutputsToBits(zkptx.outputs.value),
                groupHash: convertHashToBits(zkptx.outputs.groupHash),
            },

        commandData: CommandDataGroup{
                groupElements: convertCommandDataToBits(zkptx.commands.value.data),
                groupHash: convertHashToBits(zkptx.commands.dataGroupHash),
            }, 

        references: ReferenceGroup{
                groupElements: convertReferencesToBits(zkptx.references.value),
                groupHash: convertHashToBits(zkptx.references.groupHash),
            },        

        commandSigners: CommandSignerGroup{
                groupElements: convertCommandSignersToBits(zkptx.commands.value.signers),
                groupHash: convertHashToBits(zkptx.commands.signerGroupHash),
            }, 
        },
        convertHashToBits(zkptx.privacySalt)
    )
}