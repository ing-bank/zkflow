use std::convert::to_bits; 

//number of elements in each component group
const N_INPUTS:u16 = 2; 
const N_OUTPUTS:u16 = 2;
const N_REFERENCES:u16 = 2; 
const N_SIGNERS:u16 = 2;
const N_COMMANDS:u16 = 1;
const N_ATTACHMENTS: u16 = 2; 

const PUBKEY_BYTES:u16 = 44;
const PUBKEY_BITS:u16 = (8 as u16) * PUBKEY_BYTES;

const HASH_BYTES:u16 = 32;
const HASH_BITS:u16 = (8 as u16) * HASH_BYTES;
const TIME_WINDOW_BYTES: u16 = 24;  

const INT32_BITS:u16 = 32; 
const INT128_BITS:u16 = 128;

//Number of bits for each component group
//Input, Output, and Reference components have the same structure which is ZKStateAndRef. 
//The size of state bits depends on the content of the state. The example state we have contains two public keys and an integer value. 
const STATE_BITS:u16 = PUBKEY_BITS + INT32_BITS + PUBKEY_BITS;
const REF_BITS:u16 = HASH_BITS;

const SIGNER_BITS:u16 = PUBKEY_BITS; 
const COMMAND_BITS:u16 = INT32_BITS; 

type PubKey = [u8; PUBKEY_BYTES];
type HashDigest = [u8; HASH_BYTES];

type PrivacySalt = [bool; HASH_BITS]; 
type ComponentGroupHash = [u8; HASH_BYTES];

enum CommandData {
    CREATE = 0,
    MOVE = 1,
}

struct Owner{
    owningKey: PubKey,
}

struct Data {
    owner: Owner,
    value: i32,
}

struct NotaryTS {
    owningKey: [u8; PUBKEY_BYTES],
}

/*
This struct follows the structure in the original Corda TransactionState structure. The fields contractCN, 
encumbrance and constraint are commented out and declared bool intentionally to reserve their place in the 
structure. In the current implementation we don't use these fields, if they are going to be included, they 
should be declared with the corresponding data type. 
*/
struct TransactionState {
    data: Data,
    //contractCN: bool,
    notary: NotaryTS,
    //encumbrance: bool,
    //constraint: bool,
}

struct ZKStateRef {
    id: [u8;HASH_BYTES],
}

struct ZKStateAndRef {
    state: TransactionState,
    reference: ZKStateRef,
}

struct ContentZKStateAndRef {
    content: ZKStateAndRef,
    isFiller: bool, 
}

struct Inputs {
    value: [ContentZKStateAndRef; N_INPUTS],
    groupHash: ComponentGroupHash, 
}

struct Outputs {
    value: [ContentZKStateAndRef; N_OUTPUTS],
    groupHash: ComponentGroupHash,
}

struct References {
    value: [ContentZKStateAndRef; N_REFERENCES],
    groupHash: ComponentGroupHash,
}

struct ContentCommandData{
    content: CommandData,
    isFiller: bool, 
}

struct Commands {
    value: [ContentCommandData; N_COMMANDS], 
    groupHash: ComponentGroupHash,
}

struct ContentAttachments {
    content: HashDigest,
    isFiller: bool,
}

struct Attachments {
    value: [ContentAttachments; N_ATTACHMENTS],
    groupHash: ComponentGroupHash,
}

struct ContentNotary {
    content: NotaryTS,
    isFiller: bool,
}

struct Notary {
    value: ContentNotary,
    groupHash: ComponentGroupHash,
}

struct ContentTimeWindow {
    content: [u8; TIME_WINDOW_BYTES],
    isFiller: bool,
}

struct TimeWindow {
    value: ContentTimeWindow,
    groupHash: ComponentGroupHash,
}

struct ContentParameters {
    content: HashDigest,
    isFiller: bool,
}

struct Parameters {
    value: ContentParameters,
    groupHash: ComponentGroupHash,
}

struct ContentSigners {
    content: PubKey,
    isFiller: bool, 
}

struct Signers {
    value: [ContentSigners; N_SIGNERS], 
    groupHash: ComponentGroupHash,
}

struct ZKProverTransaction {
    inputs: Inputs,
    outputs: Outputs,
    references: References,
    commands: Commands,
    attachments: Attachments,
    notary: Notary,
    timeWindow: TimeWindow,
    parameters: Parameters,
    signers: Signers,  
    privacySalt: [u8; HASH_BYTES],
}

struct ZKStateAndRefGroup {
    state: [bool; STATE_BITS], 
    zkStateRef: [bool; REF_BITS], 
}

struct ContentZKStateAndRefGroup{
    content: ZKStateAndRefGroup,
    isFiller: bool,  
}

struct InputGroup {
    groupElements: [ContentZKStateAndRefGroup; N_INPUTS],
    groupHash: [bool;HASH_BITS],  
}

struct OutputGroup {
    groupElements: [ContentZKStateAndRefGroup; N_OUTPUTS],
    groupHash: [bool;HASH_BITS],  
}

struct ReferenceGroup{
    groupElements: [ContentZKStateAndRefGroup; N_REFERENCES],
    groupHash: [bool;HASH_BITS],      
}

struct ContentCommandDataGroup{
    content: [bool; INT32_BITS], 
    isFiller: bool, 
}

struct CommandDataGroup {
    groupElements: [ContentCommandDataGroup; N_COMMANDS],
    groupHash: [bool;HASH_BITS],  
}

struct ContentCommandSignerGroup{
    content: [bool; PUBKEY_BITS],
    isFiller: bool, 
}

struct CommandSignerGroup {
    groupElements: [ContentCommandSignerGroup; N_SIGNERS],
    groupHash: [bool;HASH_BITS],  
}

struct ComponentGroup{
    inputs: InputGroup,
    outputs: OutputGroup,
    commandData: CommandDataGroup,  
    references: ReferenceGroup,
    commandSigners: CommandSignerGroup,
}

fn convertHashToBits(value:[u8;HASH_BYTES]) -> [bool; HASH_BITS]
{
    let mut hashDigest_bits = [false; HASH_BITS];

    for i in (0 as u16) .. HASH_BYTES{
        let hd_bits = to_bits(value[i]);
        for j in (0 as u16) .. (8 as u16) {
            hashDigest_bits[(8 as u16)* i + j] = hd_bits[j];
        }
    }
    hashDigest_bits
}

fn convertStateToBits(value:TransactionState) -> [bool; STATE_BITS]
{
    let mut result = [false; STATE_BITS]; 

    //state_bits = dataOwner_owningKey || value || notary_owningKey
    for j in (0 as u16)..PUBKEY_BYTES {
        let owner_bits = to_bits(value.data.owner.owningKey[j]);
        for k in (0 as u16)..(8 as u16) {
            result[(8 as u16) * j + k]  = owner_bits[k];
        }
    }

    let value_bits = to_bits(value.data.value);
    for j in (0 as u16)..INT32_BITS {
        result[PUBKEY_BITS + j ]  = value_bits[j];
    }

    for j in (0 as u16)..PUBKEY_BYTES {
        let notary_bits = to_bits(value.notary.owningKey[j]);
        for k in (0 as u16)..(8 as u16) {
            result[PUBKEY_BITS + INT32_BITS + (8 as u16) * j + k]  = notary_bits[k];
        }
    }

    result
}

fn convertInputsToBits(value:[ContentZKStateAndRef; N_INPUTS]) -> [ContentZKStateAndRefGroup; N_INPUTS]
{
    let mut result = [ContentZKStateAndRefGroup{ 
                        content: ZKStateAndRefGroup{
                                            state: [false; STATE_BITS],
                                            zkStateRef: [false; REF_BITS]},
                        isFiller: false,                     
                                        }; N_INPUTS];
    for i in 0.. N_INPUTS { 
        //state bits 
        result[i].content.state = convertStateToBits(value[i].content.state); 
        //zkStateRef bits 
        result[i].content.zkStateRef = convertHashToBits(value[i].content.reference.id); 

        //isFiller
        result[i].isFiller = value[i].isFiller; 
    } 
    result  
}

fn convertOutputsToBits(value:[ContentZKStateAndRef; N_OUTPUTS]) -> [ContentZKStateAndRefGroup; N_OUTPUTS]
{
    let mut result = [ContentZKStateAndRefGroup{
                        content: ZKStateAndRefGroup{
                                            state: [false; STATE_BITS],
                                            zkStateRef: [false; REF_BITS],},
                        isFiller: false, 
                                        }; N_OUTPUTS];
    for i in 0.. N_OUTPUTS { 
        //state bits 
        result[i].content.state = convertStateToBits(value[i].content.state); 
        //zkStateRef bits 
        result[i].content.zkStateRef = convertHashToBits(value[i].content.reference.id); 
        
        //isFiller
        result[i].isFiller = value[i].isFiller;
    } 
    result  
}

fn convertReferencesToBits(value:[ContentZKStateAndRef; N_REFERENCES]) -> [ContentZKStateAndRefGroup; N_REFERENCES]
{
    let mut result = [ContentZKStateAndRefGroup{
                        content: ZKStateAndRefGroup{
                                            state: [false; STATE_BITS],
                                            zkStateRef: [false; REF_BITS],},
                        isFiller: false,  
                                        }; N_REFERENCES];
    for i in 0.. N_REFERENCES { 
        //state bits 
        result[i].content.state = convertStateToBits(value[i].content.state); 
        //zkStateRef bits 
        result[i].content.zkStateRef = convertHashToBits(value[i].content.reference.id); 
        
        //isFiller
        result[i].isFiller = value[i].isFiller; 
    }
    result  
}

fn convertCommandDataToBits(value:[ContentCommandData; N_COMMANDS]) -> [ContentCommandDataGroup; N_COMMANDS]
{
    let mut result = [ContentCommandDataGroup{
                        content: [false; INT32_BITS],
                        isFiller: false, 
                                        };N_COMMANDS];
    for i in 0 .. N_COMMANDS { 
        let commandBits = to_bits(value[i].content as u32); 
        for j in 0..INT32_BITS{
            result[i].content[j]  = commandBits[j];
        }
        result[i].isFiller = value[i].isFiller; 

    }  
    result                             
}

fn convertCommandSignersToBits(value:[ContentSigners; N_SIGNERS]) -> [ContentCommandSignerGroup; N_SIGNERS]
{
    let mut result = [ContentCommandSignerGroup{
                        content: [false; SIGNER_BITS],
                        isFiller: false, 
                                        };N_SIGNERS];

    for i in 0 .. N_SIGNERS {
        for j in 0 .. (SIGNER_BITS/ (8 as u16)){
            let commandSigner_bits = to_bits(value[i].content[j]);
            for k in (0 as u16)..(8 as u16) {
                result[i].content[(8 as u16) * j + k]  = commandSigner_bits[k];
            }
        }
        result[i].isFiller = value[i].isFiller;  
    }   

    result  
}

fn buildComponentGroups(zkptx:ZKProverTransaction) -> (ComponentGroup, PrivacySalt)
{
    (
        ComponentGroup {
        inputs: InputGroup{
                groupElements: convertInputsToBits(zkptx.inputs.value),
                groupHash: convertHashToBits(zkptx.inputs.groupHash),
            },

        outputs: OutputGroup{
                groupElements: convertOutputsToBits(zkptx.outputs.value),
                groupHash: convertHashToBits(zkptx.outputs.groupHash),
            },

        commandData: CommandDataGroup{
                groupElements: convertCommandDataToBits(zkptx.commands.value),
                groupHash: convertHashToBits(zkptx.commands.groupHash),
            }, 

        references: ReferenceGroup{
                groupElements: convertReferencesToBits(zkptx.references.value),
                groupHash: convertHashToBits(zkptx.references.groupHash),
            },        

        commandSigners: CommandSignerGroup{
                groupElements: convertCommandSignersToBits(zkptx.signers.value),
                groupHash: convertHashToBits(zkptx.commands.groupHash),
            }, 
        },
        convertHashToBits(zkptx.privacySalt)
    )
}

//Temporary function to test isFiller attribute - it should be moved to a separate file when zinc allows better file system management
fn CheckContractRules(value: ZKProverTransaction)
{
    //Check if inputs total is equal to outputs total
    let mut inputValueSum:i32 = 0;
    let mut outputValueSum:i32 = 0;

    for i in 0..N_INPUTS while value.inputs.value[i].isFiller == false {
        inputValueSum = inputValueSum + value.inputs.value[i].content.state.data.value; 
    }

    for i in 0..N_OUTPUTS while value.outputs.value[i].isFiller == false {
        outputValueSum = outputValueSum + value.outputs.value[i].content.state.data.value; 
    }

    assert!(inputValueSum == outputValueSum, "Failed requirement: the total value of the inputs and outputs should be equal");
}