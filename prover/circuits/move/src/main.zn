//! Combined circuit
//! GENERATED CODE. DO NOT EDIT
//! Edit a corresponding constituent

//!  IN ==== /Users/EU88FH/Developer/corda-zkp/zk-notary/prover/modules/shared/floating_point_24_6.zn
//In case if value can't be stored in BigDecimal, it will throw an exception,
//the some goes for arithmetic operations.
const INTEGER_SIZE: u8 = 24;
const FRACTION_SIZE: u8 = 6;

//Original BigDecimal in Java stores all digits in one array, and uses scale as a number of digits to the right side of
//the decimal point. Then it calculates the difference in scale of two comparing BigDecimals to adjust digits.
//For example:
//1.2, which is an array of [1, 2] and scale 1, plus 10, which is an array [1, 0], but scale 0.
//So, arrays must be adjusted w.r.t. scales, such that the digits of the same significance have the same index. Then arithmetic operations can be applied.
//
//However, zinc doesn't support indexes inferred from witnesses, so it is impossible to adjust arrays in the same way (i + scale_A - scale_B), so we use two separate arrays to
//store integer value of BigDecimal and its fraction. It is stored in little-Endian order.
//
//Description of struct properties:
//sign - sign of stored variable, belongs to {-1, 0, 1}
//integer - decimal representation of integer part of stored value, can contain only 1024 digits
//fraction - decimal representation of fraction part of stored value, can contain only 128 digits
struct BigDecimal {
    sign: i8,
    integer: [u8; INTEGER_SIZE],
    fraction: [u8; FRACTION_SIZE],
}

impl BigDecimal {
    //comparison if the same sign
    fn _compare_magnitude(this: BigDecimal, that: BigDecimal) -> i8 {
        let mut result: i8 = 0 as i8;
        for i in 0..INTEGER_SIZE {
            if result == 0 as i8 {
                result = if this.integer[i] > that.integer[i] {
                    1 as i8
                } else {
                    if this.integer[i] < that.integer[i] {
                        -1
                    } else {
                        0 as i8
                    }
                };
            }
        }

        if result == 0 as i8 {
            for i in 0..FRACTION_SIZE {
                if result == 0 as i8 {
                    result = if this.fraction[i] > that.fraction[i] {
                        1 as i8
                    } else {
                        if this.fraction[i] < that.fraction[i] {
                            -1
                        } else {
                            0 as i8
                        }
                    };
                }
            }
            result
        } else {
            result
        }
    }

    //We compare signs, then if they're different (one of inputs is negative or zero), there's no need to compare magnitude.
    //Otherwise, we compare magnitude and provide result w.r.t. to the sign (if it's negative, then magnitude of the first
    //input can be less, but first argument still will be bigger).
    fn compare(this: BigDecimal, that: BigDecimal) -> i8 {
        if this.sign == that.sign {
            if this.sign == 0 as i8 {
                0 as i8
            } else {
                this.sign * _compare_magnitude(this, that)
            }
        } else {
            if this.sign > that.sign {
                1 as i8
            } else {
                -1
            }
        }
    }

    fn equals(this: BigDecimal, that: BigDecimal) -> bool {
        this.sign == that.sign && BigDecimal::_compare_magnitude(this, that) == 0 as i8
    }

    fn _sum_magnitude(this: BigDecimal, that: BigDecimal) -> BigDecimal {
        let mut fraction: [u8; FRACTION_SIZE] = [0; FRACTION_SIZE];
        let mut diff = 0;

        for i in 0..FRACTION_SIZE {
            let value =
                this.fraction[FRACTION_SIZE - i - 1] + that.fraction[FRACTION_SIZE - i - 1] + diff;
            if value >= 10 {
                diff = 1;
                fraction[FRACTION_SIZE - i - 1] = value - 10;
            } else {
                diff = 0;
                fraction[FRACTION_SIZE - i - 1] = value;
            }
        }

        let mut integer: [u8; INTEGER_SIZE] = [0; INTEGER_SIZE];
        for i in 0..INTEGER_SIZE {
            let value =
                this.integer[INTEGER_SIZE - i - 1] + that.integer[INTEGER_SIZE - i - 1] + diff;
            if value >= 10 {
                diff = 1;
                integer[INTEGER_SIZE - i - 1] = value - 10;
            } else {
                diff = 0;
                integer[INTEGER_SIZE - i - 1] = value;
            }
        }

        assert!(diff != 1, "Magnitude exceeds the maximum stored value");

        BigDecimal {
            sign: this.sign,
            integer: integer,
            fraction: fraction,
        }
    }

    //this >= that, but this[i] is not necessarily >= that[i]
    fn _subtract_magnitude(this: BigDecimal, that: BigDecimal) -> BigDecimal {
        let mut fraction: [u8; FRACTION_SIZE] = [0; FRACTION_SIZE];
        let mut diff = 0;
        for i in 0..FRACTION_SIZE {
            let value = this.fraction[FRACTION_SIZE - i - 1] as i8
                - that.fraction[FRACTION_SIZE - i - 1] as i8
                - diff as i8;
            if value < 0 as i8 {
                diff = 1;
                fraction[FRACTION_SIZE - i - 1] = (10 as i8 + value) as u8;
            } else {
                diff = 0;
                fraction[FRACTION_SIZE - i - 1] = value as u8;
            }
        }

        let mut integer: [u8; INTEGER_SIZE] = [0; INTEGER_SIZE];
        for i in 0..INTEGER_SIZE {
            let value = this.integer[INTEGER_SIZE - i - 1] as i8
                - that.integer[INTEGER_SIZE - i - 1] as i8
                - diff as i8;
            if value < 0 as i8 {
                diff = 1;
                integer[INTEGER_SIZE - i - 1] = (10 as i8 + value) as u8;
            } else {
                diff = 0;
                integer[INTEGER_SIZE - i - 1] = value as u8;
            }
        }

        let sign = if diff == 1 { -1 } else { 1 as i8 };

        BigDecimal {
            sign: sign,
            integer: integer,
            fraction: fraction,
        }
    }

    fn _handle_different_signs(this: BigDecimal, that: BigDecimal) -> BigDecimal {
        let comparison = _compare_magnitude(this, that);
        if comparison == 0 as i8 {
            BigDecimal {
                sign: 0 as i8,
                integer: [0; INTEGER_SIZE],
                fraction: [0; FRACTION_SIZE],
            }
        } else {
            let absolute_diff = if comparison == 1 as i8 {
                _subtract_magnitude(this, that)
            } else {
                _subtract_magnitude(that, this)
            };
            BigDecimal {
                sign: comparison * this.sign,
                integer: absolute_diff.integer,
                fraction: absolute_diff.fraction,
            }
        }
    }

    fn _handle_same_sign(this: BigDecimal, that: BigDecimal) -> BigDecimal {
        if that.sign == 0 as i8 {
            BigDecimal {
                sign: 0 as i8,
                integer: [0; INTEGER_SIZE],
                fraction: [0; FRACTION_SIZE],
            }
        } else {
            _sum_magnitude(this, that)
        }
    }

    fn plus(this: BigDecimal, that: BigDecimal) -> BigDecimal {
        if this.sign == 0 as i8 {
            that
        } else {
            if that.sign == 0 as i8 {
                this
            } else {
                if this.sign == that.sign {
                    _handle_same_sign(this, that)
                } else {
                    _handle_different_signs(this, that)
                }
            }
        }
    }

    fn minus(this: BigDecimal, that: BigDecimal) -> BigDecimal {
        let negated = BigDecimal {
            sign: -that.sign,
            integer: that.integer,
            fraction: that.fraction,
        };

        plus(this, negated)
    }
}

const TOKEN_NAME_HASH_LENGTH: u8 = 32;
type TokenNameHash = [u8; TOKEN_NAME_HASH_LENGTH];

//The representation of class net.corda.core.contracts.Amount in zinc. However, zinc does not support
//generics, thus to maintain it to some extend we use the hash of class name.
//
//Description of struct properties:
//quantity - number of tokens
//display_token_size - number of units stored in token
//token_name_hash - hash of class name of token, used to distinguish tokens only
//
//For more information about struct properties, please, refer to class net.corda.core.contracts.Amount.
struct Amount {
    quantity: i64,
    display_token_size: BigDecimal,
    token_name_hash: TokenNameHash,
}

impl Amount {
    fn _compare_token_name_hashes(
        this_token_hash: TokenNameHash,
        that_token_hash: TokenNameHash,
    ) -> bool {
        let mut result = true;
        for i in 0..TOKEN_NAME_HASH_LENGTH {
            if this_token_hash[i] != that_token_hash[i] {
                result = result && false;
            }
        }
        result
    }

    fn _check_token(this: Amount, that: Amount) {
        assert!(
            BigDecimal::equals(this.display_token_size, that.display_token_size),
            "Token sizes don't match"
        );
        assert!(
            Amount::_compare_token_name_hashes(this.token_name_hash, that.token_name_hash),
            "Tokens don't match"
        );
    }

    fn plus(this: Amount, that: Amount) -> Amount {
        _check_token(this, that);
        Amount {
            quantity: this.quantity + that.quantity,
            display_token_size: this.display_token_size,
            token_name_hash: this.token_name_hash,
        }
    }

    fn minus(this: Amount, that: Amount) -> Amount {
        _check_token(this, that);
        Amount {
            quantity: this.quantity - that.quantity,
            display_token_size: this.display_token_size,
            token_name_hash: this.token_name_hash,
        }
    }

    fn equals(this: Amount, that: Amount) -> bool {
        this.quantity == that.quantity
            && Amount::_compare_token_name_hashes(this.token_name_hash, that.token_name_hash)
            && BigDecimal::equals(this.display_token_size, that.display_token_size)
    }
}
//! OUT ==== /Users/EU88FH/Developer/corda-zkp/zk-notary/prover/modules/shared/floating_point_24_6.zn

//!  IN ==== /Users/EU88FH/Developer/corda-zkp/zk-notary/prover/modules/shared/floating_point_100_20.zn
//In case if value can't be stored in BigDecimal, it will throw an exception,
//the some goes for arithmetic operations.
const INTEGER_SIZE: u8 = 100;
const FRACTION_SIZE: u8 = 20;

//Original BigDecimal in Java stores all digits in one array, and uses scale as a number of digits to the right side of
//the decimal point. Then it calculates the difference in scale of two comparing BigDecimals to adjust digits.
//For example:
//1.2, which is an array of [1, 2] and scale 1, plus 10, which is an array [1, 0], but scale 0.
//So, arrays must be adjusted w.r.t. scales, such that the digits of the same significance have the same index. Then arithmetic operations can be applied.
//
//However, zinc doesn't support indexes inferred from witnesses, so it is impossible to adjust arrays in the same way (i + scale_A - scale_B), so we use two separate arrays to
//store integer value of BigDecimal and its fraction. It is stored in little-Endian order.
//
//Description of struct properties:
//sign - sign of stored variable, belongs to {-1, 0, 1}
//integer - decimal representation of integer part of stored value, can contain only 1024 digits
//fraction - decimal representation of fraction part of stored value, can contain only 128 digits
struct BigDecimal {
    sign: i8,
    integer: [u8; INTEGER_SIZE],
    fraction: [u8; FRACTION_SIZE],
}

impl BigDecimal {
    //comparison if the same sign
    fn _compare_magnitude(this: BigDecimal, that: BigDecimal) -> i8 {
        let mut result: i8 = 0 as i8;
        for i in 0..INTEGER_SIZE {
            if result == 0 as i8 {
                result = if this.integer[i] > that.integer[i] {
                    1 as i8
                } else {
                    if this.integer[i] < that.integer[i] {
                        -1
                    } else {
                        0 as i8
                    }
                };
            }
        }

        if result == 0 as i8 {
            for i in 0..FRACTION_SIZE {
                if result == 0 as i8 {
                    result = if this.fraction[i] > that.fraction[i] {
                        1 as i8
                    } else {
                        if this.fraction[i] < that.fraction[i] {
                            -1
                        } else {
                            0 as i8
                        }
                    };
                }
            }
            result
        } else {
            result
        }
    }

    //We compare signs, then if they're different (one of inputs is negative or zero), there's no need to compare magnitude.
    //Otherwise, we compare magnitude and provide result w.r.t. to the sign (if it's negative, then magnitude of the first
    //input can be less, but first argument still will be bigger).
    fn compare(this: BigDecimal, that: BigDecimal) -> i8 {
        if this.sign == that.sign {
            if this.sign == 0 as i8 {
                0 as i8
            } else {
                this.sign * _compare_magnitude(this, that)
            }
        } else {
            if this.sign > that.sign {
                1 as i8
            } else {
                -1
            }
        }
    }

    fn equals(this: BigDecimal, that: BigDecimal) -> bool {
        this.sign == that.sign && BigDecimal::_compare_magnitude(this, that) == 0 as i8
    }

    fn _sum_magnitude(this: BigDecimal, that: BigDecimal) -> BigDecimal {
        let mut fraction: [u8; FRACTION_SIZE] = [0; FRACTION_SIZE];
        let mut diff = 0;

        for i in 0..FRACTION_SIZE {
            let value =
                this.fraction[FRACTION_SIZE - i - 1] + that.fraction[FRACTION_SIZE - i - 1] + diff;
            if value >= 10 {
                diff = 1;
                fraction[FRACTION_SIZE - i - 1] = value - 10;
            } else {
                diff = 0;
                fraction[FRACTION_SIZE - i - 1] = value;
            }
        }

        let mut integer: [u8; INTEGER_SIZE] = [0; INTEGER_SIZE];
        for i in 0..INTEGER_SIZE {
            let value =
                this.integer[INTEGER_SIZE - i - 1] + that.integer[INTEGER_SIZE - i - 1] + diff;
            if value >= 10 {
                diff = 1;
                integer[INTEGER_SIZE - i - 1] = value - 10;
            } else {
                diff = 0;
                integer[INTEGER_SIZE - i - 1] = value;
            }
        }

        assert!(diff != 1, "Magnitude exceeds the maximum stored value");

        BigDecimal {
            sign: this.sign,
            integer: integer,
            fraction: fraction,
        }
    }

    //this >= that, but this[i] is not necessarily >= that[i]
    fn _subtract_magnitude(this: BigDecimal, that: BigDecimal) -> BigDecimal {
        let mut fraction: [u8; FRACTION_SIZE] = [0; FRACTION_SIZE];
        let mut diff = 0;
        for i in 0..FRACTION_SIZE {
            let value = this.fraction[FRACTION_SIZE - i - 1] as i8
                - that.fraction[FRACTION_SIZE - i - 1] as i8
                - diff as i8;
            if value < 0 as i8 {
                diff = 1;
                fraction[FRACTION_SIZE - i - 1] = (10 as i8 + value) as u8;
            } else {
                diff = 0;
                fraction[FRACTION_SIZE - i - 1] = value as u8;
            }
        }

        let mut integer: [u8; INTEGER_SIZE] = [0; INTEGER_SIZE];
        for i in 0..INTEGER_SIZE {
            let value = this.integer[INTEGER_SIZE - i - 1] as i8
                - that.integer[INTEGER_SIZE - i - 1] as i8
                - diff as i8;
            if value < 0 as i8 {
                diff = 1;
                integer[INTEGER_SIZE - i - 1] = (10 as i8 + value) as u8;
            } else {
                diff = 0;
                integer[INTEGER_SIZE - i - 1] = value as u8;
            }
        }

        let sign = if diff == 1 { -1 } else { 1 as i8 };

        BigDecimal {
            sign: sign,
            integer: integer,
            fraction: fraction,
        }
    }

    fn _handle_different_signs(this: BigDecimal, that: BigDecimal) -> BigDecimal {
        let comparison = _compare_magnitude(this, that);
        if comparison == 0 as i8 {
            BigDecimal {
                sign: 0 as i8,
                integer: [0; INTEGER_SIZE],
                fraction: [0; FRACTION_SIZE],
            }
        } else {
            let absolute_diff = if comparison == 1 as i8 {
                _subtract_magnitude(this, that)
            } else {
                _subtract_magnitude(that, this)
            };
            BigDecimal {
                sign: comparison * this.sign,
                integer: absolute_diff.integer,
                fraction: absolute_diff.fraction,
            }
        }
    }

    fn _handle_same_sign(this: BigDecimal, that: BigDecimal) -> BigDecimal {
        if that.sign == 0 as i8 {
            BigDecimal {
                sign: 0 as i8,
                integer: [0; INTEGER_SIZE],
                fraction: [0; FRACTION_SIZE],
            }
        } else {
            _sum_magnitude(this, that)
        }
    }

    fn plus(this: BigDecimal, that: BigDecimal) -> BigDecimal {
        if this.sign == 0 as i8 {
            that
        } else {
            if that.sign == 0 as i8 {
                this
            } else {
                if this.sign == that.sign {
                    _handle_same_sign(this, that)
                } else {
                    _handle_different_signs(this, that)
                }
            }
        }
    }

    fn minus(this: BigDecimal, that: BigDecimal) -> BigDecimal {
        let negated = BigDecimal {
            sign: -that.sign,
            integer: that.integer,
            fraction: that.fraction,
        };

        plus(this, negated)
    }
}

const TOKEN_NAME_HASH_LENGTH: u8 = 32;
type TokenNameHash = [u8; TOKEN_NAME_HASH_LENGTH];

//The representation of class net.corda.core.contracts.Amount in zinc. However, zinc does not support
//generics, thus to maintain it to some extend we use the hash of class name.
//
//Description of struct properties:
//quantity - number of tokens
//display_token_size - number of units stored in token
//token_name_hash - hash of class name of token, used to distinguish tokens only
//
//For more information about struct properties, please, refer to class net.corda.core.contracts.Amount.
struct Amount {
    quantity: i64,
    display_token_size: BigDecimal,
    token_name_hash: TokenNameHash,
}

impl Amount {
    fn _compare_token_name_hashes(
        this_token_hash: TokenNameHash,
        that_token_hash: TokenNameHash,
    ) -> bool {
        let mut result = true;
        for i in 0..TOKEN_NAME_HASH_LENGTH {
            if this_token_hash[i] != that_token_hash[i] {
                result = result && false;
            }
        }
        result
    }

    fn _check_token(this: Amount, that: Amount) {
        assert!(
            BigDecimal::equals(this.display_token_size, that.display_token_size),
            "Token sizes don't match"
        );
        assert!(
            Amount::_compare_token_name_hashes(this.token_name_hash, that.token_name_hash),
            "Tokens don't match"
        );
    }

    fn plus(this: Amount, that: Amount) -> Amount {
        _check_token(this, that);
        Amount {
            quantity: this.quantity + that.quantity,
            display_token_size: this.display_token_size,
            token_name_hash: this.token_name_hash,
        }
    }

    fn minus(this: Amount, that: Amount) -> Amount {
        _check_token(this, that);
        Amount {
            quantity: this.quantity - that.quantity,
            display_token_size: this.display_token_size,
            token_name_hash: this.token_name_hash,
        }
    }

    fn equals(this: Amount, that: Amount) -> bool {
        this.quantity == that.quantity
            && Amount::_compare_token_name_hashes(this.token_name_hash, that.token_name_hash)
            && BigDecimal::equals(this.display_token_size, that.display_token_size)
    }
}
//! OUT ==== /Users/EU88FH/Developer/corda-zkp/zk-notary/prover/modules/shared/floating_point_100_20.zn

//!  IN ==== /Users/EU88FH/Developer/corda-zkp/zk-notary/prover/modules/shared/utils/preamble.zn
use std::array::truncate;

use std::crypto::blake2s;
use std::crypto::pedersen;

use std::convert::from_bits_field;
use std::convert::from_bits_unsigned;

use std::convert::to_bits;
//! OUT ==== /Users/EU88FH/Developer/corda-zkp/zk-notary/prover/modules/shared/utils/preamble.zn

//!  IN ==== /Users/EU88FH/Developer/corda-zkp/zk-notary/prover/modules/shared/utils/consts.zn
const BYTE_BITS: u16 = 8;

const U32_BYTES: u16 = 4;
const U32_BITS: u16 = U32_BYTES * BYTE_BITS;

const U128_BYTES: u16 = 16;
const U128_BITS: u16 = U128_BYTES * BYTE_BITS;

const BLAKE2S_DIGEST_BYTES: u16 = 32;

const COMPONENT_GROUP_LEAF_DIGEST_BYTES: u16 = BLAKE2S_DIGEST_BYTES;
const COMPONENT_GROUP_LEAF_DIGEST_BITS: u16 = COMPONENT_GROUP_LEAF_DIGEST_BYTES * BYTE_BITS;

const PEDERSEN_DIGEST_BYTES: u16 = 32;

const NODE_DIGEST_BYTES: u16 = PEDERSEN_DIGEST_BYTES;
const NODE_DIGEST_BITS: u16 = NODE_DIGEST_BYTES * BYTE_BITS;

const COMPONENT_GROUPS_SIZE: u16 = 9;
//! OUT ==== /Users/EU88FH/Developer/corda-zkp/zk-notary/prover/modules/shared/utils/consts.zn

//!  IN ==== /Users/EU88FH/Developer/corda-zkp/zk-notary/prover/modules/move/utils/consts.zn
//!
//! Sizes of Corda's component groups are fixed to the below values.
//! Corda must produce witness such it contains the expected number of components
//! in each group.
//! See definition of ZKCommandData on the Corda side.
//!
const ATTACHMENT_GROUP_SIZE: u16 = 2;
const COMMAND_GROUP_SIZE: u16 = 1;
const INPUT_GROUP_SIZE: u16 = 2;
const OUTPUT_GROUP_SIZE: u16 = 2;
const REFERENCE_GROUP_SIZE: u16 = 2;
const SIGNER_GROUP_SIZE: u16 = 2;
//! OUT ==== /Users/EU88FH/Developer/corda-zkp/zk-notary/prover/modules/move/utils/consts.zn

//!  IN ==== /Users/EU88FH/Developer/corda-zkp/zk-notary/prover/modules/shared/component_group_enum.zn
enum ComponentGroupEnum {
    INPUTS_GROUP = 0,
    OUTPUTS_GROUP = 1,
    COMMANDS_GROUP = 2,
    ATTACHMENTS_GROUP = 3,
    NOTARY_GROUP = 4,
    TIMEWINDOW_GROUP = 5,
    SIGNERS_GROUP = 6,
    REFERENCES_GROUP = 7,
    PARAMETERS_GROUP = 8,
}
//! OUT ==== /Users/EU88FH/Developer/corda-zkp/zk-notary/prover/modules/shared/component_group_enum.zn

//!  IN ==== /Users/EU88FH/Developer/corda-zkp/zk-notary/prover/modules/shared/crypto/privacy_salt.zn
const PRIVACY_SALT_BYTES: u16 = 32;

const PRIVACY_SALT_BITS: u16 = PRIVACY_SALT_BYTES * BYTE_BITS;

type PrivacySaltBytes = [u8; PRIVACY_SALT_BYTES];
type PrivacySaltBits = [bool; PRIVACY_SALT_BITS];

struct PrivacySalt {
    bytes: PrivacySaltBytes,
}

impl PrivacySalt {
    fn from_bytes_to_bits(this: PrivacySalt) -> PrivacySaltBits {
        let mut bits = [false; PRIVACY_SALT_BITS];

        for i in (0 as u16)..PRIVACY_SALT_BYTES {
            let byte_bits = to_bits(this.bytes[i]);
            for j in (0 as u16)..BYTE_BITS {
                bits[BYTE_BITS * i + j] = byte_bits[j];
            }
        }
        bits
    }
}
//! OUT ==== /Users/EU88FH/Developer/corda-zkp/zk-notary/prover/modules/shared/crypto/privacy_salt.zn

//!  IN ==== /Users/EU88FH/Developer/corda-zkp/zk-notary/prover/modules/shared/dto/component_group_leaf_digest_dto.zn
///Struct ComponentGroupLeafDigestDto is only used for input/output reading and writing purposes.
///In internal computations, the circuit only uses ComponentGroupLeafDigestBits type.
///
type ComponentGroupLeafDigestBytes = [u8; COMPONENT_GROUP_LEAF_DIGEST_BYTES];
type ComponentGroupLeafDigestBits = [bool; COMPONENT_GROUP_LEAF_DIGEST_BITS];

struct ComponentGroupLeafDigestDto {
    bytes: ComponentGroupLeafDigestBytes,
}

impl ComponentGroupLeafDigestDto {
    fn from_bytes_to_bits(this: ComponentGroupLeafDigestDto) -> ComponentGroupLeafDigestBits {
        let mut bits = [false; COMPONENT_GROUP_LEAF_DIGEST_BITS];

        for i in (0 as u16)..COMPONENT_GROUP_LEAF_DIGEST_BYTES {
            let byte_bits = to_bits(this.bytes[i]);
            for j in (0 as u16)..BYTE_BITS {
                bits[BYTE_BITS * i + j] = byte_bits[j];
            }
        }
        bits
    }

    fn from_bits_to_bytes(bits: ComponentGroupLeafDigestBits) -> ComponentGroupLeafDigestDto {
        let mut bytes = [0 as u8; COMPONENT_GROUP_LEAF_DIGEST_BYTES];

        for i in 0..COMPONENT_GROUP_LEAF_DIGEST_BYTES {
            let mut byte_bits = [false; BYTE_BITS];
            for j in 0..BYTE_BITS {
                byte_bits[j] = bits[BYTE_BITS * i + j];
            }
            bytes[i] = from_bits_unsigned(byte_bits);
        }
        ComponentGroupLeafDigestDto { bytes: bytes }
    }
}
//! OUT ==== /Users/EU88FH/Developer/corda-zkp/zk-notary/prover/modules/shared/dto/component_group_leaf_digest_dto.zn

//!  IN ==== /Users/EU88FH/Developer/corda-zkp/zk-notary/prover/modules/shared/dto/node_digest_dto.zn
///Struct NodeDigestDto is only used for input/output reading and writing purposes.
///In internal computations, the circuit only uses NodeDigestBits type.

type NodeDigestBytes = [u8; NODE_DIGEST_BYTES];
type NodeDigestBits = [bool; NODE_DIGEST_BITS];

struct NodeDigestDto {
    bytes: NodeDigestBytes,
}

impl NodeDigestDto {
    fn from_bytes_to_bits(this: NodeDigestDto) -> NodeDigestBits {
        let mut bits = [false; NODE_DIGEST_BITS];

        for i in (0 as u16)..NODE_DIGEST_BYTES {
            let byte_bits = to_bits(this.bytes[i]);
            for j in (0 as u16)..BYTE_BITS {
                bits[BYTE_BITS * i + j] = byte_bits[j];
            }
        }
        bits
    }

    fn from_bits_to_bytes(bits: NodeDigestBits) -> NodeDigestDto {
        let mut bytes = [0 as u8; NODE_DIGEST_BYTES];

        for i in 0..NODE_DIGEST_BYTES {
            let mut byte_bits = [false; BYTE_BITS];
            for j in 0..BYTE_BITS {
                byte_bits[j] = bits[BYTE_BITS * i + j];
            }
            bytes[i] = from_bits_unsigned(byte_bits);
        }
        NodeDigestDto { bytes: bytes }
    }
}
//! OUT ==== /Users/EU88FH/Developer/corda-zkp/zk-notary/prover/modules/shared/dto/node_digest_dto.zn

//!  IN ==== /Users/EU88FH/Developer/corda-zkp/zk-notary/prover/modules/shared/dto/nonce_digest_dto.zn
///Struct NonceDigestDto is only used for input/output reading and writing purposes.
///In internal computations, the circuit only uses NonceDigestBits type.

const NONCE_DIGEST_BYTES: u16 = COMPONENT_GROUP_LEAF_DIGEST_BYTES;
const NONCE_DIGEST_BITS: u16 = COMPONENT_GROUP_LEAF_DIGEST_BITS;

type NonceDigestBytes = [u8; NONCE_DIGEST_BYTES];
type NonceDigestBits = [bool; NONCE_DIGEST_BITS];

struct NonceDigestDto {
    bytes: NonceDigestBytes,
}

impl NonceDigestDto {
    fn from_bytes_to_bits(this: NonceDigestDto) -> NonceDigestBits {
        let mut bits = [false; NONCE_DIGEST_BITS];

        for i in (0 as u16)..NONCE_DIGEST_BYTES {
            let byte_bits = to_bits(this.bytes[i]);
            for j in (0 as u16)..BYTE_BITS {
                bits[BYTE_BITS * i + j] = byte_bits[j];
            }
        }
        bits
    }

    fn from_bits_to_bytes(bits: NonceDigestBits) -> NonceDigestDto {
        let mut bytes = [0 as u8; NONCE_DIGEST_BYTES];

        for i in 0..NONCE_DIGEST_BYTES {
            let mut byte_bits = [false; BYTE_BITS];
            for j in 0..BYTE_BITS {
                byte_bits[j] = bits[BYTE_BITS * i + j];
            }
            bytes[i] = from_bits_unsigned(byte_bits);
        }
        NonceDigestDto { bytes: bytes }
    }
}
//! OUT ==== /Users/EU88FH/Developer/corda-zkp/zk-notary/prover/modules/shared/dto/nonce_digest_dto.zn

//!  IN ==== /Users/EU88FH/Developer/corda-zkp/zk-notary/prover/modules/shared/utils/crypto_utils.zn
///Utility functions that are used by cryptographic primitives.

const PEDERSEN_FIELD_BITS: u16 = 254;

// Method to compute a nonce based on privacySalt, component group index and component internal index.
fn compute_nonce(
    privacy_salt: PrivacySaltBits,
    group_index: u32,
    internal_index: u32,
) -> NonceDigestBits {

    let mut nonce = [false; PRIVACY_SALT_BITS + U32_BITS + U32_BITS];
    for i in 0..PRIVACY_SALT_BITS {
        nonce[i] = privacy_salt[i];
    }

    let group_index_bits = to_bits(group_index);
    let internal_index_bits = to_bits(internal_index);

    for i in 0..U32_BITS {
        nonce[PRIVACY_SALT_BITS + (i as u16)] = group_index_bits[i];
        nonce[PRIVACY_SALT_BITS + U32_BITS + (i as u16)] = internal_index_bits[i];
    }

    blake2s(nonce)
}

// Method to pad pedersen digest with zeros to assure 256 bits digest size globally.
fn pedersen_to_padded_bits(digest: field) -> NodeDigestBits {
    let mut digest_bits = [false; NODE_DIGEST_BITS];
    let pedersen_bits = to_bits(digest);

    for i in 0..PEDERSEN_FIELD_BITS {
        digest_bits[(2 as u16) + i] = pedersen_bits[i];
    }

    digest_bits
}

// Method to concatenate two component leaf hash digests.
fn concatenate_component_group_leaf_digests(
    hash1: ComponentGroupLeafDigestBits,
    hash2: ComponentGroupLeafDigestBits,
) -> [bool; COMPONENT_GROUP_LEAF_DIGEST_BITS + COMPONENT_GROUP_LEAF_DIGEST_BITS] {
    let mut data = [false; COMPONENT_GROUP_LEAF_DIGEST_BITS + COMPONENT_GROUP_LEAF_DIGEST_BITS];

    for i in (0 as u16)..COMPONENT_GROUP_LEAF_DIGEST_BITS {
        data[i] = hash1[i];
        data[COMPONENT_GROUP_LEAF_DIGEST_BITS + i] = hash2[i];
    }
    data
}

// Method to concatenate two component node hash digests.
fn concatenate_node_digests(
    hash1: NodeDigestBits,
    hash2: NodeDigestBits,
) -> [bool; NODE_DIGEST_BITS + NODE_DIGEST_BITS] {
    let mut data = [false; NODE_DIGEST_BITS + NODE_DIGEST_BITS];

    for i in (0 as u16)..NODE_DIGEST_BITS {
        data[i] = hash1[i];
        data[NODE_DIGEST_BITS + i] = hash2[i];
    }
    data
}
//! OUT ==== /Users/EU88FH/Developer/corda-zkp/zk-notary/prover/modules/shared/utils/crypto_utils.zn

//!  IN ==== /Users/EU88FH/Developer/corda-zkp/zk-notary/prover/modules/shared/crypto/pub_key.zn
const PUBKEY_BYTES: u16 = 44;

const PUBKEY_FINGERPRINT_BYTES: u16 = 44;
const PUBKEY_FINGERPRINT_BITS: u16 = PUBKEY_FINGERPRINT_BYTES * BYTE_BITS;

type PubKeyBytes = [u8; PUBKEY_BYTES];
type PubKeyFingerprintBits = [bool; PUBKEY_FINGERPRINT_BITS];

struct PubKey {
    bytes: PubKeyBytes,
}

impl PubKey {
    fn fingerprint(this: PubKey) -> PubKeyFingerprintBits {
        let mut fingerprint_bits = [false; PUBKEY_FINGERPRINT_BITS];

        for i in (0 as u16)..PUBKEY_FINGERPRINT_BYTES {
            let bits = to_bits(this.bytes[i]);
            for j in (0 as u16)..BYTE_BITS {
                fingerprint_bits[BYTE_BITS * i + j] = bits[j];
            }
        }
        fingerprint_bits
    }

    // Method to compute leaf hash on public key values.
    fn compute_leaf_hash(
        this: PubKey,
        privacy_salt: PrivacySaltBits,
        group_index: u32,
        internal_index: u32,
    ) -> ComponentGroupLeafDigestBits {
        //fingerprint
        let fingerprint_pub_key = fingerprint(this);

        //compute nonce
        let mut nonce = compute_nonce(privacy_salt, group_index, internal_index);
        let mut message = [false; NONCE_DIGEST_BITS + PUBKEY_FINGERPRINT_BITS];

        //message = nonce || signature
        for i in 0..NONCE_DIGEST_BITS {
            message[i] = nonce[i];
        }

        for i in 0..PUBKEY_FINGERPRINT_BITS {
            message[NONCE_DIGEST_BITS + i] = fingerprint_pub_key[i];
        }

        blake2s(message)
    }
}
//! OUT ==== /Users/EU88FH/Developer/corda-zkp/zk-notary/prover/modules/shared/crypto/pub_key.zn

//!  IN ==== /Users/EU88FH/Developer/corda-zkp/zk-notary/prover/modules/shared/utils/merkle_utils.zn
//! GENERATED CODE. DO NOT EDIT
//! Edit it in prover/build.gradle.kts

//! Merkle tree construction for NodeDigestBits
fn get_merkle_tree_from_2_node_digests(leaves: [NodeDigestBits; 2]) -> NodeDigestBits {
    pedersen_to_padded_bits(pedersen(concatenate_node_digests(leaves[0], leaves[1])).0)
}

fn get_merkle_tree_from_4_node_digests(leaves: [NodeDigestBits; 4]) -> NodeDigestBits {
    let mut new_leaves = [[false; NODE_DIGEST_BITS]; 2];
    for i in 0..2 {
        new_leaves[i] = pedersen_to_padded_bits(
            pedersen(concatenate_node_digests(leaves[2 * i], leaves[2 * i + 1])).0,
        );
    }
    get_merkle_tree_from_2_node_digests(new_leaves)
}

fn get_merkle_tree_from_8_node_digests(leaves: [NodeDigestBits; 8]) -> NodeDigestBits {
    let mut new_leaves = [[false; NODE_DIGEST_BITS]; 4];
    for i in 0..4 {
        new_leaves[i] = pedersen_to_padded_bits(
            pedersen(concatenate_node_digests(leaves[2 * i], leaves[2 * i + 1])).0,
        );
    }
    get_merkle_tree_from_4_node_digests(new_leaves)
}

fn get_merkle_tree_from_16_node_digests(leaves: [NodeDigestBits; 16]) -> NodeDigestBits {
    let mut new_leaves = [[false; NODE_DIGEST_BITS]; 8];
    for i in 0..8 {
        new_leaves[i] = pedersen_to_padded_bits(
            pedersen(concatenate_node_digests(leaves[2 * i], leaves[2 * i + 1])).0,
        );
    }
    get_merkle_tree_from_8_node_digests(new_leaves)
}

/// Merkle tree construction for ComponentGroupLeafDigestBits.
/// Use it only for the computation of a component sub-Merkle tree from component group leaf hashes.
fn get_merkle_tree_from_2_component_group_leaf_digests(
    leaves: [ComponentGroupLeafDigestBits; 2],
) -> NodeDigestBits {
    pedersen_to_padded_bits(
        pedersen(concatenate_component_group_leaf_digests(
            leaves[0], leaves[1],
        ))
        .0,
    )
}

fn get_merkle_tree_from_4_component_group_leaf_digests(
    leaves: [ComponentGroupLeafDigestBits; 4],
) -> NodeDigestBits {
    let mut new_leaves = [[false; NODE_DIGEST_BITS]; 2];
    for i in 0..2 {
        new_leaves[i] = pedersen_to_padded_bits(
            pedersen(concatenate_component_group_leaf_digests(
                leaves[2 * i],
                leaves[2 * i + 1],
            ))
            .0,
        );
    }
    get_merkle_tree_from_2_node_digests(new_leaves)
}

fn get_merkle_tree_from_8_component_group_leaf_digests(
    leaves: [ComponentGroupLeafDigestBits; 8],
) -> NodeDigestBits {
    let mut new_leaves = [[false; NODE_DIGEST_BITS]; 4];
    for i in 0..4 {
        new_leaves[i] = pedersen_to_padded_bits(
            pedersen(concatenate_component_group_leaf_digests(
                leaves[2 * i],
                leaves[2 * i + 1],
            ))
            .0,
        );
    }
    get_merkle_tree_from_4_node_digests(new_leaves)
}

fn get_merkle_tree_from_16_component_group_leaf_digests(
    leaves: [ComponentGroupLeafDigestBits; 16],
) -> NodeDigestBits {
    let mut new_leaves = [[false; NODE_DIGEST_BITS]; 8];
    for i in 0..8 {
        new_leaves[i] = pedersen_to_padded_bits(
            pedersen(concatenate_component_group_leaf_digests(
                leaves[2 * i],
                leaves[2 * i + 1],
            ))
            .0,
        );
    }
    get_merkle_tree_from_8_node_digests(new_leaves)
}
//! OUT ==== /Users/EU88FH/Developer/corda-zkp/zk-notary/prover/modules/shared/utils/merkle_utils.zn

//!  IN ==== /Users/EU88FH/Developer/corda-zkp/zk-notary/prover/modules/shared/state_and_ref.zn
const STATE_BYTES: u16 = PUBKEY_BYTES + U32_BYTES + PUBKEY_BYTES;
const STATE_FINGERPRINT_BYTES: u16 = PUBKEY_BYTES + U32_BYTES + PUBKEY_BYTES;
const STATE_FINGERPRINT_BITS: u16 = STATE_FINGERPRINT_BYTES * BYTE_BITS;

type StateBytes = [u8; STATE_BYTES];
type StateFingerprintBits = [bool; STATE_FINGERPRINT_BITS];

const REF_FINGERPRINT_BYTES: u16 = NODE_DIGEST_BYTES + U32_BYTES;
const REF_FINGERPRINT_BITS: u16 = REF_FINGERPRINT_BYTES * BYTE_BITS;

type RefFingerprintBits = [bool; REF_FINGERPRINT_BITS];

struct Party {
    owning_key: PubKey,
}

// This struct is userland code, and will be generated from Kotlin in the future
struct TestState {
    owner: Party,
    value: i32,
}

//This struct follows the structure in the original Corda TransactionState structure. The fields
// contractCN, encumbrance and constraint are commented out and declared bool intentionally to
// reserve their place in the structure. In the current implementation we don't use these fields,
// if they are going to be included, they should be declared with the corresponding data type.
struct TransactionState {
    data: TestState,
    //contractCN: bool,
    notary: Party,
    //encumbrance: bool,
    //constraint: bool,
}

struct TransactionStatePaddingWrapper {
    content: TransactionState,
    is_filler: bool,
}

struct StateRef {
    txhash: NodeDigestDto,
    index: i32,
}

struct StateAndRef {
    state: TransactionState,
    reference: StateRef,
}

struct StateAndRefPaddingWrapper {
    content: StateAndRef,
    is_filler: bool,
}

impl StateRef {
    fn fingerprint(this: StateRef) -> RefFingerprintBits {
        let mut state_ref_bits = [false; REF_FINGERPRINT_BITS];

        let txhash_fingerprint = NodeDigestDto::from_bytes_to_bits(this.txhash);
        for i in 0..NODE_DIGEST_BITS {
            state_ref_bits[i] = txhash_fingerprint[i];
        }

        let stateref_index_bits = to_bits(this.index);
        for i in 0..U32_BITS {
            state_ref_bits[NODE_DIGEST_BITS + i] = stateref_index_bits[i];
        }
        state_ref_bits
    }

    fn compute_leaf_hash(
        this: StateRef,
        privacy_salt: PrivacySaltBits,
        group_index: u32,
        internal_index: u32,
    ) -> ComponentGroupLeafDigestBits {
        // fingerprint
        let fingerprint_ref = fingerprint(this);

        // compute nonce
        let mut nonce = compute_nonce(privacy_salt, group_index, internal_index);

        // message = nonce || ref
        let mut message = [false; NONCE_DIGEST_BITS + REF_FINGERPRINT_BITS];
        for i in 0..NONCE_DIGEST_BITS {
            message[i] = nonce[i];
        }
        for i in 0..REF_FINGERPRINT_BITS {
            message[NONCE_DIGEST_BITS + i] = fingerprint_ref[i];
        }
        blake2s(message)
    }
}

impl TransactionState {
    fn fingerprint(this: TransactionState) -> [bool; STATE_FINGERPRINT_BITS] {
        let mut result = [false; STATE_FINGERPRINT_BITS];

        // TODO: Separate the fingerprint for the actual ZKContractState our of here.
        // That means that TransactionState.data is asked for its own fingerprint.

        //state_bits = dataOwner_owning_key || value || notary_owning_key
        //dataOwner_owning_key
        result[0..PUBKEY_FINGERPRINT_BITS] = PubKey::fingerprint(this.data.owner.owning_key);
        //value
        result[PUBKEY_FINGERPRINT_BITS..(PUBKEY_FINGERPRINT_BITS + U32_BITS)] =
            to_bits(this.data.value);
        //notary_owning_key
        result[(PUBKEY_FINGERPRINT_BITS + U32_BITS)..STATE_FINGERPRINT_BITS] =
            PubKey::fingerprint(this.notary.owning_key);

        result
    }

    fn compute_leaf_hash(
        this: TransactionState,
        nonce: NonceDigestBits,
    ) -> ComponentGroupLeafDigestBits {
        // message = nonce || state
        let mut message = [false; NONCE_DIGEST_BITS + STATE_FINGERPRINT_BITS];
        for i in 0..NONCE_DIGEST_BITS {
            message[i] = nonce[i];
        }

        let fingerprint_state = fingerprint(this);
        for i in 0..STATE_FINGERPRINT_BITS {
            message[NONCE_DIGEST_BITS + i] = fingerprint_state[i];
        }
        blake2s(message)
    }
}
//! OUT ==== /Users/EU88FH/Developer/corda-zkp/zk-notary/prover/modules/shared/state_and_ref.zn

//!  IN ==== /Users/EU88FH/Developer/corda-zkp/zk-notary/prover/modules/shared/components/inputs.zn
struct InputsComponentGroup {
    components: [StateAndRefPaddingWrapper; INPUT_GROUP_SIZE],
    group_hash: NodeDigestDto,
}

impl InputsComponentGroup {
    fn compute_leaf_hashes(
        this: InputsComponentGroup,
        privacy_salt: PrivacySaltBits,
    ) -> [ComponentGroupLeafDigestBits; INPUT_GROUP_SIZE] {
        let mut component_leaf_hashes =
            [[false; COMPONENT_GROUP_LEAF_DIGEST_BITS]; INPUT_GROUP_SIZE];

        for i in (0 as u32)..(INPUT_GROUP_SIZE as u32) {
            component_leaf_hashes[i] = StateRef::compute_leaf_hash(
                this.components[i].content.reference,
                privacy_salt,
                ComponentGroupEnum::INPUTS_GROUP as u32,
                i as u32,
            );
        }
        component_leaf_hashes
    }

    fn compute_component_group_hash(
        this: InputsComponentGroup,
        privacy_salt: PrivacySaltBits,
    ) -> NodeDigestBits {

        let component_leaf_hashes = compute_leaf_hashes(this, privacy_salt);
        
        get_merkle_tree_from_2_component_group_leaf_digests(component_leaf_hashes)
        
    }
}
//! OUT ==== /Users/EU88FH/Developer/corda-zkp/zk-notary/prover/modules/shared/components/inputs.zn

//!  IN ==== /Users/EU88FH/Developer/corda-zkp/zk-notary/prover/modules/shared/components/outputs.zn
struct OutputsComponentGroup {
    components: [TransactionStatePaddingWrapper; OUTPUT_GROUP_SIZE],
    group_hash: NodeDigestDto,
}

impl OutputsComponentGroup {
    fn compute_leaf_hashes(
        this: OutputsComponentGroup,
        privacy_salt: PrivacySaltBits,
    ) -> [ComponentGroupLeafDigestBits; OUTPUT_GROUP_SIZE] {
        let mut component_leaf_hashes =
            [[false; COMPONENT_GROUP_LEAF_DIGEST_BITS]; OUTPUT_GROUP_SIZE];

        for i in (0 as u32)..(OUTPUT_GROUP_SIZE as u32) {
            component_leaf_hashes[i] = TransactionState::compute_leaf_hash(
                this.components[i].content,
                compute_nonce(
                    privacy_salt,
                    ComponentGroupEnum::OUTPUTS_GROUP as u32,
                    i as u32,
                ),
            );
        }
        component_leaf_hashes
    }

    fn compute_component_group_hash(
        this: OutputsComponentGroup,
        privacy_salt: PrivacySaltBits,
    ) -> NodeDigestBits {

        let component_leaf_hashes = compute_leaf_hashes(this, privacy_salt);
        
        get_merkle_tree_from_2_component_group_leaf_digests(component_leaf_hashes)
        
    }
}
//! OUT ==== /Users/EU88FH/Developer/corda-zkp/zk-notary/prover/modules/shared/components/outputs.zn

//!  IN ==== /Users/EU88FH/Developer/corda-zkp/zk-notary/prover/modules/shared/components/references.zn
struct ReferencesComponentGroup {
    components: [StateAndRefPaddingWrapper; REFERENCE_GROUP_SIZE],
    group_hash: NodeDigestDto,
}

impl ReferencesComponentGroup {
    fn compute_leaf_hashes(
        this: ReferencesComponentGroup,
        privacy_salt: PrivacySaltBits,
    ) -> [ComponentGroupLeafDigestBits; REFERENCE_GROUP_SIZE] {
        let mut component_leaf_hashes =
            [[false; COMPONENT_GROUP_LEAF_DIGEST_BITS]; REFERENCE_GROUP_SIZE];

        for i in (0 as u32)..(REFERENCE_GROUP_SIZE as u32) {
            component_leaf_hashes[i] = StateRef::compute_leaf_hash(
                this.components[i].content.reference,
                privacy_salt,
                ComponentGroupEnum::REFERENCES_GROUP as u32,
                i as u32,
            );
        }
        component_leaf_hashes
    }

    fn compute_component_group_hash(
        this: ReferencesComponentGroup,
        privacy_salt: PrivacySaltBits,
    ) -> NodeDigestBits {

        let component_leaf_hashes = compute_leaf_hashes(this, privacy_salt);
        
        get_merkle_tree_from_2_component_group_leaf_digests(component_leaf_hashes)
        
    }
}
//! OUT ==== /Users/EU88FH/Developer/corda-zkp/zk-notary/prover/modules/shared/components/references.zn

//!  IN ==== /Users/EU88FH/Developer/corda-zkp/zk-notary/prover/modules/shared/components/commands.zn
const COMMAND_FINGERPRINT_BITS: u16 = U32_BITS;

type CommandFingerprintBits = [bool; COMMAND_FINGERPRINT_BITS];

enum CommandData {
    CREATE = 0,
    MOVE = 1,
}

impl CommandData {
    fn fingerprint(this: CommandData) -> CommandFingerprintBits {
        to_bits(this as u32)
    }

    fn compute_leaf_hash(
        this: CommandData,
        privacy_salt: PrivacySaltBits,
        group_index: u32,
        internal_index: u32,
    ) -> ComponentGroupLeafDigestBits {
        //fingerprint
        let fingerprint_command_data = fingerprint(this);

        //compute nonce
        let mut nonce = compute_nonce(privacy_salt, group_index, internal_index);
        let mut message = [false; NONCE_DIGEST_BITS + COMMAND_FINGERPRINT_BITS];

        //message = nonce || command
        for i in 0..NONCE_DIGEST_BITS {
            message[i] = nonce[i];
        }
        for i in 0..COMMAND_FINGERPRINT_BITS {
            message[NONCE_DIGEST_BITS + i] = fingerprint_command_data[i];
        }

        blake2s(message)
    }
}

struct CommandPaddingWrapper {
    content: CommandData,
    is_filler: bool,
}

struct CommandsComponentGroup {
    components: [CommandPaddingWrapper; COMMAND_GROUP_SIZE],
    group_hash: NodeDigestDto,
}

impl CommandsComponentGroup {
    fn compute_leaf_hashes(
        this: CommandsComponentGroup,
        privacy_salt: PrivacySaltBits,
    ) -> [ComponentGroupLeafDigestBits; COMMAND_GROUP_SIZE] {
        let mut component_leaf_hashes =
            [[false; COMPONENT_GROUP_LEAF_DIGEST_BITS]; COMMAND_GROUP_SIZE];

        for i in (0 as u32)..(COMMAND_GROUP_SIZE as u32) {
            component_leaf_hashes[i] = CommandData::compute_leaf_hash(
                this.components[i].content,
                privacy_salt,
                ComponentGroupEnum::COMMANDS_GROUP as u32,
                i as u32,
            );
        }
        component_leaf_hashes
    }

    fn compute_component_group_hash(
        this: CommandsComponentGroup,
        privacy_salt: PrivacySaltBits,
    ) -> NodeDigestBits {

        let component_leaf_hashes = compute_leaf_hashes(this, privacy_salt);
        
        let mut padded_leaves = [[false; COMPONENT_GROUP_LEAF_DIGEST_BITS]; 2];
        for i in 0..1 {
            padded_leaves[i] = component_leaf_hashes[i];
        }
        
        get_merkle_tree_from_2_component_group_leaf_digests(padded_leaves)
        
    }
}
//! OUT ==== /Users/EU88FH/Developer/corda-zkp/zk-notary/prover/modules/shared/components/commands.zn

//!  IN ==== /Users/EU88FH/Developer/corda-zkp/zk-notary/prover/modules/shared/components/attachments.zn
const ATTACHMENT_ID_BYTES: u16 = 32;

const ATTACHMENT_ID_FINGERPRINT_BYTES: u16 = 32;

const ATTACHMENT_ID_FINGERPRINT_BITS: u16 = ATTACHMENT_ID_FINGERPRINT_BYTES * BYTE_BITS;

type AttachmentIdBytes = [u8; ATTACHMENT_ID_BYTES];
type AttachmentIdFingerprintBits = [bool; ATTACHMENT_ID_FINGERPRINT_BITS];

struct AttachmentId {
    bytes: AttachmentIdBytes,
}

impl AttachmentId {
    fn fingerprint(this: AttachmentId) -> AttachmentIdFingerprintBits {
        let mut fingerprint_bits = [false; ATTACHMENT_ID_FINGERPRINT_BITS];

        for i in (0 as u16)..ATTACHMENT_ID_FINGERPRINT_BYTES {
            let bits = to_bits(this.bytes[i]);
            for j in (0 as u16)..BYTE_BITS {
                fingerprint_bits[BYTE_BITS * i + j] = bits[j];
            }
        }
        fingerprint_bits
    }

    // Method to compute leaf hash on public key values.
    fn compute_leaf_hash(
        this: AttachmentId,
        privacy_salt: PrivacySaltBits,
        group_index: u32,
        internal_index: u32,
    ) -> ComponentGroupLeafDigestBits {
        //fingerprint
        let fingerprint_attachment_id = fingerprint(this);

        //compute nonce
        let mut nonce = compute_nonce(privacy_salt, group_index, internal_index);
        let mut message = [false; NONCE_DIGEST_BITS + ATTACHMENT_ID_FINGERPRINT_BITS];

        //message = nonce || signature
        for i in 0..NONCE_DIGEST_BITS {
            message[i] = nonce[i];
        }

        for i in 0..ATTACHMENT_ID_FINGERPRINT_BITS {
            message[NONCE_DIGEST_BITS + i] = fingerprint_attachment_id[i];
        }

        blake2s(message)
    }
}

struct AttachmentPaddingWrapper {
    content: AttachmentId,
    is_filler: bool,
}

struct AttachmentsComponentGroup {
    components: [AttachmentPaddingWrapper; ATTACHMENT_GROUP_SIZE],
    group_hash: NodeDigestDto,
}

impl AttachmentsComponentGroup {
    fn compute_leaf_hashes(
        this: AttachmentsComponentGroup,
        privacy_salt: PrivacySaltBits,
    ) -> [ComponentGroupLeafDigestBits; ATTACHMENT_GROUP_SIZE] {
        let mut component_leaf_hashes =
            [[false; COMPONENT_GROUP_LEAF_DIGEST_BITS]; ATTACHMENT_GROUP_SIZE];

        for i in (0 as u32)..(ATTACHMENT_GROUP_SIZE as u32) {
            component_leaf_hashes[i] = AttachmentId::compute_leaf_hash(
                this.components[i].content,
                privacy_salt,
                ComponentGroupEnum::ATTACHMENTS_GROUP as u32,
                i as u32,
            );
        }

        component_leaf_hashes
    }

    fn compute_component_group_hash(
        this: AttachmentsComponentGroup,
        privacy_salt: PrivacySaltBits,
    ) -> NodeDigestBits {

        let component_leaf_hashes = compute_leaf_hashes(this, privacy_salt);
        
        get_merkle_tree_from_2_component_group_leaf_digests(component_leaf_hashes)
        
    }
}
//! OUT ==== /Users/EU88FH/Developer/corda-zkp/zk-notary/prover/modules/shared/components/attachments.zn

//!  IN ==== /Users/EU88FH/Developer/corda-zkp/zk-notary/prover/modules/shared/components/notary.zn
struct NotaryPaddingWrapper {
    content: Party,
    is_filler: bool,
}

struct NotaryComponentGroup {
    component: NotaryPaddingWrapper,
    group_hash: NodeDigestDto,
}

impl NotaryComponentGroup {
    fn compute_component_group_hash(
        this: NotaryComponentGroup,
        privacy_salt: PrivacySaltBits,
    ) -> NodeDigestBits {
        let component_leaf_hash = PubKey::compute_leaf_hash(
            this.component.content.owning_key,
            privacy_salt,
            ComponentGroupEnum::NOTARY_GROUP as u32,
            0 as u32,
        );

        let mut padded_leaves = [[false; COMPONENT_GROUP_LEAF_DIGEST_BITS]; 2];
        padded_leaves[0] = component_leaf_hash;
        
        get_merkle_tree_from_2_component_group_leaf_digests(padded_leaves)
        
    }
}
//! OUT ==== /Users/EU88FH/Developer/corda-zkp/zk-notary/prover/modules/shared/components/notary.zn

//!  IN ==== /Users/EU88FH/Developer/corda-zkp/zk-notary/prover/modules/shared/components/time_window.zn
const TIME_WINDOW_BYTES: u16 = 24;

const TIME_WINDOW_FINGERPRINT_BYTES: u16 = 24;
const TIME_WINDOW_FINGERPRINT_BITS: u16 = TIME_WINDOW_FINGERPRINT_BYTES * BYTE_BITS;

type TimeWindowBytes = [u8; TIME_WINDOW_BYTES];
type TimeWindowFingerprintBits = [bool; TIME_WINDOW_FINGERPRINT_BITS];

struct TimeWindow {
    bytes: TimeWindowBytes,
}

impl TimeWindow {
    fn fingerprint(this: TimeWindow) -> TimeWindowFingerprintBits {
        let mut fingerprint_bits = [false; TIME_WINDOW_FINGERPRINT_BITS];

        for i in (0 as u16)..TIME_WINDOW_FINGERPRINT_BYTES {
            let bits = to_bits(this.bytes[i]);
            for j in (0 as u16)..BYTE_BITS {
                fingerprint_bits[BYTE_BITS * i + j] = bits[j];
            }
        }
        fingerprint_bits
    }

    fn compute_leaf_hash(
        this: TimeWindow,
        privacy_salt: PrivacySaltBits,
        group_index: u32,
        internal_index: u32,
    ) -> ComponentGroupLeafDigestBits {
        //fingerprint
        let fingerprint_time_window = fingerprint(this);

        //compute nonce
        let mut nonce = compute_nonce(privacy_salt, group_index, internal_index);
        let mut message = [false; NONCE_DIGEST_BITS + TIME_WINDOW_FINGERPRINT_BITS];

        //message = nonce || signature
        for i in 0..NONCE_DIGEST_BITS {
            message[i] = nonce[i];
        }
        for i in 0..TIME_WINDOW_FINGERPRINT_BITS {
            message[NONCE_DIGEST_BITS + i] = fingerprint_time_window[i];
        }

        blake2s(message)
    }
}

struct TimeWindowPaddingWrapper {
    content: TimeWindow,
    is_filler: bool,
}

struct TimeWindowComponentGroup {
    component: TimeWindowPaddingWrapper,
    group_hash: NodeDigestDto,
}

impl TimeWindowComponentGroup {
    fn compute_component_group_hash(
        this: TimeWindowComponentGroup,
        privacy_salt: PrivacySaltBits,
    ) -> NodeDigestBits {
        let component_leaf_hash = TimeWindow::compute_leaf_hash(
            this.component.content,
            privacy_salt,
            ComponentGroupEnum::TIMEWINDOW_GROUP as u32,
            0 as u32,
        );

        let mut padded_leaves = [[false; COMPONENT_GROUP_LEAF_DIGEST_BITS]; 2];
        padded_leaves[0] = component_leaf_hash;
        
        get_merkle_tree_from_2_component_group_leaf_digests(padded_leaves)
        
    }
}
//! OUT ==== /Users/EU88FH/Developer/corda-zkp/zk-notary/prover/modules/shared/components/time_window.zn

//!  IN ==== /Users/EU88FH/Developer/corda-zkp/zk-notary/prover/modules/shared/components/parameters.zn
const PARAMETERS_HASH_BYTES: u16 = 32;

const PARAMETERS_HASH_FINGERPRINT_BYTES: u16 = 32;

const PARAMETERS_HASH_FINGERPRINT_BITS: u16 = PARAMETERS_HASH_FINGERPRINT_BYTES * BYTE_BITS;

type ParametersHashBytes = [u8; PARAMETERS_HASH_BYTES];
type ParametersHashFingerprintBits = [bool; PARAMETERS_HASH_FINGERPRINT_BITS];

struct ParametersHash {
    bytes: ParametersHashBytes,
}

impl ParametersHash {
    fn fingerprint(this: ParametersHash) -> ParametersHashFingerprintBits {
        let mut fingerprint_bits = [false; PARAMETERS_HASH_FINGERPRINT_BITS];

        for i in (0 as u16)..PARAMETERS_HASH_FINGERPRINT_BYTES {
            let bits = to_bits(this.bytes[i]);
            for j in (0 as u16)..BYTE_BITS {
                fingerprint_bits[BYTE_BITS * i + j] = bits[j];
            }
        }
        fingerprint_bits
    }

    // Method to compute leaf hash on public key values.
    fn compute_leaf_hash(
        this: ParametersHash,
        privacy_salt: PrivacySaltBits,
        group_index: u32,
        internal_index: u32,
    ) -> ComponentGroupLeafDigestBits {
        //fingerprint
        let fingerprint_parameters_hash = fingerprint(this);

        //compute nonce
        let mut nonce = compute_nonce(privacy_salt, group_index, internal_index);
        let mut message = [false; NONCE_DIGEST_BITS + PARAMETERS_HASH_FINGERPRINT_BITS];

        //message = nonce || signature
        for i in 0..NONCE_DIGEST_BITS {
            message[i] = nonce[i];
        }

        for i in 0..PARAMETERS_HASH_FINGERPRINT_BITS {
            message[NONCE_DIGEST_BITS + i] = fingerprint_parameters_hash[i];
        }

        blake2s(message)
    }
}

struct ParameterPaddingWrapper {
    content: ParametersHash,
    is_filler: bool,
}

struct ParametersComponentGroup {
    component: ParameterPaddingWrapper,
    group_hash: NodeDigestDto,
}

impl ParametersComponentGroup {
    fn compute_component_group_hash(
        this: ParametersComponentGroup,
        privacy_salt: PrivacySaltBits,
    ) -> NodeDigestBits {
        let component_leaf_hash = ParametersHash::compute_leaf_hash(
            this.component.content,
            privacy_salt,
            ComponentGroupEnum::PARAMETERS_GROUP as u32,
            0 as u32,
        );

        let mut padded_leaves = [[false; COMPONENT_GROUP_LEAF_DIGEST_BITS]; 2];
        padded_leaves[0] = component_leaf_hash;
        
        get_merkle_tree_from_2_component_group_leaf_digests(padded_leaves)
        
    }
}
//! OUT ==== /Users/EU88FH/Developer/corda-zkp/zk-notary/prover/modules/shared/components/parameters.zn

//!  IN ==== /Users/EU88FH/Developer/corda-zkp/zk-notary/prover/modules/shared/components/signers.zn
struct SignerPaddingWrapper {
    content: PubKey,
    is_filler: bool,
}

struct SignersComponentGroup {
    components: [SignerPaddingWrapper; SIGNER_GROUP_SIZE],
    group_hash: NodeDigestDto,
}

impl SignersComponentGroup {
    fn compute_leaf_hashes(
        this: SignersComponentGroup,
        privacy_salt: PrivacySaltBits,
    ) -> [ComponentGroupLeafDigestBits; SIGNER_GROUP_SIZE] {
        let mut component_leaf_hashes =
            [[false; COMPONENT_GROUP_LEAF_DIGEST_BITS]; SIGNER_GROUP_SIZE];

        for i in (0 as u32)..(SIGNER_GROUP_SIZE as u32) {
            component_leaf_hashes[i] = PubKey::compute_leaf_hash(
                this.components[i].content,
                privacy_salt,
                ComponentGroupEnum::SIGNERS_GROUP as u32,
                i as u32,
            );
        }
        component_leaf_hashes
    }

    fn compute_component_group_hash(
        this: SignersComponentGroup,
        privacy_salt: PrivacySaltBits,
    ) -> NodeDigestBits {

        let component_leaf_hashes = compute_leaf_hashes(this, privacy_salt);
        
        get_merkle_tree_from_2_component_group_leaf_digests(component_leaf_hashes)
        
    }
}
//! OUT ==== /Users/EU88FH/Developer/corda-zkp/zk-notary/prover/modules/shared/components/signers.zn

//!  IN ==== /Users/EU88FH/Developer/corda-zkp/zk-notary/prover/modules/shared/zk_prover_transaction.zn
struct ZKProverTransaction {
    inputs: InputsComponentGroup,
    outputs: OutputsComponentGroup,
    references: ReferencesComponentGroup,
    commands: CommandsComponentGroup,
    attachments: AttachmentsComponentGroup,
    notary: NotaryComponentGroup,
    time_window: TimeWindowComponentGroup,
    parameters: ParametersComponentGroup,
    signers: SignersComponentGroup,
    privacy_salt: PrivacySalt,
}

struct Witness {
    transaction: ZKProverTransaction,
    input_nonces: [NonceDigestDto; INPUT_GROUP_SIZE],
    reference_nonces: [NonceDigestDto; REFERENCE_GROUP_SIZE],
}
//! OUT ==== /Users/EU88FH/Developer/corda-zkp/zk-notary/prover/modules/shared/zk_prover_transaction.zn

//!  IN ==== /Users/EU88FH/Developer/corda-zkp/zk-notary/prover/modules/shared/utils/utxo_digests.zn
// Verify that for each input, when calculating the digest of its content with the nonce for the utxo
// it points to as provided in the public input, matches the digest provided in the public input.
// This proves that we did not change the contents of the inputs, compared to
// the VerifierTransaction known by the verifier, of which they were an output.
fn compute_input_utxo_digests(
    inputs: [StateAndRefPaddingWrapper; INPUT_GROUP_SIZE],
    input_nonces: [NonceDigestDto; INPUT_GROUP_SIZE],
) -> [ComponentGroupLeafDigestDto; INPUT_GROUP_SIZE] {
    let mut input_digests = [ComponentGroupLeafDigestDto {
        bytes: [0; COMPONENT_GROUP_LEAF_DIGEST_BYTES],
    }; INPUT_GROUP_SIZE];
    for i in 0..INPUT_GROUP_SIZE {
        input_digests[i] =
            ComponentGroupLeafDigestDto::from_bits_to_bytes(TransactionState::compute_leaf_hash(
                inputs[i].content.state,
                NonceDigestDto::from_bytes_to_bits(input_nonces[i]),
            ));
    }
    input_digests
}

// Verify that for each reference, when calculating the digest of its content with the nonce for the utxo
// it points to as provided in the public input, matches the digest provided in the public input.
// This proves that we did not change the contents of the references, compared to
// the VerifierTransaction known by the verifier, of which they were an output.
fn compute_reference_utxo_digests(
    references: [StateAndRefPaddingWrapper; REFERENCE_GROUP_SIZE],
    reference_nonces: [NonceDigestDto; REFERENCE_GROUP_SIZE],
) -> [ComponentGroupLeafDigestDto; REFERENCE_GROUP_SIZE] {
    let mut reference_digests = [ComponentGroupLeafDigestDto {
        bytes: [0; COMPONENT_GROUP_LEAF_DIGEST_BYTES],
    }; REFERENCE_GROUP_SIZE];
    for i in 0..REFERENCE_GROUP_SIZE {
        reference_digests[i] =
            ComponentGroupLeafDigestDto::from_bits_to_bytes(TransactionState::compute_leaf_hash(
                references[i].content.state,
                NonceDigestDto::from_bytes_to_bits(reference_nonces[i]),
            ));
    }
    reference_digests
}
//! OUT ==== /Users/EU88FH/Developer/corda-zkp/zk-notary/prover/modules/shared/utils/utxo_digests.zn

//!  IN ==== /Users/EU88FH/Developer/corda-zkp/zk-notary/prover/modules/shared/merkle_tree.zn
const MERKLE_TREE_SIZE: u16 = 16;

/// Top-level function to be called.
/// Pads the configure number of leaves to the right amount with zero hashes from the right
/// and calls appropriate tree-constructing procedure
fn merkle_root(leaves: [NodeDigestBits; COMPONENT_GROUPS_SIZE]) -> NodeDigestBits {

    let l = MERKLE_TREE_SIZE - COMPONENT_GROUPS_SIZE;

    let mut full_leaves = [[false; NODE_DIGEST_BITS]; MERKLE_TREE_SIZE];
    for i in 0..COMPONENT_GROUPS_SIZE {
        full_leaves[i] = leaves[i];
    }

    get_merkle_tree_from_16_node_digests(full_leaves)
}

fn build_merkle_tree(zk_prover_transaction: ZKProverTransaction) -> NodeDigestBits {
    // Fingerprint for privacy salt
    let privacy_salt = PrivacySalt::from_bytes_to_bits(zk_prover_transaction.privacy_salt);

    let mut component_group_hashes = [[false; NODE_DIGEST_BITS]; COMPONENT_GROUPS_SIZE];

    component_group_hashes[ComponentGroupEnum::INPUTS_GROUP] =
        InputsComponentGroup::compute_component_group_hash(
            zk_prover_transaction.inputs,
            privacy_salt,
        );
    component_group_hashes[ComponentGroupEnum::OUTPUTS_GROUP] =
        OutputsComponentGroup::compute_component_group_hash(
            zk_prover_transaction.outputs,
            privacy_salt,
        );
    component_group_hashes[ComponentGroupEnum::COMMANDS_GROUP] =
        CommandsComponentGroup::compute_component_group_hash(
            zk_prover_transaction.commands,
            privacy_salt,
        );
    component_group_hashes[ComponentGroupEnum::ATTACHMENTS_GROUP] =
        AttachmentsComponentGroup::compute_component_group_hash(
            zk_prover_transaction.attachments,
            privacy_salt,
        );
    component_group_hashes[ComponentGroupEnum::NOTARY_GROUP] =
        NotaryComponentGroup::compute_component_group_hash(
            zk_prover_transaction.notary,
            privacy_salt,
        );
    component_group_hashes[ComponentGroupEnum::TIMEWINDOW_GROUP] =
        TimeWindowComponentGroup::compute_component_group_hash(
            zk_prover_transaction.time_window,
            privacy_salt,
        );
    component_group_hashes[ComponentGroupEnum::SIGNERS_GROUP] =
        SignersComponentGroup::compute_component_group_hash(
            zk_prover_transaction.signers,
            privacy_salt,
        );
    component_group_hashes[ComponentGroupEnum::REFERENCES_GROUP] =
        ReferencesComponentGroup::compute_component_group_hash(
            zk_prover_transaction.references,
            privacy_salt,
        );
    component_group_hashes[ComponentGroupEnum::PARAMETERS_GROUP] =
        ParametersComponentGroup::compute_component_group_hash(
            zk_prover_transaction.parameters,
            privacy_salt,
        );

    //compute merkle root
    merkle_root(component_group_hashes)
}
//! OUT ==== /Users/EU88FH/Developer/corda-zkp/zk-notary/prover/modules/shared/merkle_tree.zn

//!  IN ==== /Users/EU88FH/Developer/corda-zkp/zk-notary/prover/modules/move/validate/contract_rules.zn
fn check_contract_rules(value: ZKProverTransaction) {
    // Validate the number of commands
    assert!(
        COMMAND_GROUP_SIZE == (1 as u16),
        "Failed requirement: the tx has only one command"
    );

    // Validate the number of outputs
    let mut input_size: u16 = 0;
    for i in 0..INPUT_GROUP_SIZE {
        if !value.inputs.components[i].is_filler {
            input_size = input_size + (1 as u16);
        }
    }

    assert!(
        input_size == (1 as u16),
        "Failed requirement: the tx has only one input"
    );

    // Validate the number of outputs
    let mut output_size: u16 = 0;
    for i in 0..OUTPUT_GROUP_SIZE {
        if !value.outputs.components[i].is_filler {
            output_size = output_size + (1 as u16);
        }
    }

    assert!(
        output_size == (1 as u16),
        "Failed requirement: the tx has only one output"
    );

    // Check if inputs total is equal to outputs total
    let mut input_value_sum: i32 = 0;
    let mut output_value_sum: i32 = 0;

    for i in 0..INPUT_GROUP_SIZE {
        if !value.inputs.components[i].is_filler {
            input_value_sum = input_value_sum + value.inputs.components[i].content.state.data.value;
        }
    }

    for i in 0..OUTPUT_GROUP_SIZE {
        if !value.outputs.components[i].is_filler {
            output_value_sum = output_value_sum + value.outputs.components[i].content.data.value;
        }
    }

    assert!(
        input_value_sum == output_value_sum,
        "Failed requirement: the total value of the inputs and outputs should be equal"
    );
}
//! OUT ==== /Users/EU88FH/Developer/corda-zkp/zk-notary/prover/modules/move/validate/contract_rules.zn

//!  IN ==== /Users/EU88FH/Developer/corda-zkp/zk-notary/prover/modules/move/main.zn
//!
//! The 'move' main module.
//!

struct PublicInput {
    transaction_id: NodeDigestDto,
    input_hashes: [ComponentGroupLeafDigestDto; INPUT_GROUP_SIZE],
    reference_hashes: [ComponentGroupLeafDigestDto; REFERENCE_GROUP_SIZE],
}

fn main(witness: Witness) -> PublicInput {
    // Check contract rules
    check_contract_rules(witness.transaction);

    // Compute the transaction id
    let root_hash = build_merkle_tree(witness.transaction);

    PublicInput {
        transaction_id: NodeDigestDto::from_bits_to_bytes(root_hash),
        input_hashes: compute_input_utxo_digests(
            witness.transaction.inputs.components,
            witness.input_nonces,
        ),
        reference_hashes: compute_reference_utxo_digests(
            witness.transaction.references.components,
            witness.reference_nonces,
        ),
    }
}
//! OUT ==== /Users/EU88FH/Developer/corda-zkp/zk-notary/prover/modules/move/main.zn

