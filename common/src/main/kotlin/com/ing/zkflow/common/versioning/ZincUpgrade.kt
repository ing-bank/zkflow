package com.ing.zkflow.common.versioning

import org.intellij.lang.annotations.Language

/**
 * Annotation specifying the body of a static zinc method on the enclosing type and any additional checks that should happen during upgrade.
 * An example of an important additional check would be specifying the required signers of this upgrade.
 * By default, this does nothing, meaning that anyone can sign an upgrade transaction.
 *
 * The argument name of the Self::new method is derived from the parameter name in the upgrade constructor.
 *
 * Note in addition to the entire CommandContext, which contains the relevant parts of the entire transaction
 * for this circuit, the following two variables are also defined in the upgrade function to make life easier when
 * writing any additional checks:
 * - input (the input ContractState, so in the example below MyTypeV1)
 * - output (the output ContractState, so in the example below MyTypeV2)
 *
 * Example:
 * ```kotlin
 * interface MyType : VersionedContractStateGroup, ContractState
 * @ZKP data class MyTypeV1(val a: Int) : MyType
 * @ZKP data class MyTypeV2(val a: Int, val b: Int) : MyType {
 *     @ZincUpgrade(
 *        /*
 *         * This is the circuit code that should behave identical to the constructor below: it should construct Self from the
 *         * previous version of this class. Fields will be identical to the Kotlin fields, except in snake case instead of camel case.
 *         * To help you determine which fields from Kotlin are mapped to which fields in the ZKP circuit, you can check two files that
 *         * are generated by ZKFlow:
 *         * - The generated ZKP circuit sources for any command that uses this state. These are created during kotlin compilation.
 *         * In this case, have a look at the `IssuePrivate` command in `build/zinc/issue_private/structure/module_outputs_example_token_transaction_component.txt`
 *         * - `src/main/zkp/structure.json`. This file is generated by calling `./gradlew generateZkpStructure`.
 *         */
 *         upgrade = "Self::new(previous_version.a, 0 as i32)",
 *         // This is an additional check we might want to do as part of the smart contract that is generated for the upgrade transaction.
 *         // By default, upgrade smart contracts do nothing in addition to checking that the upgrade succeeds.
 *         // In this case, we want to ensure that a token can only be upgraded if the current owner agrees and signs the upgrade transaction.
 *         additionalChecks = """
 *             assert!(ctx.signers.contains(input.owner.public_key), "Input owner must sign");
 *             """
 *     )
 *     constructor(previousVersion: MyTypeV1) : this(previousVersion.a, 0)
 * }
 * ```
 *
 * ```rust
 * impl MyTypeV2 {
 *     fn upgrade_from(previous_version: MyTypeV1) -> Self {
 *         Self::new(previous_version.a, 0 as i32)
 *     }
 * }
 * ```
 */
@Target(AnnotationTarget.CONSTRUCTOR)
annotation class ZincUpgrade(
    @Language("Rust") val upgrade: String, @Language("Rust") val additionalChecks: String = "")
