package com.ing.zkflow.common.contracts

import com.ing.zkflow.common.zkp.metadata.ResolvedZKCommandMetadata
import net.corda.core.contracts.CommandData
import org.intellij.lang.annotations.Language

/**
 * Upgrade commands are always generated by a compiler plugin.
 * They are unique to an upgrade between two versions of a state.
 * This means that upgrade commands do not need to be versioned, since there will never be changes to them.
 * This interface exists to identify upgrade commands, so that we don't enforce versioning on them.
 */
interface ZKUpgradeCommandData : ZKCommandData

interface ZKCommandData : CommandData {
    val metadata: ResolvedZKCommandMetadata

    /**
     * This function is the verification function for the private transaction components as described in the metadata.
     * It returns a string of valid Zinc code.
     *
     * To determine which types are available in the CommandContext (which contains all secret transaction components) for this command,
     * you can inspect the directory that describes the structure of what is sent to Zinc: `build/zinc/<command_name_in_camel_case>/structure`.
     */
    @Language("Rust")
    fun verifyPrivate(): String = """
            mod module_command_context;
            use module_command_context::CommandContext;
            
            fn verify(ctx: CommandContext) {
                assert!(true != false, "Reality is in an inconsistent state.");
            } 
    """.trimIndent()
}
