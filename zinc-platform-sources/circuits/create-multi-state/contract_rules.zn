mod platform_witness;
mod signers_anonymous_party_ed_dsa;
mod tx_state_test_state1;
mod tx_state_test_state2;

use platform_witness::Witness;
use signers_anonymous_party_ed_dsa::Signers;
use tx_state_test_state1::TxStateTestState1;
use tx_state_test_state2::TxStateTestState2;

fn check_contract_rules(witness: Witness) {
    // public fun verifyCreate(
    //     tx: LedgerTransaction,
    //     command: CommandWithParties<CommandData>
    // ) {
    //     tx.zkFLowMetadata.verify(tx)
    //     // Transaction structure
    //     if (tx.outputs.size != 2) throw IllegalArgumentException("Failed requirement: the tx has exactly two outputs")
    //     if (tx.inputs.isNotEmpty()) throw IllegalArgumentException("Failed requirement: the tx has no inputs")

    //     // Transaction contents
    //     val output1 = tx.getOutput(0) as TestState1
    //     val output2 = tx.getOutput(1) as TestState2
    //     if (output1.owner.owningKey !in command.signers) throw IllegalArgumentException("Failed requirement: the first output state is owned by the command signer")
    //     if (output2.owner.owningKey !in command.signers) throw IllegalArgumentException("Failed requirement: the second output state is owned by the command signer")
    // }

    let signers = Signers::deserialize(witness.signers[0]);
    dbg!("[Create] Signers {}", signers);

    let tx_test_state1 = TxStateTestState1::deserialize(witness.outputs.test_state1[0]);
    dbg!("[Create] TxState_TestState1 {}", tx_test_state1);

    assert!(Signers::contains(signers, tx_test_state1.data.owner), "[Create] Owner must sign");
    dbg!("[Create] Owner signed");

    let tx_test_state2 = TxStateTestState2::deserialize(witness.outputs.test_state2[0]);
    dbg!("[Create] TxState_TestState2 {}", tx_test_state2);

    assert!(Signers::contains(signers, tx_test_state2.data.owner), "[Create] Owner must sign");
    dbg!("[Create] Owner signed");

    dbg!("[Create] Contract rules verified");
}