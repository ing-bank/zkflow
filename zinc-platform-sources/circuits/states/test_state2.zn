mod platform_consts;
mod anonymous_party_ed_dsa;
mod anonymous_party_ed_dsa_collection_2;
mod platform_integer;
mod i32_collection_2;

use platform_consts::U32_BYTES;
use platform_consts::I32_BYTES;
use platform_consts::LIST_LENGTH_PREFIX;
use platform_consts::CORDA_SERDE_MAGIC_LENGTH;
use anonymous_party_ed_dsa::AnonymousPartyEdDSA;
use anonymous_party_ed_dsa::ANONYMOUS_PARTY_ED_DSA_LENGTH;
use anonymous_party_ed_dsa_collection_2::AnonymousPartyEdDSA_Collection_2;
use anonymous_party_ed_dsa_collection_2::ANONYMOUS_PARTY_ED_DSA_COLLECTION_2_LENGTH;

use i32_collection_2::I32_Collection_2;
use i32_collection_2::I32_COLLECTION_2_LENGTH;

// @Serializable
// @BelongsToContract(TestContract::class)
// public data class TestState2(
//     val value: Int = Random().nextInt(1000),
//     @FixedLength([2])
//     val list: List<Int> = listOf()
// ) : ZKContractState {

const STATE_PARTICIPANTS_SIZE: u16 = 2;
const LIST_SIZE: u16 = 2;

//! TestState2 lengths
const OWNER_LENGTH: u16 = ANONYMOUS_PARTY_ED_DSA_LENGTH;
const VALUE_LENGTH: u16 = I32_BYTES;
const LIST_LENGTH: u16 = I32_COLLECTION_2_LENGTH;
const PARTICIPANTS_LENGTH: u16 = ANONYMOUS_PARTY_ED_DSA_COLLECTION_2_LENGTH;


//! TestState2 offsets
const OWNER_OFFSET: u16 = 0;
const VALUE_OFFSET: u16
    = OWNER_OFFSET
    + OWNER_LENGTH;
const LIST_OFFSET: u16
    = VALUE_OFFSET
    + VALUE_LENGTH;
const PARTICIPANTS_OFFSET: u16
    = LIST_OFFSET
    + LIST_LENGTH;
const TEST_STATE2_LENGTH: u16
    = PARTICIPANTS_OFFSET
    + PARTICIPANTS_LENGTH;


struct TestState2 {
    value : i32,
    list:  I32_Collection_2,
    participants: AnonymousPartyEdDSA_Collection_2,
}

type SerializedTestState2 = [u8; TEST_STATE2_LENGTH];

impl TestState2 {
    fn deserialize(serialized: SerializedTestState2) -> TestState2 {
        let owner = {
            let mut owner_bytes = [0; ANONYMOUS_PARTY_ED_DSA_LENGTH];
            for i in 0..ANONYMOUS_PARTY_ED_DSA_LENGTH {
                owner_bytes[i] = serialized[i + OWNER_OFFSET];
            }
            AnonymousPartyEdDSA::deserialize(owner_bytes)
        };
        dbg!("[Create] Owner = {}", owner);

        let value = {
            let mut value_bytes = [0; I32_BYTES];
            for i in 0..VALUE_LENGTH {
                value_bytes[i] = serialized[i + VALUE_OFFSET];
            }
            platform_integer::parse_i32(value_bytes)
        };
        dbg!("[Create] Value = {}", value);

        let list = {
            let mut list_bytes = [0; LIST_LENGTH];
            for i in 0..LIST_LENGTH {
                list_bytes[i] = serialized[i + LIST_OFFSET];
            }
            I32_Collection_2::deserialize(list_bytes)
        };
        dbg!("[Create] List = {}", list);

        let participants = {
            let mut participants_bytes = [0; ANONYMOUS_PARTY_ED_DSA_COLLECTION_2_LENGTH];
            for i in 0..ANONYMOUS_PARTY_ED_DSA_COLLECTION_2_LENGTH {
                participants_bytes[i] = serialized[i + PARTICIPANTS_OFFSET];
            }
            AnonymousPartyEdDSA_Collection_2::deserialize(participants_bytes)
        };
        dbg!("[Create] Participants = {}", participants);

        TestState2 {
            value: value,
            list:  list,
            participants: participants,
        }
    }

    fn equals(this: TestState2, that: TestState2) -> bool {
            this.value == that.value  &&
            I32_Collection_2::equals(this.list, that.list) &&
            AnonymousPartyEdDSA_Collection_2::equals(this.participants, that.participants)
    }
}