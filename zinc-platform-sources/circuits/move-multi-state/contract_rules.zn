mod platform_witness;
mod signers_anonymous_party_ed_dsa;
mod tx_state_test_state1;

use platform_witness::Witness;
use signers_anonymous_party_ed_dsa::Signers;
use tx_state_test_state1::TxStateTestState1;

fn check_contract_rules(witness: Witness) {
    // public fun verifyMove(
    //     tx: LedgerTransaction,
    //     command: CommandWithParties<CommandData>
    // ) {
    //     // Transaction structure
    //     if (tx.outputs.size != 1) throw IllegalArgumentException("Failed requirement: the tx has only one output")
    //     if (tx.inputs.size != 1) throw IllegalArgumentException("Failed requirement: the tx has only one output")
    //
    //     // Transaction contents
    //     val output = tx.getOutput(0) as TestState
    //     val input = tx.getInput(0) as TestState
    //
    //     if (input.owner.owningKey !in command.signers) throw IllegalArgumentException("Failed requirement: the input state is owned by a required command signer")
    //     if (input.value != output.value) throw IllegalArgumentException("Failed requirement: the value of the input and out put should be equal")
    // }

    // Transaction structure is ensured by construction of witness.

    // Transaction contents.
    let input = TxStateTestState1::deserialize(witness.serialized_input_utxos.test_state1[0]);
    let output = TxStateTestState1::deserialize(witness.outputs.test_state1[0]);
    assert!(input.data.value == output.data.value, "[Move] Values of input and output must equal");
    dbg!("[Move] Value of moved value verified");

    let signers = Signers::deserialize(witness.signers[0]);
    dbg!("[Move] Signers {}", signers);

    assert!(Signers::contains(signers, input.data.owner), "[Move] Owner must sign");
    dbg!("[Move] Owner of consumed state signed");


    // assert!(tx_test_state2.data.list.elements[0] == 42 as i32, "[Create] First element of the list should be 42.");

    dbg!("[Move] Contract rules are verified");
}