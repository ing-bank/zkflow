// Hashes expected by Corda must be at most 32 bytes long.
// @FixedLength([32])
// val bytes: ByteArray

mod platform_consts;

use platform_consts::LIST_LENGTH_PREFIX;
use std::convert::to_bits;
use platform_consts::BYTE_BITS;

const _PRIVACY_SALT_LENGTH: u16 = 32;
const PRIVACY_SALT_BITS: u16 = _PRIVACY_SALT_LENGTH * 8 as u16;

type SerializedPrivacySalt = [u8; LIST_LENGTH_PREFIX + _PRIVACY_SALT_LENGTH];

type PrivacySaltBytes = [u8; _PRIVACY_SALT_LENGTH];
type PrivacySaltBits = [bool; PRIVACY_SALT_BITS];

struct PrivacySalt {
    bytes: [u8; _PRIVACY_SALT_LENGTH]
}

impl PrivacySalt {
    fn equals(this: PrivacySalt, that: PrivacySalt) -> bool {
        let mut are_equal = true;
        for i in 0.._PRIVACY_SALT_LENGTH while are_equal {
            are_equal = this.bytes[i] == that.bytes[i];
        }
        are_equal
    }

    fn deserialize(serialized_privacy_salt: SerializedPrivacySalt) -> PrivacySalt {
        let mut bytes = [0 as u8; _PRIVACY_SALT_LENGTH];

        for i in 0.._PRIVACY_SALT_LENGTH {
            bytes[i] = serialized_privacy_salt[LIST_LENGTH_PREFIX + i];
        }

        PrivacySalt {
            bytes: bytes
        }
    }
}

fn from_bytes_to_bits(bytes: PrivacySaltBytes) -> PrivacySaltBits {
    let mut bits = [false; PRIVACY_SALT_BITS];

    for i in (0 as u16).._PRIVACY_SALT_LENGTH {
        let byte_bits = to_bits(bytes[i]);
        for j in (0 as u16)..BYTE_BITS {
            bits[BYTE_BITS * i + j] = byte_bits[j];
        }
    }
    bits
}
