// Hashes expected by Corda must be at most 32 bytes long.
// @FixedLength([32])
// val bytes: ByteArray

mod platform_consts;

use platform_consts::LIST_LENGTH_PREFIX;
use std::convert::from_bits_unsigned;
use platform_consts::BYTE_BITS;

const _PRIVACY_SALT_LENGTH: u16 = 32;
const PRIVACY_SALT_BITS: u16 = _PRIVACY_SALT_LENGTH * 8 as u16;

type SerializedPrivacySalt = [u8; LIST_LENGTH_PREFIX + _PRIVACY_SALT_LENGTH];

type PrivacySaltBytes = [u8; _PRIVACY_SALT_LENGTH];
type PrivacySaltBits = [bool; PRIVACY_SALT_BITS];

struct PrivacySalt {
    bytes: [u8; _PRIVACY_SALT_LENGTH]
}

impl PrivacySalt {
    fn equals(this: PrivacySalt, that: PrivacySalt) -> bool {
        let mut are_equal = true;
        for i in 0.._PRIVACY_SALT_LENGTH while are_equal {
            are_equal = this.bytes[i] == that.bytes[i];
        }
        are_equal
    }

    fn deserialize(serialized_privacy_salt: SerializedPrivacySalt) -> PrivacySalt {
        let mut bytes = [0 as u8; _PRIVACY_SALT_LENGTH];

        for i in 0.._PRIVACY_SALT_LENGTH {
            bytes[i] = serialized_privacy_salt[LIST_LENGTH_PREFIX + i];
        }

        PrivacySalt {
            bytes: bytes
        }
    }
}

fn from_bits_to_bytes(bits: PrivacySaltBits) -> PrivacySaltBytes {
    let mut bytes = [0 as u8; _PRIVACY_SALT_LENGTH];

    for i in (0 as u16).._PRIVACY_SALT_LENGTH {
        let mut byte_bits = [false; BYTE_BITS];
        for j in (0 as u16)..BYTE_BITS {
            byte_bits[j] = bits[i * BYTE_BITS + j];
        }
        bytes[i] = from_bits_unsigned(byte_bits);
    }
    bytes
}