mod amount_8_big_decimal_100_20;

use amount_8_big_decimal_100_20::Amount_8_BigDecimal_100_20;
use amount_8_big_decimal_100_20::SerializedAmount_8_BigDecimal_100_20;
use amount_8_big_decimal_100_20::AMOUNT_8_BIG_DECIMAL_100_20_LENGTH;

const AMOUNTS_LENGTH_LENGTH: u8 = 4;
const AMOUNTS_MAX_LENGTH: u8 = 4;

const WITNESS_LENGTH: u16 =
        AMOUNT_8_BIG_DECIMAL_100_20_LENGTH as u16
      * AMOUNTS_MAX_LENGTH as u16
      + AMOUNTS_LENGTH_LENGTH as u16;

fn get_int(witness: [u8; WITNESS_LENGTH], start_byte: u16) -> u32 {
    let mut result: u32 = 0;
    for i in 0..4 {
        result = result * 256 as u32 + witness[start_byte + i as u16] as u32;
    }
    result
}

fn main(witness: [u8; WITNESS_LENGTH]) -> Amount_8_BigDecimal_100_20 {
    dbg!("Witness length: {}", WITNESS_LENGTH);
    let length = get_int(witness, 0 as u16);
    let mut amounts: [Amount_8_BigDecimal_100_20; AMOUNTS_MAX_LENGTH] = [Amount_8_BigDecimal_100_20::zero(); AMOUNTS_MAX_LENGTH];

    let mut amount_bytes: SerializedAmount_8_BigDecimal_100_20 = [0; AMOUNT_8_BIG_DECIMAL_100_20_LENGTH];
    for i in 0..AMOUNTS_MAX_LENGTH while i as u32 < length {
        let offset: u16 = AMOUNTS_LENGTH_LENGTH as u16 + i as u16 * AMOUNT_8_BIG_DECIMAL_100_20_LENGTH as u16;
        for j in 0..AMOUNT_8_BIG_DECIMAL_100_20_LENGTH {
            amount_bytes[j] = witness[offset + j as u16];
        }
        amounts[i] = Amount_8_BigDecimal_100_20::deserialize(amount_bytes);
    }

    let mut max: Amount_8_BigDecimal_100_20 = amounts[0];
    for i in 1..AMOUNTS_MAX_LENGTH while i as u32 < length {
        Amount_8_BigDecimal_100_20::_check_token(max, amounts[i]);
        if amounts[i].quantity > max.quantity {
            max = amounts[i];
        }
    }

    max
}
