// TODO: This file was never update to work with the latest version
// and makes use of non-existent functions. Commented out for now.
// mod platform_state_and_ref;
// mod consts;
// mod platform_consts;
// mod platform_node_digest_dto;
// mod platform_nonce_digest_dto;
// mod platform_privacy_salt;
// mod platform_component_group_leaf_digest_dto;
// mod platform_component_group_enum;
// mod platform_zk_prover_transaction;
//
// use platform_component_group_enum::ComponentGroupEnum;
// use platform_zk_prover_transaction::ZKProverTransaction;
// use platform_node_digest_dto::NodeDigestDto;
// use platform_nonce_digest_dto::NonceDigestBits;
// use platform_node_digest_dto::NodeDigestBits;
// use platform_node_digest_dto::NODE_DIGEST_BITS;
// use platform_consts::COMPONENT_GROUPS_SIZE;
//
// // Auxiliary method to validate a GroupHash
// // * computed digest that is computed from witness.
// // * received digest that is received within the witness.
// // return bool If the computed value is equal to the one received then the function returns true. Otherwise, returns false.
// fn validate_group_hash(computed: NodeDigestBits, received: NodeDigestBits) -> bool {
//     dbg!("{}", NodeDigestDto::from_bits_to_bytes(computed));
//     dbg!("{}", NodeDigestDto::from_bits_to_bytes(received));
//
//     let mut is_equal = true;
//
//     for i in 0..NODE_DIGEST_BITS {
//         if computed[i] != received[i] {
//             is_equal = false;
//         }
//     }
//     is_equal
// }
//
// // Method to validate group hashes.
// // * component_group_hashes that are computed from the witness ZKProverTransaction.
// // * zk_prover_transaction  that contains component group hashes computed by the prover.
// // If one component_group_hash value cannot be validated then the execution terminates.
// fn validate_group_hashes(
//     component_group_hashes: [NodeDigestBits; COMPONENT_GROUPS_SIZE],
//     zk_prover_transaction: ZKProverTransaction,
// ) {
//     //Validate component hashes
//     dbg!("Comparing Input group");
//     let validate_input = validate_group_hash(
//         component_group_hashes[ComponentGroupEnum::INPUTS_GROUP],
//         fingerprint(zk_prover_transaction.inputs.group_hash),
//     );
//
//     assert!(
//         validate_input,
//         "Failed computation: The computed input group hash does not match the received group hash."
//     );
//     dbg!("");
//
//     dbg!("Comparing Output group");
//     let validate_output = validate_group_hash(
//         component_group_hashes[ComponentGroupEnum::OUTPUTS_GROUP],
//         NodeDigest::fingerprint(zk_prover_transaction.outputs.group_hash),
//     );
//
//     assert!(validate_output, "Failed computation: The computed output group hash does not match the received group hash.");
//     dbg!("");
//
//     dbg!("Comparing Commands group");
//     let validate_command = validate_group_hash(
//         component_group_hashes[ComponentGroupEnum::COMMANDS_GROUP],
//         NodeDigest::fingerprint(zk_prover_transaction.commands.group_hash),
//     );
//
//     assert!(validate_command, "Failed computation: The computed command group hash does not match the received group hash.");
//     dbg!("");
//
//     dbg!("Comparing Attachments group");
//     let validate_attachment = validate_group_hash(
//         component_group_hashes[ComponentGroupEnum::ATTACHMENTS_GROUP],
//         NodeDigest::fingerprint(zk_prover_transaction.attachments.group_hash),
//     );
//
//     assert!(validate_attachment, "Failed computation: The computed attachment group hash does not match the received group hash.");
//     dbg!("");
//
//     dbg!("Comparing Notary group");
//     let validate_notary = validate_group_hash(
//         component_group_hashes[ComponentGroupEnum::NOTARY_GROUP],
//         NodeDigest::fingerprint(zk_prover_transaction.notary.group_hash),
//     );
//
//     assert!(validate_notary, "Failed computation: The computed notary group hash does not match the received group hash.");
//     dbg!("");
//
//     dbg!("Comparing TimeWindow group");
//     let validate_time_window = validate_group_hash(
//         component_group_hashes[ComponentGroupEnum::TIMEWINDOW_GROUP],
//         NodeDigest::fingerprint(zk_prover_transaction.time_window.group_hash),
//     );
//
//     assert!(validate_time_window, "Failed computation: The computed time window group hash does not match the received group hash.");
//     dbg!("");
//
//     dbg!("Comparing Signers group");
//     let validate_signers = validate_group_hash(
//         component_group_hashes[ComponentGroupEnum::SIGNERS_GROUP],
//         NodeDigest::fingerprint(zk_prover_transaction.signers.group_hash),
//     );
//
//     assert!(validate_signers, "Failed computation: The computed signers group hash does not match the received group hash.");
//
//     dbg!("Comparing Reference group");
//     let validate_reference = validate_group_hash(
//         component_group_hashes[ComponentGroupEnum::REFERENCES_GROUP],
//         NodeDigest::fingerprint(zk_prover_transaction.references.group_hash),
//     );
//
//     assert!(validate_reference, "Failed computation: The computed reference group hash does not match the received group hash.");
//     dbg!("");
//
//     dbg!("Comparing Parameters group");
//     let validate_parameters = validate_group_hash(
//         component_group_hashes[ComponentGroupEnum::PARAMETERS_GROUP],
//         NodeDigest::fingerprint(zk_prover_transaction.parameters.group_hash),
//     );
//
//     assert!(validate_parameters, "Failed computation: The computed parameters group hash does not match the received group hash.");
//     dbg!("");
// }
