mod platform_state_and_ref;
mod consts;
mod platform_node_digest_dto;
mod platform_nonce_digest_dto;
mod platform_privacy_salt;
mod platform_component_group_leaf_digest_dto;
mod platform_component_group_enum;
mod platform_components_inputs;
mod platform_components_references;

use consts::INPUT_GROUP_SIZE;
use consts::REFERENCE_GROUP_SIZE;
use platform_component_group_enum::ComponentGroupEnum;
use platform_component_group_leaf_digest_dto::COMPONENT_GROUP_LEAF_DIGEST_BITS;
use platform_component_group_leaf_digest_dto::COMPONENT_GROUP_LEAF_DIGEST_BYTES;
use platform_component_group_leaf_digest_dto::ComponentGroupLeafDigestBits;
use platform_component_group_leaf_digest_dto::ComponentGroupLeafDigestDto;
use platform_components_inputs::SerializedInputGroup;
use platform_components_references::SerializedReferenceGroup;
use platform_node_digest_dto::NODE_DIGEST_BITS;
use platform_node_digest_dto::NodeDigestBits;
use platform_node_digest_dto::NodeDigestDto;
use platform_nonce_digest_dto::NonceDigestDto;
use platform_privacy_salt::PrivacySaltBits;
use platform_state_and_ref::StateAndRefPaddingWrapper;
use platform_state_and_ref::StateRef;
use platform_state_and_ref::TransactionState;

// Verify that for each input, when calculating the digest of its content with the nonce for the utxo
// it points to as provided in the public input, matches the digest provided in the public input.
// This proves that we did not change the contents of the inputs, compared to
// the VerifierTransaction known by the verifier, of which they were an output.
fn compute_input_utxo_digests(
    inputs: SerializedInputGroup,
    input_nonces: [NonceDigestDto; INPUT_GROUP_SIZE],
) -> [ComponentGroupLeafDigestDto; INPUT_GROUP_SIZE] {
    let mut input_digests = [ComponentGroupLeafDigestDto {
        bytes: [0; COMPONENT_GROUP_LEAF_DIGEST_BYTES],
    }; INPUT_GROUP_SIZE];
    for i in 0..INPUT_GROUP_SIZE {
        // TODO: implement this correctly
        // input_digests[i] =
        //     ComponentGroupLeafDigestDto::from_bits_to_bytes(TransactionState::compute_leaf_hash(
        //         inputs[i],
        //         NonceDigestDto::from_bytes_to_bits(input_nonces[i]),
        //     ));
    }
    input_digests
}

// Verify that for each reference, when calculating the digest of its content with the nonce for the utxo
// it points to as provided in the public input, matches the digest provided in the public input.
// This proves that we did not change the contents of the references, compared to
// the VerifierTransaction known by the verifier, of which they were an output.
fn compute_reference_utxo_digests(
    references: SerializedReferenceGroup,
    reference_nonces: [NonceDigestDto; REFERENCE_GROUP_SIZE],
) -> [ComponentGroupLeafDigestDto; REFERENCE_GROUP_SIZE] {
    let mut reference_digests = [ComponentGroupLeafDigestDto {
        bytes: [0; COMPONENT_GROUP_LEAF_DIGEST_BYTES],
    }; REFERENCE_GROUP_SIZE];
    for i in 0..REFERENCE_GROUP_SIZE {
        // TODO: implement this correctly
        // reference_digests[i] =
        // ComponentGroupLeafDigestDto::from_bits_to_bytes(TransactionState::compute_leaf_hash(
        //     references[i],
        //     NonceDigestDto::from_bytes_to_bits(reference_nonces[i]),
        // ));
    }
    reference_digests
}
