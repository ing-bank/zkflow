// Input parameters:
//   - TYPE_NAME: String = name of the collection, e.g. ${INNER_TYPE_NAME}(_)Collection_${FIXED_SIZE}
//   - CONSTANT_PREFIX: String = prefix used for constant names, e.g. ${INNER_CONSTANT_PREFIX}_COLLECTION_${FIXED_SIZE}
//   - INNER_MODULE_NAME: String = module name of the inner struct
//   - INNER_CONSTANT_PREFIX: String = prefix used for constant names of the inner struct
//   - INNER_TYPE_NAME: String = name of the inner struct
//   - FIXED_SIZE: u16 = fixed size of the collection

mod platform_consts;
mod platform_integer;

use platform_consts::${INNER_CONSTANT_PREFIX}_BYTES;

// handled in that way because importing U32_BYTES could create a collision
const ${CONSTANT_PREFIX}_SIZE_LENGTH: u16 = 4 as u16;
const ${CONSTANT_PREFIX}_ELEMENTS_LENGTH: u16 = ${INNER_CONSTANT_PREFIX}_BYTES * ${FIXED_SIZE} as u16;

const ${CONSTANT_PREFIX}_SIZE_OFFSET: u16 = 0;
const ${CONSTANT_PREFIX}_ELEMENTS_OFFSET: u16
    = ${CONSTANT_PREFIX}_SIZE_OFFSET
    + ${CONSTANT_PREFIX}_SIZE_LENGTH;
const ${CONSTANT_PREFIX}_LENGTH: u16
    = ${CONSTANT_PREFIX}_ELEMENTS_OFFSET
    + ${CONSTANT_PREFIX}_ELEMENTS_LENGTH;

type Serialized${TYPE_NAME} = [u8; ${CONSTANT_PREFIX}_LENGTH];

struct ${TYPE_NAME} {
    size: u32,
    elements: [${INNER_MODULE_NAME}; ${FIXED_SIZE}],
}

impl ${TYPE_NAME} {
    fn print_structure() {
        dbg!("[${TYPE_NAME}] LENGTH: {}", ${CONSTANT_PREFIX}_LENGTH);
        dbg!("[${TYPE_NAME}] STRUCTURE");
        dbg!("[${TYPE_NAME}] - SIZE:     {}", ${CONSTANT_PREFIX}_SIZE_LENGTH);
        dbg!("[${TYPE_NAME}] - ELEMENTS: {}", ${CONSTANT_PREFIX}_ELEMENTS_LENGTH);
        dbg!("[${TYPE_NAME}]   - CAPACITY: {}", ${FIXED_SIZE});
        dbg!("[${TYPE_NAME}]   - ELEMENT:  {} (${INNER_MODULE_NAME})", ${INNER_CONSTANT_PREFIX}_BYTES);
        dbg!("[${TYPE_NAME}]");
    }

    fn empty() -> ${TYPE_NAME} {
        ${TYPE_NAME} {
            size: 0 as u32,
            elements: [0 as ${INNER_MODULE_NAME}; ${FIXED_SIZE}],
        }
    }

    fn equals(this: ${TYPE_NAME}, that: ${TYPE_NAME}) -> bool {
        let mut still_equal = this.size == that.size;
        for i in 0..${FIXED_SIZE} while still_equal && i as u32 < this.size {
            still_equal = this.elements[i] == that.elements[i];
        }
        still_equal
    }

    fn contains(this: ${TYPE_NAME}, value: ${INNER_MODULE_NAME}) -> bool {
        let mut found = false;
        for i in 0..${FIXED_SIZE} while !found && i as u32 < this.size {
            found = this.elements[i] == value;
        }
        found
    }

    fn is_subset(this: ${TYPE_NAME}, that: ${TYPE_NAME}) -> bool {
        let mut still_subset = this.size <= that.size;
        for i in 0..${FIXED_SIZE} while still_subset && i as u32 < this.size {
            still_subset = contains(that, this.elements[i]);
        }
        still_subset
    }

    fn deserialize(serialized: Serialized${TYPE_NAME}) -> ${TYPE_NAME} {
        let size = {
            let mut size_bytes = [0; ${CONSTANT_PREFIX}_SIZE_LENGTH];
            for i in 0..${CONSTANT_PREFIX}_SIZE_LENGTH {
                size_bytes[i] = serialized[i + ${CONSTANT_PREFIX}_SIZE_OFFSET];
            }
            platform_integer::parse_u32(size_bytes)
        };

        let elements = {
            let mut element_array = [0 as ${INNER_MODULE_NAME}; ${FIXED_SIZE}];
            let mut element_bytes = [0; ${INNER_CONSTANT_PREFIX}_BYTES];
            for i in 0..${FIXED_SIZE} while i as u32 < size {
                for j in 0..${INNER_CONSTANT_PREFIX}_BYTES {
                    element_bytes[j] = serialized[j + ${CONSTANT_PREFIX}_ELEMENTS_OFFSET + (i as u16) * ${INNER_CONSTANT_PREFIX}_BYTES];
                }
                element_array[i] = platform_integer::parse_${INNER_MODULE_NAME}(element_bytes);
            }
            element_array
        };

        ${TYPE_NAME} {
            size: size,
            elements: elements,
        }
    }
}
