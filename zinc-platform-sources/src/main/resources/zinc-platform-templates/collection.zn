// Input parameters:
//   - TYPE_NAME: String = name of the collection, e.g. ${INNER_TYPE_NAME}(_)Collection_${FIXED_SIZE}
//   - CONSTANT_PREFIX: String = prefix used for constant names, e.g. ${INNER_CONSTANT_PREFIX}_COLLECTION_${FIXED_SIZE}
//   - INNER_MODULE_NAME: String = module name of the inner struct
//   - INNER_CONSTANT_PREFIX: String = prefix used for constant names of the inner struct
//   - INNER_TYPE_NAME: String = name of the inner struct
//   - FIXED_SIZE: u16 = fixed size of the collection

mod platform_consts;
mod platform_integer;
mod ${INNER_MODULE_NAME};

use platform_consts::U32_BYTES;

use ${INNER_MODULE_NAME}::${INNER_TYPE_NAME};
use ${INNER_MODULE_NAME}::${INNER_CONSTANT_PREFIX}_LENGTH;

const ${CONSTANT_PREFIX}_SIZE_LENGTH: u16 = U32_BYTES;
const ${CONSTANT_PREFIX}_ELEMENTS_LENGTH: u16 = ${INNER_CONSTANT_PREFIX}_LENGTH * ${FIXED_SIZE} as u16;

const ${CONSTANT_PREFIX}_SIZE_OFFSET: u16 = 0;
const ${CONSTANT_PREFIX}_ELEMENTS_OFFSET: u16
    = ${CONSTANT_PREFIX}_SIZE_OFFSET
    + ${CONSTANT_PREFIX}_SIZE_LENGTH;
const ${CONSTANT_PREFIX}_LENGTH: u16
    = ${CONSTANT_PREFIX}_ELEMENTS_OFFSET
    + ${CONSTANT_PREFIX}_ELEMENTS_LENGTH;

type Serialized${TYPE_NAME} = [u8; ${CONSTANT_PREFIX}_LENGTH];

struct ${TYPE_NAME} {
    size: u32,
    elements: [${INNER_TYPE_NAME}; ${FIXED_SIZE}],
}

impl ${TYPE_NAME} {
    fn empty() -> ${TYPE_NAME} {
        ${TYPE_NAME} {
            size: 0 as u32,
            elements: [${INNER_TYPE_NAME}::empty(); ${FIXED_SIZE}],
        }
    }

    fn equals(this: ${TYPE_NAME}, that: ${TYPE_NAME}) -> bool {
        let mut still_equal = this.size == that.size;
        for i in 0..${FIXED_SIZE} while still_equal && i as u32 < this.size {
            still_equal = ${INNER_TYPE_NAME}::equals(this.elements[i], that.elements[i]);
        }
        still_equal
    }

    fn contains(this: ${TYPE_NAME}, value: ${INNER_TYPE_NAME}) -> bool {
        let mut found = false;
        for i in 0..${FIXED_SIZE} while !found && i as u32 < this.size {
            found = ${INNER_TYPE_NAME}::equals(this.elements[i], value);
        }
        found
    }

    fn is_subset(this: ${TYPE_NAME}, that: ${TYPE_NAME}) -> bool {
        let mut still_subset = this.size <= that.size;
        for i in 0..${FIXED_SIZE} while still_subset && i as u32 < this.size {
            still_subset = contains(that, this.elements[i]);
        }
        still_subset
    }

    fn deserialize(serialized: Serialized${TYPE_NAME}) -> ${TYPE_NAME} {
        let size = {
            let mut size_bytes = [0; ${CONSTANT_PREFIX}_SIZE_LENGTH];
            for i in 0..${CONSTANT_PREFIX}_SIZE_LENGTH {
                size_bytes[i] = serialized[i + ${CONSTANT_PREFIX}_SIZE_OFFSET];
            }
            platform_integer::parse_u32(size_bytes)
        };

        let elements = {
            let mut element_array = [${INNER_TYPE_NAME}::empty(); ${FIXED_SIZE}];
            let mut element_bytes = [0; ${INNER_CONSTANT_PREFIX}_LENGTH];
            for i in 0..${FIXED_SIZE} while i as u32 < size {
                for j in 0..${INNER_CONSTANT_PREFIX}_LENGTH {
                    element_bytes[j] = serialized[j + ${CONSTANT_PREFIX}_ELEMENTS_OFFSET + (i as u16) * ${INNER_CONSTANT_PREFIX}_LENGTH];
                }
                element_array[i] = ${INNER_TYPE_NAME}::deserialize(element_bytes);
            }
            element_array
        };

        ${TYPE_NAME} {
            size: size,
            elements: elements,
        }
    }
}