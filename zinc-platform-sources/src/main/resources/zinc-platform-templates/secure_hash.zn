// Input parameters:
//   - BYTES_SIZE: u16 = The bytearray size of the bytes field

mod byte_array_${BYTES_SIZE};

use byte_array_${BYTES_SIZE}::ByteArray_${BYTES_SIZE};
use byte_array_${BYTES_SIZE}::BYTE_ARRAY_${BYTES_SIZE}_LENGTH;

//! SecureHash lengths
const SECURE_HASH_ALGORITHM_LENGTH: u16 = 1;
const SECURE_HASH_BYTES_LENGTH: u16 = BYTE_ARRAY_${BYTES_SIZE}_LENGTH;

//! SecureHash offsets
const SECURE_HASH_ALGORITHM_OFFSET: u16 = 0;
const SECURE_HASH_BYTES_OFFSET: u16
    = SECURE_HASH_ALGORITHM_OFFSET
    + SECURE_HASH_ALGORITHM_LENGTH;
const SECURE_HASH_LENGTH: u16
    = SECURE_HASH_BYTES_OFFSET
    + SECURE_HASH_BYTES_LENGTH;

type SerializedSecureHash = [u8; SECURE_HASH_LENGTH];

struct SecureHash {
    algorithm: u8,
    bytes: ByteArray_${BYTES_SIZE},
}

impl SecureHash {
    fn empty() -> SecureHash {
        SecureHash {
            algorithm: 0,
            bytes: ByteArray_${BYTES_SIZE}::empty(),
        }
    }

    fn equals(this: SecureHash, that: SecureHash) -> bool {
        this.algorithm == that.algorithm
            && ByteArray_${BYTES_SIZE}::equals(this.bytes, that.bytes)
    }

    fn deserialize(serialized_hash: SerializedSecureHash) -> SecureHash {
        let algorithm = serialized_hash[SECURE_HASH_ALGORITHM_OFFSET];

        let mut bytes = [0; SECURE_HASH_BYTES_LENGTH];
        for i in 0..SECURE_HASH_BYTES_LENGTH {
            bytes[i] = serialized_hash[i + SECURE_HASH_BYTES_OFFSET];
        }

        SecureHash {
            algorithm: algorithm,
            bytes: ByteArray_${BYTES_SIZE}::deserialize(bytes),
        }
    }
}
