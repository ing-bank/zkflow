// Input parameters:
//   - TYPE_NAME: String = The type name of the generated file
//   - CONST_PREFIX: String = The prefix to use for constants
//   - ENCODED_SIZE: u16 = Number of bytes in the encoded public key byte array
//   - SERIAL_NAME_SIZE: u16 = String size of SerialName

mod byte_array_${ENCODED_SIZE};
mod string_${SERIAL_NAME_SIZE};

use byte_array_${ENCODED_SIZE}::ByteArray_${ENCODED_SIZE};
use byte_array_${ENCODED_SIZE}::SerializedByteArray_${ENCODED_SIZE};
use byte_array_${ENCODED_SIZE}::BYTE_ARRAY_${ENCODED_SIZE}_LENGTH;

use string_${SERIAL_NAME_SIZE}::String_${SERIAL_NAME_SIZE};
use string_${SERIAL_NAME_SIZE}::SerializedString_${SERIAL_NAME_SIZE};
use string_${SERIAL_NAME_SIZE}::STRING_${SERIAL_NAME_SIZE}_LENGTH;

//! PublicKey lengths
const ${CONST_PREFIX}_SERIAL_NAME_LENGTH: u16 = STRING_${SERIAL_NAME_SIZE}_LENGTH;
const ${CONST_PREFIX}_ENCODED_LENGTH: u16 = BYTE_ARRAY_${ENCODED_SIZE}_LENGTH;

//! PublicKey offsets
const ${CONST_PREFIX}_SERIAL_NAME_OFFSET: u16 = 0;
const ${CONST_PREFIX}_ENCODED_OFFSET: u16
    = ${CONST_PREFIX}_SERIAL_NAME_OFFSET
    + ${CONST_PREFIX}_SERIAL_NAME_LENGTH;
const ${CONST_PREFIX}_LENGTH: u16
    = ${CONST_PREFIX}_ENCODED_OFFSET
    + ${CONST_PREFIX}_ENCODED_LENGTH;

type Serialized${TYPE_NAME} = [u8; ${CONST_PREFIX}_LENGTH];
struct ${TYPE_NAME} {
    serial_name: String_${SERIAL_NAME_SIZE},
    encoded: ByteArray_${ENCODED_SIZE},
}

impl ${TYPE_NAME} {
    fn equals(this: ${TYPE_NAME}, that: ${TYPE_NAME}) -> bool {
        String_${SERIAL_NAME_SIZE}::equals(this.serial_name, that.serial_name)
            && ByteArray_${ENCODED_SIZE}::equals(this.encoded, that.encoded)
    }

    fn deserialize(serialized: Serialized${TYPE_NAME}) -> ${TYPE_NAME} {
        let serial_name = {
            let mut serial_bytes = [0; ${CONST_PREFIX}_SERIAL_NAME_LENGTH];
            for i in 0..${CONST_PREFIX}_SERIAL_NAME_LENGTH {
                serial_bytes[i] = serialized[i + ${CONST_PREFIX}_SERIAL_NAME_OFFSET];
            }
            String_${SERIAL_NAME_SIZE}::deserialize(serial_bytes)
        };
        let encoded = {
            let mut encoded_bytes = [0; ${CONST_PREFIX}_ENCODED_LENGTH];
            for i in 0..${CONST_PREFIX}_ENCODED_LENGTH {
                encoded_bytes[i] = serialized[i + ${CONST_PREFIX}_ENCODED_OFFSET];
            }
            ByteArray_${ENCODED_SIZE}::deserialize(encoded_bytes)
        };
        ${TYPE_NAME} {
            serial_name: serial_name,
            encoded: encoded,
        }
    }
}
