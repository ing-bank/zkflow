// Input parameters:
//   - TYPE_NAME: String = The type name of the generated file
//   - CONSTANT_PREFIX: String = The prefix to use for constants
//   - ENCODED_SIZE: u16 = Number of bytes in the encoded public key byte array

mod byte_array_${ENCODED_SIZE};
mod string_1;

use byte_array_${ENCODED_SIZE}::ByteArray_${ENCODED_SIZE};
use byte_array_${ENCODED_SIZE}::SerializedByteArray_${ENCODED_SIZE};
use byte_array_${ENCODED_SIZE}::BYTE_ARRAY_${ENCODED_SIZE}_LENGTH;

use string_1::STRING_1_LENGTH;

//! PublicKey lengths
const ${CONSTANT_PREFIX}_SERIAL_NAME_LENGTH: u16 = STRING_1_LENGTH;
const ${CONSTANT_PREFIX}_SCHEME_ID_LENGTH: u16 = 1;
const ${CONSTANT_PREFIX}_ENCODED_LENGTH: u16 = BYTE_ARRAY_${ENCODED_SIZE}_LENGTH;

//! PublicKey offsets
const ${CONSTANT_PREFIX}_SCHEME_ID_OFFSET: u16
    = ${CONSTANT_PREFIX}_SERIAL_NAME_LENGTH;
const ${CONSTANT_PREFIX}_ENCODED_OFFSET: u16
    = ${CONSTANT_PREFIX}_SCHEME_ID_OFFSET
    + ${CONSTANT_PREFIX}_SCHEME_ID_LENGTH;
const ${CONSTANT_PREFIX}_LENGTH: u16
    = ${CONSTANT_PREFIX}_ENCODED_OFFSET
    + ${CONSTANT_PREFIX}_ENCODED_LENGTH;

type Serialized${TYPE_NAME} = [u8; ${CONSTANT_PREFIX}_LENGTH];
struct ${TYPE_NAME} {
    scheme_id: u8,
    encoded: ByteArray_${ENCODED_SIZE},
}

impl ${TYPE_NAME} {
    // In Corda notation, the two versions of BCECPublicKey with different curves,
    // correspond to two signtature schemes: Crypto.ECDSA_SECP256K1_SHA256 (88 bytes)
    // and Crypto.ECDSA_SECP256R1_SHA256 (91 bytes).
    // These scheme have associated schemeId's 2 and 3, respectively.
    // See net.corda.core.crypto.Crypto.
    // 0 corresponds to another scheme which is serialized without using a schemeId,
    // the type system will prevent us from interpreting this type as the type corresponding
    // to the signature scheme with schemeId 0.
    fn empty() -> ${TYPE_NAME} {
        ${TYPE_NAME} {
            scheme_id: 0 as u8,
            encoded: ByteArray_${ENCODED_SIZE}::empty(),
        }
    }

    fn equals(this: ${TYPE_NAME}, that: ${TYPE_NAME}) -> bool {
        this.scheme_id == that.scheme_id
            && ByteArray_${ENCODED_SIZE}::equals(this.encoded, that.encoded)
    }

    fn deserialize(serialized: Serialized${TYPE_NAME}) -> ${TYPE_NAME} {
        let scheme_id = serialized[${CONSTANT_PREFIX}_SCHEME_ID_OFFSET];

        let encoded = {
            let mut encoded_bytes = [0; ${CONSTANT_PREFIX}_ENCODED_LENGTH];
            for i in 0..${CONSTANT_PREFIX}_ENCODED_LENGTH {
                encoded_bytes[i] = serialized[i + ${CONSTANT_PREFIX}_ENCODED_OFFSET];
            }
            ByteArray_${ENCODED_SIZE}::deserialize(encoded_bytes)
        };

        ${TYPE_NAME} {
            scheme_id: scheme_id,
            encoded: encoded,
        }
    }
}
