// Input parameters:
//   - TYPE_NAME: String = Name of the main struct, and suffix for Serialized struct, use camelcase
//   - CONSTANT_PREFIX: String = prefix to use for constant names, use uppercase
//   - TOKEN_SIZE_PLACEHOLDER: u16 = number of bytes of bfl encoded token
//   - BD_TYPE_NAME: String = name of the BigDecimal struct, and suffix for Serialized struct, use camelcase
//   - BD_CONSTANT_PREFIX: String = prefix used for constant names of BigDecimal, use uppercase and snakecase
//   - BD_MODULE_NAME: String = module name of the BigDecimal, use lowercase and snakecase
// NOTE:
// All internal size constants are u16, which mean that all values should be below 65536.

mod ${BD_MODULE_NAME};
mod platform_consts;
mod platform_integer;

use ${BD_MODULE_NAME}::${BD_TYPE_NAME};
use ${BD_MODULE_NAME}::Serialized${BD_TYPE_NAME};
use ${BD_MODULE_NAME}::${BD_CONSTANT_PREFIX}_LENGTH;

use platform_consts::BYTE_BITS;
use platform_consts::U32_BITS;
use platform_consts::U32_BYTES;
use platform_consts::U64_BITS;
use platform_consts::U64_BYTES;

//! ${TYPE_NAME} lengths
const ${CONSTANT_PREFIX}_QUANTITY_LENGTH: u16 = U64_BYTES;
const ${CONSTANT_PREFIX}_DISPLAY_TOKEN_SIZE_LENGTH: u16 = ${BD_CONSTANT_PREFIX}_LENGTH;
const ${CONSTANT_PREFIX}_TOKEN_TYPE_HASH_LENGTH_LENGTH: u16 = U32_BYTES;
const ${CONSTANT_PREFIX}_TOKEN_TYPE_HASH_LENGTH: u16 = 32;
const ${CONSTANT_PREFIX}_TOKEN_LENGTH: u16 = ${TOKEN_SIZE_PLACEHOLDER};

//! ${TYPE_NAME} offsets
const ${CONSTANT_PREFIX}_QUANTITY_OFFSET: u16 = 0;
const ${CONSTANT_PREFIX}_DISPLAY_TOKEN_SIZE_OFFSET: u16 =
    ${CONSTANT_PREFIX}_QUANTITY_OFFSET
    + ${CONSTANT_PREFIX}_QUANTITY_LENGTH;
const ${CONSTANT_PREFIX}_TOKEN_TYPE_HASH_LENGTH_OFFSET: u16 =
    ${CONSTANT_PREFIX}_DISPLAY_TOKEN_SIZE_OFFSET
    + ${CONSTANT_PREFIX}_DISPLAY_TOKEN_SIZE_LENGTH;
const ${CONSTANT_PREFIX}_TOKEN_TYPE_HASH_OFFSET: u16 =
    ${CONSTANT_PREFIX}_TOKEN_TYPE_HASH_LENGTH_OFFSET
    + ${CONSTANT_PREFIX}_TOKEN_TYPE_HASH_LENGTH_LENGTH;
const ${CONSTANT_PREFIX}_TOKEN_OFFSET: u16 =
    ${CONSTANT_PREFIX}_TOKEN_TYPE_HASH_OFFSET
    + ${CONSTANT_PREFIX}_TOKEN_TYPE_HASH_LENGTH;
const ${CONSTANT_PREFIX}_LENGTH: u16 =
    ${CONSTANT_PREFIX}_TOKEN_OFFSET
    + ${CONSTANT_PREFIX}_TOKEN_LENGTH;

type Serialized${TYPE_NAME} = [u8; ${CONSTANT_PREFIX}_LENGTH];

type TokenHash = [u8; ${CONSTANT_PREFIX}_TOKEN_TYPE_HASH_LENGTH];
type TokenValue = [u8; ${CONSTANT_PREFIX}_TOKEN_LENGTH];

//The representation of class net.corda.core.contracts.Amount in zinc. However, zinc does not support
//generics, thus to maintain it to some extend we use the hash of the token.
//
//Description of struct properties:
//quantity - number of tokens
//display_token_size - number of units stored in token
//token_type_hash - hash of token, used to distinguish tokens only
//token - serialized token
//
//For more information about struct properties, please, refer to class net.corda.core.contracts.Amount.
struct ${TYPE_NAME} {
    quantity: i64,
    display_token_size: ${BD_TYPE_NAME},
    token_type_hash: TokenHash,
    token: TokenValue,
}

impl ${TYPE_NAME} {
    fn empty() -> ${TYPE_NAME} {
        ${TYPE_NAME} {
            quantity: 0 as i64,
            display_token_size: ${BD_TYPE_NAME}::empty(),
            token_type_hash: [0; ${CONSTANT_PREFIX}_TOKEN_TYPE_HASH_LENGTH],
            token: [0; ${CONSTANT_PREFIX}_TOKEN_LENGTH],
        }
    }

    fn _compare_token_type_hashes(
        this_token_type_hash: TokenHash,
        that_token_type_hash: TokenHash,
    ) -> bool {
        let mut result = true;
        for i in 0..${CONSTANT_PREFIX}_TOKEN_TYPE_HASH_LENGTH {
            result = result && this_token_type_hash[i] == that_token_type_hash[i];
        }
        result
    }

    fn _compare_tokens(
        this_token: TokenValue,
        that_token: TokenValue,
    ) -> bool {
        let mut result = true;
        for i in 0..${CONSTANT_PREFIX}_TOKEN_LENGTH {
            result = result && this_token[i] == that_token[i];
        }
        result
    }

    fn _check_token(this: ${TYPE_NAME}, that: ${TYPE_NAME}) {
        assert!(
            ${BD_TYPE_NAME}::equals(this.display_token_size, that.display_token_size),
            "Token sizes don't match"
        );
        assert!(
            ${TYPE_NAME}::_compare_token_type_hashes(this.token_type_hash, that.token_type_hash),
            "Token types don't match"
        );
        assert!(
            ${TYPE_NAME}::_compare_tokens(this.token, that.token),
            "Tokens don't match"
        );
    }

    fn plus(this: ${TYPE_NAME}, that: ${TYPE_NAME}) -> ${TYPE_NAME} {
        _check_token(this, that);
        ${TYPE_NAME} {
            quantity: this.quantity + that.quantity,
            display_token_size: this.display_token_size,
            token_type_hash: this.token_type_hash,
            token: this.token,
        }
    }

    fn minus(this: ${TYPE_NAME}, that: ${TYPE_NAME}) -> ${TYPE_NAME} {
        _check_token(this, that);
        ${TYPE_NAME} {
            quantity: this.quantity - that.quantity,
            display_token_size: this.display_token_size,
            token_type_hash: this.token_type_hash,
            token: this.token,
        }
    }

    fn equals(this: ${TYPE_NAME}, that: ${TYPE_NAME}) -> bool {
        this.quantity == that.quantity
            && ${TYPE_NAME}::_compare_token_type_hashes(this.token_type_hash, that.token_type_hash)
            && ${BD_TYPE_NAME}::equals(this.display_token_size, that.display_token_size)
    }

    fn _extract_int(bytes: Serialized${TYPE_NAME}, offset: u16) -> u32 {
        let mut bits = [false; U32_BITS];
        for i in 0..U32_BYTES {
            let pre_bits = std::convert::to_bits(bytes[i + offset]);

            for j in 0..BYTE_BITS {
                bits[i * BYTE_BITS + j] = pre_bits[j];
            }
        }
        std::convert::from_bits_unsigned(bits)
    }

    fn _extract_long(bytes: Serialized${TYPE_NAME}, offset: u16) -> u64 {
        let mut bits = [false; U64_BITS];
        for i in 0..U64_BYTES {
            let pre_bits = std::convert::to_bits(bytes[i + offset]);

            for j in 0..BYTE_BITS {
                bits[i * BYTE_BITS + j] = pre_bits[j];
            }
        }
        std::convert::from_bits_unsigned(bits)
    }

    fn _extract_${BD_MODULE_NAME}(serialized_amount: Serialized${TYPE_NAME}, offset: u16) -> ${BD_TYPE_NAME} {
        let mut bd_bytes: Serialized${BD_TYPE_NAME} = [0; ${BD_CONSTANT_PREFIX}_LENGTH];
        for i in 0..${BD_CONSTANT_PREFIX}_LENGTH {
            bd_bytes[i] = serialized_amount[offset + i];
        }
        ${BD_TYPE_NAME}::deserialize(bd_bytes)
    }

    fn deserialize(serialized_amount: Serialized${TYPE_NAME}) -> ${TYPE_NAME} {
        let quantity = _extract_long(serialized_amount, ${CONSTANT_PREFIX}_QUANTITY_OFFSET);

        let display_token_size = _extract_${BD_MODULE_NAME}(serialized_amount, ${CONSTANT_PREFIX}_DISPLAY_TOKEN_SIZE_OFFSET);

        let token_type_hash_length = _extract_int(serialized_amount, ${CONSTANT_PREFIX}_TOKEN_TYPE_HASH_LENGTH_OFFSET);
        let mut token_type_hash: TokenHash = [0; ${CONSTANT_PREFIX}_TOKEN_TYPE_HASH_LENGTH];
        for i in 0..${CONSTANT_PREFIX}_TOKEN_TYPE_HASH_LENGTH while i as u32 < token_type_hash_length {
            token_type_hash[i] = serialized_amount[${CONSTANT_PREFIX}_TOKEN_TYPE_HASH_OFFSET + i];
        }

        let mut token: TokenValue = [0; ${CONSTANT_PREFIX}_TOKEN_LENGTH];
        for i in 0..${CONSTANT_PREFIX}_TOKEN_LENGTH {
            token[i] = serialized_amount[${CONSTANT_PREFIX}_TOKEN_OFFSET + i];
        }

        ${TYPE_NAME} {
            quantity: quantity as i64,
            display_token_size: display_token_size,
            token_type_hash: token_type_hash,
            token: token,
        }
    }
}
