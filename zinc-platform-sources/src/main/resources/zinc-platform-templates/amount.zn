// Input parameters:
//   - AMOUNT_TOKEN_SIZE: TODO
//   - INTEGER_SIZE_PLACEHOLDER: u16 = Integer size of BigDecimal displayTokenSize
//   - FRACTION_SIZE_PLACEHOLDER: u16 = Fraction size of BigDecimal displayTokenSize
// NOTE:
// All internal size constants are u16, which mean that all values should be below 65536.

mod big_decimal_${INTEGER_SIZE_PLACEHOLDER}_${FRACTION_SIZE_PLACEHOLDER};

use big_decimal_${INTEGER_SIZE_PLACEHOLDER}_${FRACTION_SIZE_PLACEHOLDER}::BigDecimal;
use big_decimal_${INTEGER_SIZE_PLACEHOLDER}_${FRACTION_SIZE_PLACEHOLDER}::SerializedBigDecimal;
use big_decimal_${INTEGER_SIZE_PLACEHOLDER}_${FRACTION_SIZE_PLACEHOLDER}::BIG_DECIMAL_LENGTH;

const AMOUNT_QUANTITY_LENGTH: u16 = 8;
const AMOUNT_DISPLAY_TOKEN_SIZE_LENGTH: u16 = BIG_DECIMAL_LENGTH;
const AMOUNT_TOKEN_TYPE_HASH_LENGTH_LENGTH: u16 = 4;
const AMOUNT_TOKEN_TYPE_HASH_LENGTH: u16 = 32;
// TODO make template parameter
const AMOUNT_TOKEN_LENGTH: u16 = 8;

//! Amount offsets
const AMOUNT_QUANTITY_OFFSET: u16 = 0;
const AMOUNT_DISPLAY_TOKEN_SIZE_OFFSET: u16 =
    AMOUNT_QUANTITY_OFFSET
    + AMOUNT_QUANTITY_LENGTH;
const AMOUNT_TOKEN_TYPE_HASH_LENGTH_OFFSET: u16 =
    AMOUNT_DISPLAY_TOKEN_SIZE_OFFSET
    + AMOUNT_DISPLAY_TOKEN_SIZE_LENGTH;
const AMOUNT_TOKEN_TYPE_HASH_OFFSET: u16 =
    AMOUNT_TOKEN_TYPE_HASH_LENGTH_OFFSET
    + AMOUNT_TOKEN_TYPE_HASH_LENGTH_LENGTH;
const AMOUNT_TOKEN_OFFSET: u16 =
    AMOUNT_TOKEN_TYPE_HASH_OFFSET
    + AMOUNT_TOKEN_TYPE_HASH_LENGTH;
const AMOUNT_LENGTH: u16 =
    AMOUNT_TOKEN_OFFSET
    + AMOUNT_TOKEN_LENGTH;

type SerializedAmount = [u8; AMOUNT_LENGTH];

type TokenHash = [u8; AMOUNT_TOKEN_TYPE_HASH_LENGTH];
type TokenValue = [u8; AMOUNT_TOKEN_LENGTH];

//The representation of class net.corda.core.contracts.Amount in zinc. However, zinc does not support
//generics, thus to maintain it to some extend we use the hash of the token.
//
//Description of struct properties:
//quantity - number of tokens
//display_token_size - number of units stored in token
//token_type_hash - hash of token, used to distinguish tokens only
//token - serialized token
//
//For more information about struct properties, please, refer to class net.corda.core.contracts.Amount.
struct Amount {
    quantity: i64,
    display_token_size: BigDecimal,
    token_type_hash: TokenHash,
    token: TokenValue,
}

impl Amount {
    fn zero() -> Amount {
        Amount {
            quantity: 0 as i64,
            display_token_size: BigDecimal::zero(),
            token_type_hash: [0; AMOUNT_TOKEN_TYPE_HASH_LENGTH],
            token: [0; AMOUNT_TOKEN_LENGTH],
        }
    }

    fn _compare_token_type_hashes(
        this_token_type_hash: TokenHash,
        that_token_type_hash: TokenHash,
    ) -> bool {
        let mut result = true;
        for i in 0..AMOUNT_TOKEN_TYPE_HASH_LENGTH {
            result = result && this_token_type_hash[i] == that_token_type_hash[i];
        }
        result
    }

    fn _compare_tokens(
        this_token: TokenValue,
        that_token: TokenValue,
    ) -> bool {
        let mut result = true;
        for i in 0..AMOUNT_TOKEN_LENGTH {
            result = result && this_token[i] == that_token[i];
        }
        result
    }

    fn _check_token(this: Amount, that: Amount) {
        assert!(
            BigDecimal::equals(this.display_token_size, that.display_token_size),
            "Token sizes don't match"
        );
        assert!(
            Amount::_compare_token_type_hashes(this.token_type_hash, that.token_type_hash),
            "Token types don't match"
        );
        assert!(
            Amount::_compare_tokens(this.token, that.token),
            "Tokens don't match"
        );
    }

    fn plus(this: Amount, that: Amount) -> Amount {
        _check_token(this, that);
        Amount {
            quantity: this.quantity + that.quantity,
            display_token_size: this.display_token_size,
            token_type_hash: this.token_type_hash,
            token: this.token,
        }
    }

    fn minus(this: Amount, that: Amount) -> Amount {
        _check_token(this, that);
        Amount {
            quantity: this.quantity - that.quantity,
            display_token_size: this.display_token_size,
            token_type_hash: this.token_type_hash,
            token: this.token,
        }
    }

    fn equals(this: Amount, that: Amount) -> bool {
        this.quantity == that.quantity
            && Amount::_compare_token_type_hashes(this.token_type_hash, that.token_type_hash)
            && BigDecimal::equals(this.display_token_size, that.display_token_size)
    }

    fn _extract_int(serialized_amount: SerializedAmount, offset: u16) -> u32 {
        let mut result: u32 = 0;
        for i in 0..4 {
            result = result * 256 as u32 + serialized_amount[offset + i as u16] as u32;
        }
        result
    }

    fn _extract_long(serialized_amount: SerializedAmount, offset: u16) -> u64 {
        let mut result: u64 = 0;
        for i in 0..8 {
            result = result * 256 as u64 + serialized_amount[offset + i as u16] as u64;
        }
        result
    }

    fn _extract_big_decimal(serialized_amount: SerializedAmount, offset: u16) -> BigDecimal {
        let mut bd_bytes: SerializedBigDecimal = [0; BIG_DECIMAL_LENGTH];
        for i in 0..BIG_DECIMAL_LENGTH {
            bd_bytes[i] = serialized_amount[offset + i];
        }
        BigDecimal::deserialize(bd_bytes)
    }

    fn deserialize(serialized_amount: SerializedAmount) -> Amount {
        let quantity = _extract_long(serialized_amount, AMOUNT_QUANTITY_OFFSET);

        let display_token_size = _extract_big_decimal(serialized_amount, AMOUNT_DISPLAY_TOKEN_SIZE_OFFSET);

        let token_type_hash_length = _extract_int(serialized_amount, AMOUNT_TOKEN_TYPE_HASH_LENGTH_OFFSET);
        let mut token_type_hash: TokenHash = [0; AMOUNT_TOKEN_TYPE_HASH_LENGTH];
        for i in 0..AMOUNT_TOKEN_TYPE_HASH_LENGTH while i as u32 < token_type_hash_length {
            token_type_hash[i] = serialized_amount[AMOUNT_TOKEN_TYPE_HASH_OFFSET + i];
        }

        let mut token: TokenValue = [0; AMOUNT_TOKEN_LENGTH];
        for i in 0..AMOUNT_TOKEN_LENGTH {
            token[i] = serialized_amount[AMOUNT_TOKEN_OFFSET + i];
        }

        Amount {
            quantity: quantity as i64,
            display_token_size: display_token_size,
            token_type_hash: token_type_hash,
            token: token,
        }
    }
}
