// Input parameters:
//   - TYPE_NAME: String = The type name of the generated struct
//   - CONSTANT_PREFIX: String = The prefix to use for constants
//   - PARTY_TYPE_NAME: String = The type name to use for Party
//   - PARTY_MODULE_NAME: String = The module name for Party
//   - PARTY_CONSTANT_PREFIX: String = The constant prefix for Party
//   - REFERENCE_SIZE: u16 = The max number of bytes in the Reference

mod ${PARTY_MODULE_NAME};
mod byte_array_${REFERENCE_SIZE};

use ${PARTY_MODULE_NAME}::${PARTY_TYPE_NAME};
use ${PARTY_MODULE_NAME}::${PARTY_CONSTANT_PREFIX}_LENGTH;

use byte_array_${REFERENCE_SIZE}::ByteArray_${REFERENCE_SIZE};
use byte_array_${REFERENCE_SIZE}::SerializedByteArray_${REFERENCE_SIZE};
use byte_array_${REFERENCE_SIZE}::BYTE_ARRAY_${REFERENCE_SIZE}_LENGTH;

//! ${TYPE_NAME} lengths
const ${CONSTANT_PREFIX}_PARTY_LENGTH: u16 = ${PARTY_CONSTANT_PREFIX}_LENGTH;
const ${CONSTANT_PREFIX}_REFERENCE_LENGTH: u16 = BYTE_ARRAY_${REFERENCE_SIZE}_LENGTH;

//! ${TYPE_NAME} offsets
const ${CONSTANT_PREFIX}_PARTY_OFFSET: u16
    = 0;
const ${CONSTANT_PREFIX}_REFERENCE_OFFSET: u16
    = ${CONSTANT_PREFIX}_PARTY_OFFSET
    + ${CONSTANT_PREFIX}_PARTY_LENGTH;
//! ${TYPE_NAME} length
const ${CONSTANT_PREFIX}_LENGTH: u16
    = ${CONSTANT_PREFIX}_REFERENCE_OFFSET
    + ${CONSTANT_PREFIX}_REFERENCE_LENGTH;

type Serialized${TYPE_NAME} = [u8; ${CONSTANT_PREFIX}_LENGTH];

type PartyType = ${PARTY_TYPE_NAME};
type ReferenceType = ByteArray_${REFERENCE_SIZE};
struct ${TYPE_NAME} {
    party: PartyType,
    reference: ReferenceType,
}

impl ${TYPE_NAME} {
    fn equals(this: ${TYPE_NAME}, that: ${TYPE_NAME}) -> bool {
        PartyType::equals(this.party, that.party)
            && ReferenceType::equals(this.reference, that.reference)
    }

    fn deserialize(serialized: Serialized${TYPE_NAME}) -> ${TYPE_NAME} {
        let party = {
            let mut party_bytes = [0; ${CONSTANT_PREFIX}_PARTY_LENGTH];
            for i in 0..${CONSTANT_PREFIX}_PARTY_LENGTH {
                party_bytes[i] = serialized[i + ${CONSTANT_PREFIX}_PARTY_OFFSET];
            }
            PartyType::deserialize(party_bytes)
        };
        let reference = {
            let mut reference_bytes = [0; ${CONSTANT_PREFIX}_REFERENCE_LENGTH];
            for i in 0..${CONSTANT_PREFIX}_REFERENCE_LENGTH {
                reference_bytes[i] = serialized[i + ${CONSTANT_PREFIX}_REFERENCE_OFFSET];
            }
            ReferenceType::deserialize(reference_bytes)
        };
        ${TYPE_NAME} {
            party: party,
            reference: reference,
        }
    }
}
