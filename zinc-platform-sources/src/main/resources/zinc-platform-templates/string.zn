// Input parameters:
//   - TYPE_NAME: String = Name of the main struct, and suffix for Serialized struct, use camelcase
//   - CONSTANT_PREFIX: String = prefix to use for constant names, use uppercase
//   - STRING_SIZE_PLACEHOLDER: u16 = max number of characters in encoded string
// NOTE:
// All internal size constants are u16, which mean that all chars should be below 65536.

mod platform_consts;
mod platform_integer;

use platform_consts::BYTE_BITS;
use platform_consts::U16_BITS;
use platform_consts::U16_BYTES;

const ${CONSTANT_PREFIX}_MAX_CHARS: u16 = ${STRING_SIZE_PLACEHOLDER};

//! ${TYPE_NAME} field byte sizes
const ${CONSTANT_PREFIX}_SIZE_LENGTH: u16 = U16_BYTES;
const ${CONSTANT_PREFIX}_CHARS_LENGTH: u16 = ${CONSTANT_PREFIX}_MAX_CHARS * U16_BYTES;

//! ${TYPE_NAME} field offsets
const ${CONSTANT_PREFIX}_SIZE_OFFSET: u16 = 0;
const ${CONSTANT_PREFIX}_CHARS_OFFSET: u16 =
      ${CONSTANT_PREFIX}_SIZE_OFFSET
    + ${CONSTANT_PREFIX}_SIZE_LENGTH;
const ${CONSTANT_PREFIX}_LENGTH: u16 =
      ${CONSTANT_PREFIX}_CHARS_OFFSET
    + ${CONSTANT_PREFIX}_CHARS_LENGTH;

type Serialized${TYPE_NAME} = [u8; ${CONSTANT_PREFIX}_LENGTH];

struct ${TYPE_NAME} {
    size: u16,
    chars: [u16; ${CONSTANT_PREFIX}_MAX_CHARS],
}

impl ${TYPE_NAME} {
    fn print_structure() {
        dbg!("[${TYPE_NAME}] LENGTH: {}", ${CONSTANT_PREFIX}_LENGTH);
        dbg!("[${TYPE_NAME}] STRUCTURE");
        dbg!("[${TYPE_NAME}] - SIZE:     {}", ${CONSTANT_PREFIX}_SIZE_LENGTH);
        dbg!("[${TYPE_NAME}] - CHARS: {}", ${CONSTANT_PREFIX}_CHARS_LENGTH);
        dbg!("[${TYPE_NAME}]   - CAPACITY: {}", ${CONSTANT_PREFIX}_MAX_CHARS);
        dbg!("[${TYPE_NAME}]   - ELEMENT:  2 (u16)");
        dbg!("[${TYPE_NAME}]");
    }

    fn empty() -> ${TYPE_NAME} {
        ${TYPE_NAME} {
            size: 0 as u16,
            chars: [0 as u16; ${CONSTANT_PREFIX}_MAX_CHARS],
        }
    }

    //! Checks whether two strings are equal
    //! returns true iff the size and chars of both strings are equal
    fn equals(this: ${TYPE_NAME}, that: ${TYPE_NAME}) -> bool {
        let mut still_equal = this.size == that.size;
        for i in 0..${CONSTANT_PREFIX}_MAX_CHARS while still_equal {
            still_equal = this.chars[i] == that.chars[i];
        }
        still_equal
    }

    //! Compares two strings, and returns the comparison result
    //! returns
    //! - -1 when this < that
    //! - 1  when this > that
    //! - 0  when this == that
    fn compare(this: ${TYPE_NAME}, that: ${TYPE_NAME}) -> i8 {
        let mut result: i8 = 0 as i8;
        for i in 0..${CONSTANT_PREFIX}_MAX_CHARS while result == 0 as i8 {
            result = if this.chars[i] < that.chars[i] {
                -1
            } else if this.chars[i] > that.chars[i] {
                1 as i8
            } else {
                0 as i8
            }
        }
        result
    }

    //! Extract a short in big-endian form
    fn _extract_short(bytes: Serialized${TYPE_NAME}, offset: u16) -> u16 {
        let mut bits = [false; U16_BITS];
        for i in 0..U16_BYTES {
            let pre_bits = std::convert::to_bits(bytes[i + offset]);

            for j in 0..BYTE_BITS {
                bits[i * BYTE_BITS + j] = pre_bits[j];
            }
        }
        std::convert::from_bits_unsigned(bits)
    }

    fn deserialize(serialized_string: Serialized${TYPE_NAME}) -> ${TYPE_NAME} {
        let string_length: u16 = _extract_short(serialized_string, 0 as u16);

        let mut string_chars = [0 as u16; ${CONSTANT_PREFIX}_MAX_CHARS];
        for i in 0..${CONSTANT_PREFIX}_MAX_CHARS {
            string_chars[i] = _extract_short(serialized_string, ${CONSTANT_PREFIX}_CHARS_OFFSET + (i * 2 as u16));
        }

        ${TYPE_NAME} {
            size: string_length,
            chars: string_chars,
        }
    }
}
