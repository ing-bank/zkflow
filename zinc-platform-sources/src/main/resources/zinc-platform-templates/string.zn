// Input parameters:
//   - TYPE_NAME: String = Name of the main struct, and suffix for Serialized struct, use camelcase
//   - CONSTANT_PREFIX: String = prefix to use for constant names, use uppercase
//   - STRING_SIZE_PLACEHOLDER: u16 = max number of characters in encoded string
// NOTE:
// All internal size constants are u16, which mean that all chars should be below 65536.

const ${CONSTANT_PREFIX}_MAX_CHARS: u16 = ${STRING_SIZE_PLACEHOLDER};

//! ${TYPE_NAME} field byte sizes
const ${CONSTANT_PREFIX}_SIZE_LENGTH: u16 = 2;
const ${CONSTANT_PREFIX}_CHARS_LENGTH: u16 = ${CONSTANT_PREFIX}_MAX_CHARS * 2 as u16;

//! ${TYPE_NAME} field offsets
const ${CONSTANT_PREFIX}_SIZE_OFFSET: u16 = 0;
const ${CONSTANT_PREFIX}_CHARS_OFFSET: u16 =
      ${CONSTANT_PREFIX}_SIZE_OFFSET
    + ${CONSTANT_PREFIX}_SIZE_LENGTH;
const ${CONSTANT_PREFIX}_LENGTH: u16 =
      ${CONSTANT_PREFIX}_CHARS_OFFSET
    + ${CONSTANT_PREFIX}_CHARS_LENGTH;

type Serialized${TYPE_NAME} = [u8; ${CONSTANT_PREFIX}_LENGTH];

struct ${TYPE_NAME} {
    size: u16,
    chars: [u16; ${CONSTANT_PREFIX}_MAX_CHARS],
}

impl ${TYPE_NAME} {
    fn empty() -> ${TYPE_NAME} {
        ${TYPE_NAME} {
            size: 0 as u16,
            chars: [0 as u16; ${CONSTANT_PREFIX}_MAX_CHARS],
        }
    }

    //! Checks whether two strings are equal
    //! returns true iff the size and chars of both strings are equal
    fn equals(this: ${TYPE_NAME}, that: ${TYPE_NAME}) -> bool {
        let mut still_equal = this.size == that.size;
        for i in 0..${CONSTANT_PREFIX}_MAX_CHARS while still_equal {
            still_equal = this.chars[i] == that.chars[i];
        }
        still_equal
    }

    //! Compares two strings, and returns the comparison result
    //! returns
    //! - -1 when this < that
    //! - 1  when this > that
    //! - 0  when this == that
    fn compare(this: ${TYPE_NAME}, that: ${TYPE_NAME}) -> i8 {
        let mut result: i8 = 0 as i8;
        for i in 0..${CONSTANT_PREFIX}_MAX_CHARS while result == 0 as i8 {
            result = if this.chars[i] < that.chars[i] {
                -1
            } else if this.chars[i] > that.chars[i] {
                1 as i8
            } else {
                0 as i8
            }
        }
        result
    }

    //! Extract a short in big-endian form
    fn _extract_short(serialized_string: Serialized${TYPE_NAME}, offset: u16) -> u16 {
        serialized_string[0 as u16 + offset] as u16 * 256 as u16 + serialized_string[1 as u16 + offset] as u16
    }

    fn deserialize(serialized_string: Serialized${TYPE_NAME}) -> ${TYPE_NAME} {
        let string_length: u16 = _extract_short(serialized_string, 0 as u16);

        let mut string_chars = [0 as u16; ${CONSTANT_PREFIX}_MAX_CHARS];
        for i in 0..${CONSTANT_PREFIX}_MAX_CHARS {
            // for i in 0..${CONSTANT_PREFIX}_MAX_CHARS while i < string_length {
            string_chars[i] = _extract_short(serialized_string, ${CONSTANT_PREFIX}_CHARS_OFFSET + (i * 2 as u16));
        }

        ${TYPE_NAME} {
            size: string_length,
            chars: string_chars,
        }
    }
}
