// Input parameters:
//   - STRING_SIZE_PLACEHOLDER: u16 = max number of characters in encoded string
// NOTE:
// All internal size constants are u16, which mean that all chars should be below 65536.

const STRING_MAX_CHARS: u16 = ${STRING_SIZE_PLACEHOLDER};

//! String field byte sizes
const STRING_SIZE_LENGTH: u16 = 2;
const STRING_CHARS_LENGTH: u16 = STRING_MAX_CHARS * 2 as u16;

//! String field offsets
const STRING_SIZE_OFFSET: u16 = 0;
const STRING_CHARS_OFFSET: u16 =
      STRING_SIZE_OFFSET
    + STRING_SIZE_LENGTH;
const STRING_LENGTH: u16 =
      STRING_CHARS_OFFSET
    + STRING_CHARS_LENGTH;

type SerializedString = [u8; STRING_LENGTH];

struct String {
    size: u16,
    chars: [u16; STRING_MAX_CHARS],
}

impl String {
    fn empty() -> String {
        String {
            size: 0 as u16,
            chars: [0 as u16; STRING_MAX_CHARS],
        }
    }

    fn compare(this: String, that: String) -> i8 {
        let mut result: i8 = 0 as i8;
        for i in 0..STRING_MAX_CHARS while result == 0 as i8 {
            result = if this.chars[i] < that.chars[i] {
                -1
            } else if this.chars[i] > that.chars[i] {
                1 as i8
            } else {
                0 as i8
            }
        }
        result
    }

    //! Extract a short in big-endian form
    fn _extract_short(serialized_string: SerializedString, offset: u16) -> u16 {
        serialized_string[0 as u16 + offset] as u16 * 256 as u16 + serialized_string[1 as u16 + offset] as u16
    }

    fn deserialize(serialized_string: SerializedString) -> String {
        let string_length: u16 = _extract_short(serialized_string, 0 as u16);

        let mut string_chars = [0 as u16; STRING_MAX_CHARS];
        for i in 0..STRING_MAX_CHARS {
            // for i in 0..STRING_MAX_CHARS while i < string_length {
            string_chars[i] = _extract_short(serialized_string, STRING_CHARS_OFFSET + (i * 2 as u16));
        }

        String {
            size: string_length,
            chars: string_chars,
        }
    }
}
