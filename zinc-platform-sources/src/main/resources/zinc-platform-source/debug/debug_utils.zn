///Debug functions to convert bit arrays to byte arrays  which helps readability in printing
///intermediate computation results.

///The constant values introduced in here are only used in this file to maintain the module order.
///They are not used in the main circuit computations.
///Once Zinc supports proper module system, these values should be deleted and replaced with
///the corresponding values in the main circuit.
const NONCE_DBG_BYTES: u16 = PRIVACY_SALT_BYTES + U32_BYTES + U32_BYTES;
const NONCE_DBG_BITS: u16 = PRIVACY_SALT_BITS + U32_BITS + U32_BITS;

const COMMAND_DBG_BYTES: u16 = U32_BYTES;
const COMMAND_DBG_BITS: u16 = COMMAND_DBG_BYTES * BYTE_BITS;

const PUBKEY_DBG_BYTES: u16 = 44;
const PUBKEY_DBG_BITS: u16 = PUBKEY_DBG_BYTES * BYTE_BITS;

const ATTACHMENT_ID_DBG_BYTES: u16 = 32;
const ATTACHMENT_ID_DBG_BITS: u16 = ATTACHMENT_ID_DBG_BYTES * BYTE_BITS;

const PARAMETERS_HASH_DBG_BYTES: u16 = 32;
const PARAMETERS_HASH_DBG_BITS: u16 = PARAMETERS_HASH_DBG_BYTES * BYTE_BITS;

const REF_DBG_BYTES: u16 = 32;
const REF_DBG_BITS: u16 = REF_DBG_BYTES * BYTE_BITS;

const STATE_DBG_BYTES: u16 = 32;
const STATE_DBG_BITS: u16 = STATE_DBG_BYTES * BYTE_BITS;

const TIME_WINDOW_DBG_BYTES: u16 = 32;
const TIME_WINDOW_DBG_BITS: u16 = TIME_WINDOW_DBG_BYTES * BYTE_BITS;

fn uint32_bits_to_bytes(bits: [bool; U32_BITS]) -> [u8; U32_BYTES] {
    let mut bytes = [0 as u8; U32_BYTES];

    for i in 0..U32_BYTES {
        let mut byte_bits = [false; BYTE_BITS];
        for j in 0..BYTE_BITS {
            byte_bits[j] = bits[BYTE_BITS * i + j];
        }
        bytes[i] = from_bits_unsigned(byte_bits);
    }
    bytes
}

fn privacy_salt_bits_to_bytes(bits: [bool; PRIVACY_SALT_BITS]) -> [u8; PRIVACY_SALT_BYTES] {
    let mut bytes = [0 as u8; PRIVACY_SALT_BYTES];

    for i in 0..PRIVACY_SALT_BYTES {
        let mut byte_bits = [false; BYTE_BITS];
        for j in 0..BYTE_BITS {
            byte_bits[j] = bits[BYTE_BITS * i + j];
        }
        bytes[i] = from_bits_unsigned(byte_bits);
    }
    bytes
}

fn pub_key_fingerprint_bits_to_bytes(bits: [bool; PUBKEY_DBG_BITS]) -> [u8; PUBKEY_DBG_BYTES] {
    let mut bytes = [0 as u8; PUBKEY_DBG_BYTES];

    for i in 0..PUBKEY_DBG_BYTES {
        let mut byte_bits = [false; BYTE_BITS];
        for j in 0..BYTE_BITS {
            byte_bits[j] = bits[BYTE_BITS * i + j];
        }
        bytes[i] = from_bits_unsigned(byte_bits);
    }
    bytes
}

fn nonce_preimage_bits_to_bytes(bits: [bool; NONCE_DBG_BITS]) -> [u8; NONCE_DBG_BYTES] {
    let mut bytes = [0 as u8; NONCE_DBG_BYTES];

    for i in 0..NONCE_DBG_BYTES {
        let mut byte_bits: [bool; BYTE_BITS] = [false; BYTE_BITS];
        for j in 0..BYTE_BITS {
            byte_bits[j] = bits[BYTE_BITS * i + j];
        }
        bytes[(i as u16)] = from_bits_unsigned(byte_bits);
    }
    bytes
}

fn command_data_fingerprint_bits_to_bytes(
    bits: [bool; COMMAND_DBG_BITS],
) -> [u8; COMMAND_DBG_BYTES] {
    let mut bytes = [0 as u8; COMMAND_DBG_BYTES];

    for i in 0..COMMAND_DBG_BYTES {
        let mut byte_bits = [false; BYTE_BITS];
        for j in 0..BYTE_BITS {
            byte_bits[j] = bits[BYTE_BITS * i + j];
        }
        bytes[i] = from_bits_unsigned(byte_bits);
    }
    bytes
}

fn attachment_id_fingerprint_bits_to_bytes(
    bits: [bool; ATTACHMENT_ID_DBG_BITS],
) -> [u8; ATTACHMENT_ID_DBG_BYTES] {
    let mut bytes = [0 as u8; ATTACHMENT_ID_DBG_BYTES];

    for i in 0..(ATTACHMENT_ID_DBG_BYTES) {
        let mut byte_bits = [false; BYTE_BITS];
        for j in 0..BYTE_BITS {
            byte_bits[j] = bits[BYTE_BITS * i + j];
        }
        bytes[i] = from_bits_unsigned(byte_bits);
    }
    bytes
}

fn parameters_hash_fingerprint_bits_to_bytes(
    bits: [bool; PARAMETERS_HASH_DBG_BITS],
) -> [u8; PARAMETERS_HASH_DBG_BYTES] {
    let mut bytes = [0 as u8; PARAMETERS_HASH_DBG_BYTES];

    for i in 0..(PARAMETERS_HASH_DBG_BYTES) {
        let mut byte_bits = [false; BYTE_BITS];
        for j in 0..BYTE_BITS {
            byte_bits[j] = bits[BYTE_BITS * i + j];
        }
        bytes[i] = from_bits_unsigned(byte_bits);
    }
    bytes
}

fn ref_fingerprint_bits_to_bytes(bits: [bool; REF_DBG_BITS]) -> [u8; REF_DBG_BYTES] {
    let mut bytes = [0 as u8; REF_DBG_BYTES];

    for i in 0..(REF_DBG_BYTES) {
        let mut byte_bits = [false; BYTE_BITS];
        for j in 0..BYTE_BITS {
            byte_bits[j] = bits[BYTE_BITS * i + j];
        }
        bytes[i] = from_bits_unsigned(byte_bits);
    }
    bytes
}

fn state_fingerprint_bits_to_bytes(bits: [bool; STATE_DBG_BITS]) -> [u8; STATE_DBG_BYTES] {
    let mut bytes = [0 as u8; STATE_DBG_BYTES];

    for i in 0..(STATE_DBG_BYTES) {
        let mut byte_bits = [false; BYTE_BITS];
        for j in 0..BYTE_BITS {
            byte_bits[j] = bits[BYTE_BITS * i + j];
        }
        bytes[i] = from_bits_unsigned(byte_bits);
    }
    bytes
}

fn time_window_fingerprint_bits_to_bytes(
    bits: [bool; TIME_WINDOW_DBG_BITS],
) -> [u8; TIME_WINDOW_DBG_BYTES] {
    let mut bytes = [0 as u8; TIME_WINDOW_DBG_BYTES];

    for i in 0..(TIME_WINDOW_DBG_BYTES) {
        let mut byte_bits = [false; BYTE_BITS];
        for j in 0..BYTE_BITS {
            byte_bits[j] = bits[BYTE_BITS * i + j];
        }
        bytes[i] = from_bits_unsigned(byte_bits);
    }
    bytes
}
