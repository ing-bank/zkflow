
mod platform_consts;

use platform_consts::U32_BYTES;

//! ZonedDateTime lengths
const ZONED_DATE_TIME_YEAR_LENGTH: u16 = U32_BYTES;
const ZONED_DATE_TIME_MONTH_LENGTH: u16 = 1;
const ZONED_DATE_TIME_DAY_OF_MONTH_LENGTH: u16 = 1;
const ZONED_DATE_TIME_HOUR_LENGTH: u16 = 1;
const ZONED_DATE_TIME_MINUTE_LENGTH: u16 = 1;
const ZONED_DATE_TIME_SECOND_LENGTH: u16 = 1;
const ZONED_DATE_TIME_NANO_OF_SECOND_LENGTH: u16 = U32_BYTES;
const ZONED_DATE_TIME_ZONE_OFFSET_SECONDS_LENGTH: u16 = U32_BYTES;
const ZONED_DATE_TIME_ZONE_ID_HASH_LENGTH: u16 = U32_BYTES;

//! ZonedDateTime offsets
const ZONED_DATE_TIME_YEAR_OFFSET: u16 = 0;
const ZONED_DATE_TIME_MONTH_OFFSET: u16
    = ZONED_DATE_TIME_YEAR_OFFSET
    + ZONED_DATE_TIME_YEAR_LENGTH;
const ZONED_DATE_TIME_DAY_OF_MONTH_OFFSET: u16
    = ZONED_DATE_TIME_MONTH_OFFSET
    + ZONED_DATE_TIME_MONTH_LENGTH;
const ZONED_DATE_TIME_HOUR_OFFSET: u16
    = ZONED_DATE_TIME_DAY_OF_MONTH_OFFSET
    + ZONED_DATE_TIME_DAY_OF_MONTH_LENGTH;
const ZONED_DATE_TIME_MINUTE_OFFSET: u16
    = ZONED_DATE_TIME_HOUR_OFFSET
    + ZONED_DATE_TIME_HOUR_LENGTH;
const ZONED_DATE_TIME_SECOND_OFFSET: u16
    = ZONED_DATE_TIME_MINUTE_OFFSET
    + ZONED_DATE_TIME_MINUTE_LENGTH;
const ZONED_DATE_TIME_NANO_OF_SECOND_OFFSET: u16
    = ZONED_DATE_TIME_SECOND_OFFSET
    + ZONED_DATE_TIME_SECOND_LENGTH;
const ZONED_DATE_TIME_ZONE_OFFSET_SECONDS_OFFSET: u16
    = ZONED_DATE_TIME_NANO_OF_SECOND_OFFSET
    + ZONED_DATE_TIME_NANO_OF_SECOND_LENGTH;
const ZONED_DATE_TIME_ZONE_ID_HASH_OFFSET: u16
    = ZONED_DATE_TIME_ZONE_OFFSET_SECONDS_OFFSET
    + ZONED_DATE_TIME_ZONE_OFFSET_SECONDS_LENGTH;
const ZONED_DATE_TIME_LENGTH: u16
    = ZONED_DATE_TIME_ZONE_ID_HASH_OFFSET
    + ZONED_DATE_TIME_ZONE_ID_HASH_LENGTH;

type SerializedZonedDateTime = [u8; ZONED_DATE_TIME_LENGTH];

struct ZonedDateTime {
    year: u32,
    month: u8,
    day_of_month: u8,
    hour: u8,
    minute: u8,
    second: u8,
    nano_of_second: u32,
    zone_offset_seconds: u32,
    zone_id_hash: u32
}

impl ZonedDateTime {
    fn _extract_u32(serialized_zdt: SerializedZonedDateTime, offset: u16) -> u32 {
        let mut result: u32 = 0;
        for i in 0..U32_BYTES {
            result = result * 256 as u32 + serialized_zdt[i + offset] as u32;
        }
        result
    }

    fn deserialize(serialized_zdt: SerializedZonedDateTime) -> ZonedDateTime {
        ZonedDateTime {
            year: _extract_u32(serialized_zdt, ZONED_DATE_TIME_YEAR_OFFSET),
            month: serialized_zdt[ZONED_DATE_TIME_MONTH_OFFSET],
            day_of_month: serialized_zdt[ZONED_DATE_TIME_DAY_OF_MONTH_OFFSET],
            hour: serialized_zdt[ZONED_DATE_TIME_HOUR_OFFSET],
            minute: serialized_zdt[ZONED_DATE_TIME_MINUTE_OFFSET],
            second: serialized_zdt[ZONED_DATE_TIME_SECOND_OFFSET],
            nano_of_second: _extract_u32(serialized_zdt, ZONED_DATE_TIME_NANO_OF_SECOND_OFFSET),
            zone_offset_seconds: _extract_u32(serialized_zdt, ZONED_DATE_TIME_ZONE_OFFSET_SECONDS_OFFSET),
            zone_id_hash: _extract_u32(serialized_zdt, ZONED_DATE_TIME_ZONE_ID_HASH_OFFSET),
        }
    }
}
