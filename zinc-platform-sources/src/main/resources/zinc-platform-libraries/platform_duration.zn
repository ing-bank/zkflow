//    val seconds: Long,
//    val nanos: Int

mod platform_consts;

use platform_consts::BYTE_BITS;
use platform_consts::U32_BITS;
use platform_consts::U32_BYTES;
use platform_consts::U64_BITS;
use platform_consts::U64_BYTES;

//! Duration field byte sizes
const DURATION_SECONDS_LENGTH: u16 = U64_BYTES;
const DURATION_NANOS_LENGTH: u16 = U32_BYTES;

//! Duration field offsets
const DURATION_SECONDS_OFFSET: u16 = 0;
const DURATION_NANOS_OFFSET: u16
    = DURATION_SECONDS_OFFSET
    + DURATION_SECONDS_LENGTH;
const DURATION_LENGTH: u16
    = DURATION_NANOS_OFFSET
    + DURATION_NANOS_LENGTH;

type SerializedDuration = [u8; DURATION_LENGTH];

struct Duration {
    seconds: u64,
    nanos: u32,
}

impl Duration {
    fn zero() -> Duration {
        Duration { seconds: 0 as u64, nanos: 0 as u32 }
    }

    fn equals(this: Duration, that: Duration) -> bool {
        this.seconds == that.seconds
            && this.nanos == that.nanos
    }

    fn _extract_u32(bytes: SerializedDuration, offset: u16) -> u32 {
        let mut bits = [false; U32_BITS];
        for i in 0..U32_BYTES {
            let pre_bits = std::convert::to_bits(bytes[i + offset]);

            for j in 0..BYTE_BITS {
                bits[i * BYTE_BITS + j] = pre_bits[j];
            }
        }
        std::convert::from_bits_unsigned(bits)
    }

    fn _extract_u64(bytes: SerializedDuration, offset: u16) -> u64 {
        let mut bits = [false; U64_BITS];
        for i in 0..U64_BYTES {
            let pre_bits = std::convert::to_bits(bytes[i + offset]);

            for j in 0..BYTE_BITS {
                bits[i * BYTE_BITS + j] = pre_bits[j];
            }
        }
        std::convert::from_bits_unsigned(bits)
    }

    fn deserialize(serialized_duration: SerializedDuration) -> Duration {
        Duration {
            seconds: _extract_u64(serialized_duration, DURATION_SECONDS_OFFSET),
            nanos: _extract_u32(serialized_duration, DURATION_NANOS_OFFSET),
        }
    }
}
