// val fromTime: @Contextual Instant?,
// val untilTime: @Contextual Instant?

mod platform_instant;
mod nullable_instant;

use platform_instant::Instant;
use nullable_instant::NullableInstant;
use nullable_instant::NULLABLE_INSTANT_LENGTH;

type SerializedTimeWindow = [u8; NULLABLE_INSTANT_LENGTH + NULLABLE_INSTANT_LENGTH];

struct TimeWindow {
    from_time: NullableInstant,
    until_time: NullableInstant,
}

impl TimeWindow {
    fn equals(this: TimeWindow, that: TimeWindow) -> bool {
        NullableInstant::equals(this.from_time, that.from_time)
            && NullableInstant::equals(this.until_time, that.until_time)
    }

    fn deserialize(serialized_time_window: SerializedTimeWindow) -> TimeWindow {
        let from_time = {
            // Name scoping does not work!
            // `from_time_buffer` must be called differently from `from_time`.
            let mut from_time_buffer = [0 as u8; NULLABLE_INSTANT_LENGTH];
            for i in 0..NULLABLE_INSTANT_LENGTH {
                from_time_buffer[i] = serialized_time_window[i];
            }
            NullableInstant::deserialize(from_time_buffer)
        };

        let until_time = {
            let mut until_time_buffer = [0 as u8; NULLABLE_INSTANT_LENGTH];
            for i in 0..NULLABLE_INSTANT_LENGTH {
                until_time_buffer[i] = serialized_time_window[NULLABLE_INSTANT_LENGTH + i];
            }
            NullableInstant::deserialize(until_time_buffer)
        };

        TimeWindow {
            from_time: from_time,
            until_time: until_time,
        }
    }

    fn contains(this: TimeWindow, instant: Instant) -> bool {
        // Matching on tuples does not work.
        if !this.from_time.is_null && !this.until_time.is_null {
            Instant::geq(instant, this.from_time.inner)
                && Instant::le(instant, this.until_time.inner)
        } else if !this.from_time.is_null {
            Instant::geq(instant, this.from_time.inner)
        } else if !this.until_time.is_null {
            Instant::le(instant, this.until_time.inner)
        } else {
            assert!(false, "Both `from_time` and `until_time` are nulls");
            false
        }
    }
}
