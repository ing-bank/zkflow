//    val seconds: Long,
//    val nanos: Int

mod platform_consts;

use platform_consts::BYTE_BITS;
use platform_consts::U32_BITS;
use platform_consts::U32_BYTES;
use platform_consts::U64_BITS;
use platform_consts::U64_BYTES;

//! Instant field byte sizes
const INSTANT_SECONDS_LENGTH: u16 = U64_BYTES;
const INSTANT_NANOS_LENGTH: u16 = U32_BYTES;

//! Instant field offsets
const INSTANT_SECONDS_OFFSET: u16 = 0;
const INSTANT_NANOS_OFFSET: u16
    = INSTANT_SECONDS_OFFSET
    + INSTANT_SECONDS_LENGTH;
const INSTANT_LENGTH: u16
    = INSTANT_NANOS_OFFSET
    + INSTANT_NANOS_LENGTH;

type SerializedInstant = [u8; INSTANT_LENGTH];

struct Instant {
    seconds: u64,
    nanos: u32,
}

impl Instant {
    fn zero() -> Instant {
        Instant { seconds: 0 as u64, nanos: 0 as u32 }
    }

    fn _extract_u32(bytes: SerializedInstant, offset: u16) -> u32 {
        let mut bits = [false; U32_BITS];
        for i in 0..U32_BYTES {
            let pre_bits = std::convert::to_bits(bytes[i + offset]);

            for j in 0..BYTE_BITS {
                bits[i * BYTE_BITS + j] = pre_bits[j];
            }
        }
        std::convert::from_bits_unsigned(bits)
    }

    fn _extract_u64(bytes: SerializedInstant, offset: u16) -> u64 {
        let mut bits = [false; U64_BITS];
        for i in 0..U64_BYTES {
            let pre_bits = std::convert::to_bits(bytes[i + offset]);

            for j in 0..BYTE_BITS {
                bits[i * BYTE_BITS + j] = pre_bits[j];
            }
        }
        std::convert::from_bits_unsigned(bits)
    }

    fn deserialize(serialized_instant: SerializedInstant) -> Instant {
        Instant {
            seconds: _extract_u64(serialized_instant, INSTANT_SECONDS_OFFSET),
            nanos: _extract_u32(serialized_instant, INSTANT_NANOS_OFFSET),
        }
    }

    /// 1 if x > y
    /// 2 if x < y
    /// 0, otherwise
    fn _compare_to(this: Instant, other: Instant) -> u8 {
        if this.seconds > other.seconds {
            1 as u8
        } else if this.seconds < other.seconds {
            2 as u8
        } else if this.nanos > other.nanos {
            1 as u8
        } else if this.nanos < other.nanos {
            2 as u8
        } else {
            0 as u8
        }
    }

    fn le(this: Instant, other: Instant) -> bool {
        Instant::_compare_to(this, other) == 2
    }

    fn leq(this: Instant, other: Instant) -> bool {
        let cmp = Instant::_compare_to(this, other);
        cmp == 2 || cmp == 0
    }

    fn ge(this: Instant, other: Instant) -> bool {
        Instant::le(other, this)
    }

    fn geq(this: Instant, other: Instant) -> bool {
        Instant::leq(other, this)
    }
}
