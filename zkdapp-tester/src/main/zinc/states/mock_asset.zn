mod platform_consts;
mod anonymous_party_ed_dsa;
mod anonymous_party_ed_dsa_collection_1;
mod platform_integer;

use platform_consts::U32_BYTES;
use platform_consts::I32_BYTES;
use platform_consts::LIST_LENGTH_PREFIX;
use platform_consts::CORDA_SERDE_MAGIC_LENGTH;
use anonymous_party_ed_dsa::AnonymousPartyEdDSA;
use anonymous_party_ed_dsa::ANONYMOUS_PARTY_ED_DSA_LENGTH;
use anonymous_party_ed_dsa_collection_1::AnonymousPartyEdDSA_Collection_1;
use anonymous_party_ed_dsa_collection_1::ANONYMOUS_PARTY_ED_DSA_COLLECTION_1_LENGTH;

// data class MockAsset(
//     override val owner: AnonymousParty,
//     val value: Int = Random().nextInt()
// ) : ZKOwnableState {
//
//    @FixedLength([1])
//    override val participants: List<AnonymousParty> = listOf(owner)
//
// }

//! MockAsset lengths
const OWNER_LENGTH: u16 = ANONYMOUS_PARTY_ED_DSA_LENGTH;
const VALUE_LENGTH: u16 = I32_BYTES;
const PARTICIPANTS_LENGTH: u16 = ANONYMOUS_PARTY_ED_DSA_COLLECTION_1_LENGTH;

//! MockAsset offsets
const OWNER_OFFSET: u16 = 0;
const VALUE_OFFSET: u16
    = OWNER_OFFSET
    + OWNER_LENGTH;
const PARTICIPANTS_OFFSET: u16
    = VALUE_OFFSET
    + VALUE_LENGTH;
const TEST_STATE_LENGTH: u16
    = PARTICIPANTS_OFFSET
    + PARTICIPANTS_LENGTH;

struct MockAsset {
    owner: AnonymousPartyEdDSA,
    value: i32,
    participants: AnonymousPartyEdDSA_Collection_1,
}

type SerializedMockAsset = [u8; TEST_STATE_LENGTH];

impl MockAsset {
    fn deserialize(serialized: SerializedMockAsset) -> MockAsset {
        let owner = {
            let mut owner_bytes = [0; ANONYMOUS_PARTY_ED_DSA_LENGTH];
            for i in 0..ANONYMOUS_PARTY_ED_DSA_LENGTH {
                owner_bytes[i] = serialized[i + OWNER_OFFSET];
            }
            AnonymousPartyEdDSA::deserialize(owner_bytes)
        };
        dbg!("[Create] Owner = {}", owner);

        let value = {
            let mut value_bytes = [0; I32_BYTES];
            for i in 0..VALUE_LENGTH {
                value_bytes[i] = serialized[i + VALUE_OFFSET];
            }
            platform_integer::parse_i32(value_bytes)
        };
        dbg!("[Create] Value = {}", value);

        let participants = {
            let mut participants_bytes = [0; ANONYMOUS_PARTY_ED_DSA_COLLECTION_1_LENGTH];
            for i in 0..ANONYMOUS_PARTY_ED_DSA_COLLECTION_1_LENGTH {
                participants_bytes[i] = serialized[i + PARTICIPANTS_OFFSET];
            }
            AnonymousPartyEdDSA_Collection_1::deserialize(participants_bytes)
        };
        dbg!("[Create] Participants = {}", participants);

        MockAsset {
            owner: owner,
            value: value,
            participants: participants,
        }
    }

    fn equals(this: MockAsset, that: MockAsset) -> bool {
        AnonymousPartyEdDSA::equals(this.owner, that.owner) &&
            this.value == that.value &&
            AnonymousPartyEdDSA_Collection_1::equals(this.participants, that.participants)
    }
}
