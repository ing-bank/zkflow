//!
//! The 'BigDecimal' main module.
//!

const INTEGER_SIZE: u16 = 1024;
const FRACTION_SIZE: u8 = 128;

//Original BigDecimal in Java stores all digits in one array, and uses scale as a number of digits to the right side of
//the decimal point. Then it calculates difference in scale of two comparing BigDecimals to adjust digits.
//For example:
//1.2, which is an array of [1, 2] and scale 1, plus 10, which is an array [1, 0], but scale 0.
//So, arrays must be adjusted w.r.t. scales. Then arithmetic operations can be applied.
//
//However, zinc doesn't support indexes inferred from witnesses (|scale_A - scale_B|), so we use two separate arrays to
//store integer value of BigDecimal and its fraction. It is stored in little-Endian order.
struct BigDecimal {
    sign: i8,
    integer: [u8; INTEGER_SIZE],
    fraction: [u8; FRACTION_SIZE]
}

impl BigDecimal {

    fn compare_magnitude(this: BigDecimal, that: BigDecimal) -> i8 {
        let mut result: i8 = 0 as i8;
        for i in 0..INTEGER_SIZE {
            if result == 0 as i8 {
                result = if this.integer[i] > that.integer[i] {
                    1 as i8
                } else {
                    if this.integer[i] < that.integer[i] {
                        -1
                    } else {
                        0 as i8
                    }
                };
            }
        }

        if result == 0 as i8 {
            for i in 0..FRACTION_SIZE {
                if result == 0 as i8 {
                    result = if this.fraction[i] > that.fraction[i] {
                        1 as i8
                    } else {
                        if this.fraction[i] < that.fraction[i] {
                            -1
                        } else {
                            0 as i8
                        }
                    };
                }
            }
            result
        } else {
            result
        }
    }

    fn sum_abs(this: BigDecimal, that: BigDecimal) -> BigDecimal {
        let mut fraction: [u8; FRACTION_SIZE] = [0; FRACTION_SIZE];
        let mut diff = 0 as i8;
        let mut all_zeros = true;

        for i in 0..FRACTION_SIZE {
            let value = this.fraction[FRACTION_SIZE - i - 1] as i8 + that.fraction[FRACTION_SIZE - i - 1] as i8 + diff;
            if value >= 10 as i8 {
                diff = 1 as i8;
                fraction[FRACTION_SIZE - i - 1] = (value - 10 as i8) as u8;
            } else {
                diff = 0 as i8;
                fraction[FRACTION_SIZE - i - 1] = value as u8;
                if all_zeros && value != 0 as i8 {
                    all_zeros = all_zeros && false;
                }
            }
        }

        let mut integer: [u8; INTEGER_SIZE] = [0; INTEGER_SIZE];
        for i in 0..INTEGER_SIZE {
            let value = this.integer[INTEGER_SIZE - i - 1 as u16] as i8 + that.integer[INTEGER_SIZE - i - 1 as u16] as i8 + diff;
            if value >= 10 as i8 {
                diff = 1 as i8;
                integer[INTEGER_SIZE - i - 1 as u16] = (value - 10 as i8) as u8;
            } else {
                diff = 0 as i8;
                integer[INTEGER_SIZE - i - 1 as u16] = value as u8;
                if all_zeros && value != 0 as i8 {
                    all_zeros = all_zeros && false;
                }
            }
        }

        assert!(diff != 1 as i8, "Magnitude exceeds the maximum stored value");

        BigDecimal {
            sign: 1 as i8,
            integer: integer,
            fraction: fraction,
        }
    }

    fn subtract_magnitude(this: BigDecimal, that: BigDecimal) -> BigDecimal {
        let mut fraction: [u8; FRACTION_SIZE] = [0; FRACTION_SIZE];
        let mut diff = 0 as i8;
        let mut all_zeros = true;
        for i in 0..FRACTION_SIZE {
            let value = this.fraction[FRACTION_SIZE - i - 1] as i8 - that.fraction[FRACTION_SIZE - i - 1] as i8 - diff;
            if value < 0 as i8 {
                diff = 1 as i8;
                fraction[FRACTION_SIZE - i - 1] = (10 as i8 + value) as u8;
            } else {
                diff = 0 as i8;
                fraction[FRACTION_SIZE - i - 1] = value as u8;
                if all_zeros && value != 0 as i8 {
                    all_zeros = all_zeros && false;
                }
            }
        }

        let mut integer: [u8; INTEGER_SIZE] = [0; INTEGER_SIZE];
        for i in 0..INTEGER_SIZE {
            let value = this.integer[INTEGER_SIZE - i - 1 as u16] as i8 - that.integer[INTEGER_SIZE - i - 1 as u16] as i8 - diff;
            if all_zeros && value != 0 as i8 {
                all_zeros = all_zeros && false;
            };
            if value < 0 as i8 {
                diff = 1 as i8;
                integer[INTEGER_SIZE - i - 1 as u16] = (10 as i8 + value) as u8;
            } else {
                diff = 0 as i8;
                integer[INTEGER_SIZE - i - 1 as u16] = value as u8;
            }
        }

        let sign = if diff == 1 as i8 {
            -1
        } else {
            if all_zeros {
                0 as i8
            } else {
                1 as i8
            }
        };

        BigDecimal {
            sign: sign,
            integer: integer,
            fraction: fraction,
        }
    }

    fn handle_different_signs(this: BigDecimal, that: BigDecimal) -> BigDecimal {
        if that.sign == 0 as i8 {
            BigDecimal {
                sign: this.sign,
                integer: this.integer,
                fraction: this.fraction,
            }
        } else {
            if this.sign == 0 as i8 {
                BigDecimal {
                    sign: -that.sign,
                    integer: that.integer,
                    fraction: that.fraction,
                }
            } else {
                let absolute_sum: BigDecimal = sum_abs(this, that);
                BigDecimal {
                    sign: this.sign,
                    integer: absolute_sum.integer,
                    fraction: absolute_sum.fraction,
                }
            }
        }
    }

    fn handle_the_same_sign(this: BigDecimal, that: BigDecimal) -> BigDecimal {
        let comparison = compare_magnitude(this, that);
        if comparison == 0 as i8 {
            BigDecimal {
                sign: 0 as i8,
                integer: [0; INTEGER_SIZE],
                fraction: [0; FRACTION_SIZE],
            }
        } else {
            let absolute_diff = if comparison == 1 as i8 {
                subtract_magnitude(this, that)
            } else {
                subtract_magnitude(that, this)
            };
            BigDecimal {
                sign: comparison * this.sign,
                integer: absolute_diff.integer,
                fraction: absolute_diff.fraction,
            }
        }
    }

    fn minus(this: BigDecimal, that: BigDecimal) -> BigDecimal {
        if this.sign == that.sign {
            handle_the_same_sign(this, that)
        } else {
            handle_different_signs(this, that)
        }
    }
}

fn main(left: BigDecimal, right: BigDecimal) -> BigDecimal {
    BigDecimal::minus(left, right)
}
