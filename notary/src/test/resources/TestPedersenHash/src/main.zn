use std::array::pad;
use std::convert::to_bits;
use std::crypto::pedersen;

const BYTE_BITS: u16 = 8;
const PREIMAGE_BYTES: u16 = 4;
const PREIMAGE_BITS: u16 = PREIMAGE_BYTES * BYTE_BITS;
const HASH_BYTES: u16 = 32;
const HASH_BITS: u16 = HASH_BYTES * BYTE_BITS;
const FIELD_SIZE: u16 = 254;

/**
 * Pads left with 0-bits until HASH_BITS size
 */
fn toPaddedBits(digest: field) -> [bool; HASH_BITS]
{
    let mut digest_bits = [false; HASH_BITS];
    let pedersen_bits = to_bits(digest);

    let offset = HASH_BITS - FIELD_SIZE;
    for i in 0..FIELD_SIZE {
        digest_bits[(offset as u16) + i] = pedersen_bits[i];
    }

    digest_bits
}

fn main(preimage: [u8; PREIMAGE_BYTES]) -> [u8; HASH_BYTES] {
    dbg!("preimage: {}", preimage);

    let mut preimage_bits = [false; PREIMAGE_BITS];
    for j in 0..PREIMAGE_BYTES {
        let preimage_byte_bits = to_bits(preimage[j]);
        for k in 0..BYTE_BITS {
            preimage_bits[BYTE_BITS * j + k] = preimage_byte_bits[k];
        }
    }
    dbg!("preimage_bits: {}", preimage_bits);

    let mut hash_bits = toPaddedBits(pedersen(preimage_bits).0);
    dbg!("hash_bits: {}", hash_bits);

    let mut hash_bytes = [0 as u8; HASH_BYTES];

    for i in 0..HASH_BYTES {
        let mut byte_bits = [false; BYTE_BITS];
        for j in 0..BYTE_BITS {
            byte_bits[j] = hash_bits[BYTE_BITS * i + j];
        }
        hash_bytes[i] = std::convert::from_bits_unsigned(byte_bits);
    }

    hash_bytes
}
