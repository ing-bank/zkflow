mod platform_consts;
mod platform_integer;
mod string_20;

use platform_consts::U32_BYTES;

use platform_integer::parse_u32;

use string_20::String_20;
use string_20::STRING_20_LENGTH;


const CLAIM_U32_PROPERTY_LENGTH: u16 = STRING_20_LENGTH;
const CLAIM_U32_VALUE_LENGTH: u16 = U32_BYTES;

const CLAIM_U32_PROPERTY_OFFSET: u16 = 0;
const CLAIM_U32_VALUE_OFFSET: u16
    = CLAIM_U32_PROPERTY_OFFSET
    + CLAIM_U32_PROPERTY_LENGTH;
const CLAIM_U32_LENGTH: u16
    = CLAIM_U32_VALUE_OFFSET
    + CLAIM_U32_VALUE_LENGTH;

type SerializedClaimU32 = [u8; CLAIM_U32_LENGTH];

struct ClaimU32 {
    property: String_20,
    value: u32,
}

impl ClaimU32 {
    fn print_structure() {
        dbg!("Size of ClaimU32");
        dbg!("- LENGTH: {}", CLAIM_U32_LENGTH);
        dbg!("Structure of ClaimU32");
        dbg!("- PROPERTY: {}", CLAIM_U32_PROPERTY_LENGTH);
        dbg!("- VALUE:    {}", CLAIM_U32_VALUE_LENGTH);
        dbg!("");
    }

    fn empty() -> ClaimU32 {
        ClaimU32 {
            property: String_20::empty(),
            value: 0 as u32,
        }
    }

    fn equals(this: ClaimU32, that: ClaimU32) -> bool {
        String_20::equals(this.property, that.property)
            && this.value == that.value
    }

    fn deserialize(serialized: SerializedClaimU32) -> ClaimU32 {
        let property = {
            let mut property_bytes = [0; CLAIM_U32_PROPERTY_LENGTH];
            for i in 0..CLAIM_U32_PROPERTY_LENGTH {
                property_bytes[i] = serialized[i + CLAIM_U32_PROPERTY_OFFSET];
            }
            String_20::deserialize(property_bytes)
        };

        let value = {
            let mut value_bytes = [0; CLAIM_U32_VALUE_LENGTH];
            for i in 0..CLAIM_U32_VALUE_LENGTH {
                value_bytes[i] = serialized[i + CLAIM_U32_VALUE_OFFSET];
            }
            parse_u32(value_bytes)
        };

        ClaimU32 {
            property: property,
            value: value,
        }
    }
}
