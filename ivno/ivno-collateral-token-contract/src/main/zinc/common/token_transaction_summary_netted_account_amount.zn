mod account_address;
mod big_decimal_amount_token_descriptor;

use account_address::AccountAddress;
use account_address::ACCOUNT_ADDRESS_LENGTH;

use big_decimal_amount_token_descriptor::BigDecimalAmountTokenDescriptor;
use big_decimal_amount_token_descriptor::BIG_DECIMAL_AMOUNT_TOKEN_DESCRIPTOR_LENGTH;

const TOKEN_TRANSACTION_SUMMARY_NETTED_ACCOUNT_AMOUNT_ACCOUNT_ADDRESS_LENGTH: u16 = ACCOUNT_ADDRESS_LENGTH;
const TOKEN_TRANSACTION_SUMMARY_NETTED_ACCOUNT_AMOUNT_AMOUNT_LENGTH: u16 = BIG_DECIMAL_AMOUNT_TOKEN_DESCRIPTOR_LENGTH;

const TOKEN_TRANSACTION_SUMMARY_NETTED_ACCOUNT_AMOUNT_ACCOUNT_ADDRESS_OFFSET: u16 = 0;
const TOKEN_TRANSACTION_SUMMARY_NETTED_ACCOUNT_AMOUNT_AMOUNT_OFFSET: u16
    = TOKEN_TRANSACTION_SUMMARY_NETTED_ACCOUNT_AMOUNT_ACCOUNT_ADDRESS_OFFSET
    + TOKEN_TRANSACTION_SUMMARY_NETTED_ACCOUNT_AMOUNT_ACCOUNT_ADDRESS_LENGTH;
const TOKEN_TRANSACTION_SUMMARY_NETTED_ACCOUNT_AMOUNT_LENGTH: u16
    = TOKEN_TRANSACTION_SUMMARY_NETTED_ACCOUNT_AMOUNT_AMOUNT_OFFSET
    + TOKEN_TRANSACTION_SUMMARY_NETTED_ACCOUNT_AMOUNT_AMOUNT_LENGTH;

type SerializedTokenTransactionSummaryNettedAccountAmount = [u8; TOKEN_TRANSACTION_SUMMARY_NETTED_ACCOUNT_AMOUNT_LENGTH];

struct TokenTransactionSummaryNettedAccountAmount {
    address: AccountAddress,
    amount: BigDecimalAmountTokenDescriptor,
}

impl TokenTransactionSummaryNettedAccountAmount {
    fn empty() -> TokenTransactionSummaryNettedAccountAmount {
        TokenTransactionSummaryNettedAccountAmount {
            address: AccountAddress::empty(),
            amount: BigDecimalAmountTokenDescriptor::empty(),
        }
    }

    fn equals(this: TokenTransactionSummaryNettedAccountAmount, that: TokenTransactionSummaryNettedAccountAmount) -> bool {
        AccountAddress::equals(this.address, that.address)
            && BigDecimalAmountTokenDescriptor::equals(this.amount, that.amount)
    }

    fn deserialize(serialized: SerializedTokenTransactionSummaryNettedAccountAmount) -> TokenTransactionSummaryNettedAccountAmount {
        let address = {
            let mut account_address_bytes = [0; TOKEN_TRANSACTION_SUMMARY_NETTED_ACCOUNT_AMOUNT_ACCOUNT_ADDRESS_LENGTH];
            for i in 0..TOKEN_TRANSACTION_SUMMARY_NETTED_ACCOUNT_AMOUNT_ACCOUNT_ADDRESS_LENGTH {
                account_address_bytes[i] = serialized[i + TOKEN_TRANSACTION_SUMMARY_NETTED_ACCOUNT_AMOUNT_ACCOUNT_ADDRESS_OFFSET];
            }
            AccountAddress::deserialize(account_address_bytes)
        };
        let amount = {
            let mut amount_bytes = [0; TOKEN_TRANSACTION_SUMMARY_NETTED_ACCOUNT_AMOUNT_AMOUNT_LENGTH];
            for i in 0..TOKEN_TRANSACTION_SUMMARY_NETTED_ACCOUNT_AMOUNT_AMOUNT_LENGTH {
                amount_bytes[i] = serialized[i + TOKEN_TRANSACTION_SUMMARY_NETTED_ACCOUNT_AMOUNT_AMOUNT_OFFSET];
            }
            BigDecimalAmountTokenDescriptor::deserialize(amount_bytes)
        };

        TokenTransactionSummaryNettedAccountAmount {
            address: address,
            amount: amount,
        }
    }
}