mod nullable_byte_array_100;

use nullable_byte_array_100::NullableByteArray_100;
use nullable_byte_array_100::SerializedNullableByteArray_100;
use nullable_byte_array_100::NULLABLE_BYTE_ARRAY_100_LENGTH;

// field lengths
const TOKEN_CONTRACT_COMMAND_MOVE_CONTRACT_CLASS_NAME_LENGTH: u16 = NULLABLE_BYTE_ARRAY_100_LENGTH;

// field offsets
const TOKEN_CONTRACT_COMMAND_MOVE_CONTRACT_CLASS_NAME_OFFSET: u16
    = 0;

const TOKEN_CONTRACT_COMMAND_MOVE_LENGTH: u16
    = TOKEN_CONTRACT_COMMAND_MOVE_CONTRACT_CLASS_NAME_OFFSET
    + TOKEN_CONTRACT_COMMAND_MOVE_CONTRACT_CLASS_NAME_LENGTH;

type SerializedTokenContractCommandMove = [u8; TOKEN_CONTRACT_COMMAND_MOVE_LENGTH];

struct TokenContractCommandMove {
    contract_class_name: NullableByteArray_100,
}

impl TokenContractCommandMove {
    fn empty() -> TokenContractCommandMove {
        TokenContractCommandMove {
            contract_class_name: NullableByteArray_100::null(),
        }
    }

    fn equals(this: TokenContractCommandMove, that: TokenContractCommandMove) -> bool {
        NullableByteArray_100::equals(this.contract_class_name, that.contract_class_name)
    }

    fn deserialize(serialized: SerializedTokenContractCommandMove) -> TokenContractCommandMove {
        let contract_class_name = {
            let mut contract_class_name_bytes = [0; TOKEN_CONTRACT_COMMAND_MOVE_CONTRACT_CLASS_NAME_LENGTH];
            for i in 0..TOKEN_CONTRACT_COMMAND_MOVE_CONTRACT_CLASS_NAME_LENGTH {
                contract_class_name_bytes[i] = serialized[i + TOKEN_CONTRACT_COMMAND_MOVE_CONTRACT_CLASS_NAME_OFFSET];
            }
            NullableByteArray_100::deserialize(contract_class_name_bytes)
        };

        TokenContractCommandMove {
            contract_class_name: contract_class_name,
        }
    }
}
